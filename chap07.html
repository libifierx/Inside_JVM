<!-- All material contained herein is copyright (c) McGraw-Hill Professional Books
All Rights Reserved. No use of this material may be made without express written
permission of the copyright holder. HTML conversions by Mega Space [barry@megaspace.com] -->

<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=ISO-8859-1">
<TITLE>Understanding Digital Signatures: Inside the Java Virtual Machine
 by Bill Venners - Beta Version</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<TABLE BORDER="0" WIDTH="100%">
<TR><TD><A HREF="http://www.pbg.mcgraw-hill.com/betabooks/stores.html" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/stores.html" target="bottom"><IMG SRC="hotkey.gif" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/images/hotkey.gif" ALIGN="LEFT" BORDER="0" WIDTH="40" HEIGHT="40" ALT="Orders"></A>
<IMG SRC="order_text.gif" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/images/order_text.gif" WIDTH="103" HEIGHT="41" ALT="Orders"></TD>
<TD ALIGN="RIGHT"><A HREF="chap06.html" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/venners/chap06.html"><IMG SRC="backward.gif" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/images/backward.gif" BORDER="0" ALT="Backward" WIDTH="32" HEIGHT="32"></A>&nbsp;<A HREF="chap08.html" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/venners/chap08.html"><IMG SRC="forward.gif" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/images/forward.gif" BORDER="0" ALT="Forward" WIDTH="32" HEIGHT="32"></A></TD></TR>
<TR><TD COLSPAN="2"><A HREF="mailto:computing@mcgraw-hill.com"><IMG SRC="hotkey.gif" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/images/hotkey.gif" ALIGN="LEFT" BORDER="0" WIDTH="40" HEIGHT="40" ALT="Comments"></A>
<IMG SRC="comment_text.gif" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/images/comment_text.gif" WIDTH="73" HEIGHT="39" ALT="Comments"></TD></TR>

<TR><TD COLSPAN="2"><FONT FACE="ARIEL,HELVETICA" SIZE="-1"><I>&copy; 1997 The McGraw-Hill Companies, Inc.  All rights reserved.  <BR>Any use of this Beta Book is subject to the rules stated in the <A HREF="http://www.mcgraw-hill.com/corporate/news_info/copyrttm.htm" tppabs="http://www.mcgraw-hill.com/corporate/news_info/copyrttm.htm" target="_top">Terms of Use</A>.</I></FONT><br>
<script language="javascript">
    document.write("<a href='http://banners.linkbuddies.com/click.php?id=237296'><img src='http://banners.linkbuddies.com/image.php?id=237296&ref=" + document.referrer + "' width=468 height=60 alt='Click Here' border=0></a>");
</script></TD></TR>

</TABLE>
<HR>
<P><H1>Chapter Seven</H1></P>
<P><H2>The Lifetime of a Class</H2></P>
<P>The previous chapter described in detail the format of the Java class file, the standard binary form for representing Java types. This chapter looks at what happens when binary type data is imported into a Java Virtual Machine. The chapter follows the lifetime of a type (class or interface) from the typeís initial entrance into the virtual machine to its ultimate exit. It discusses the processes of loading, linking, and initialization that occur at the beginning of a classís lifetime; the processes of object instantiation, garbage collection, and finalization that can occur in the prime of a classís lifetime; and the finalization and unloading of types that can occur at the end of a classís lifetime.</P>
<H3><EM><P>Class Loading, Linking, and Initialization</P>
</EM></H3><P>The Java Virtual Machine makes types available to the running program through a process of <I>loading</I>, <I>linking</I>, and <I>initialization</I>. Loading is the process of bringing a binary form for a type into the Java Virtual Machine. Linking is the process of incorporating the binary type data into the runtime state of the virtual machine. Linking is divided into three sub-steps: <I>verification</I>, <I>preparation</I>, and <I>resolution</I>. Verification ensures the type is properly formed and fit for use by the Java Virtual Machine. Preparation involves allocating memory needed by the type, such as memory for any class variables. Resolution is the process of transforming symbolic references in the constant pool into direct references. Implementations may delay the resolution step until each symbolic reference is actually used by the running program. After verification, preparation, and (optionally) resolution are completed, the type is ready for initialization. During initialization, the class variables are given their proper initial values. See Figure 7-1 for a graphical depiction of this process.</P>
<P><IMG SRC="fig7-1.gif" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/venners/images/fig7-1.gif" ALT="Figure 7-1"></P>

<P>As you can see from Figure 7-1, the processes of (1) loading, (2) linking, and (3) initialization must take place in that order. The only exception to this required ordering is the third phase of linking, resolution, which may optionally take place after initialization.</P>
<P>The Java Virtual Machine specification gives implementations flexibility in the timing of class and interface loading and linking, but strictly defines the timing of initialization. All implementations must initialize each class and interface on its first <I>active use</I>. An active use of a class is:</P>
<UL><LI> The invocation of a constructor on a new instance of the class
<LI> The creation of an array that has the class as its an element type
<LI> The invocation of a method declared by the class (not inherited from a superclass)
<LI> The use or assignment of a field declared by the class (not inherited from a superclass or superinterface), except for fields that are both <FONT FACE="Courier New">static</FONT> and <FONT FACE="Courier New">final</FONT>, and are initialized by a compile-time constant expression</UL>
<P>An active use of an interface is:</P>
<UL><LI> The use or assignment of a field declared by the interface (not inherited from a superinterface), except for fields that are initialized by a compile-time constant expression</UL>
<P>All other uses of a type besides the five listed above are <I>passive uses</I> of the type. Several examples illustrating the difference between active and passive uses are given later in this chapter.</P>
<P>Aside from its own initial active use, there is one other situation that will cause the initialization of a class: the initial active use of one of its subclasses. Initialization of a class requires prior initialization of all its superclasses.</P>
<P>The same is not true of interfaces, however. An interface is initialized only because a non-constant field declared by the interface is used, never because a subinterface or class that implements the interface needs to be initialized. Thus, initialization of a class requires prior initialization of all its superclasses, but not its superinterfaces. Initialization of an interface does not require initialization of its superinterfaces.</P>
<P>The &quot;initialize on first active use&quot; rule drives the mechanism that loads, links, and initializes classes. On its first active use, a type must be initialized. Before it can be initialized, however, it must be linked. And before it can be linked, it must be loaded. At their option, implementations may load and link types early. They need not wait until the typeís first active use to load and link the type. If a type hasnít been loaded and linked before its first active use, however, it must be loaded and linked at that time, so that it can be initialized.</P>
<H3><P>Loading</P>
</H3><P>The loading process consists of three basic activities. To load a type, the Java Virtual Machine must:</P>
<UL><LI> produce a stream of binary data that represents the type
<LI> parse the stream of binary data into internal data structures in the method area
<LI> create an instance of class <FONT FACE="Courier New">java.lang.Class</FONT> that represents the type</UL>
<P>The stream of binary data may adhere to the Java class file format, but could alternatively follow some other format. As mentioned in previous chapters, all Java Virtual Machine implementations must recognize the Java class file format, but individual implementations may also recognize other binary formats.</P>
<P>The Java Virtual Machine specification does not say how the binary data for a type must be produced. Some potential ways to produce binary data for a type are:</P>
<UL><LI> load a Java class file from the local file system
<LI> download a Java class file across a network
<LI> extract a Java class file from a ZIP, JAR, CAB, or other archive file
<LI> extract a Java class file from a proprietary database
<LI> compile a Java source file on the fly into the class file format
<LI> compute the class file data for a type on the fly
<LI> any of the above, but using a binary file format other than the Java class file</UL>
<P>Given the binary data for a type, the Java Virtual Machine must process that data to a great enough extent that it can create an instance of class <FONT FACE="Courier New">java.lang.Class</FONT>. The virtual machine must parse the binary data into implementation-dependent internal data structures. (See Chapter 5, &quot;The Java Virtual Machine,&quot; for a discussion of potential internal data structures for storing class data.) The <FONT FACE="Courier New">Class</FONT> instance, the end product of the loading step, serves as an interface between the program and the internal data structures. To access information about a type that is stored in the internal data structures, the program invokes methods on the <FONT FACE="Courier New">Class</FONT> instance for that type.</P>
<P>As described in previous chapters, types are loaded either through the primordial class loader or through class loader objects. The primordial class loader, a part of the virtual machine implementation, loads types (including the classes and interfaces of the Java API) in an implementation-dependent way. Class loader objects, instances of subclasses of <FONT FACE="Courier New">java.lang.ClassLoader</FONT>, load classes in custom ways. The inner workings of class loader objects are described in more detail later in Chapter 8, &quot;The Linking Model.&quot;</P>
<P>Class loaders (primordial or object) need not wait until a typeís first active use before they load the type. Class loaders are allowed to cache binary representations of types, load types early in anticipation of eventual use, or load types together in related groups. If a class loader encounters a problem during early loading, however, it must report that problem (by throwing a subclass of <FONT FACE="Courier New">LinkageError</FONT>) only upon the typeís first active use. In other words, if a class loader encounters a missing or malformed class file during early loading, it must wait to report that error until the classís first active use by the program. If the class is never actively used by the program, the class loader will never report the error.</P>
<H3><P>Verification</P>
</H3><P>After a type is loaded, it is ready to be linked. The first step of the linking process is verification--ensuring that the type obeys the semantics of the Java language and that it wonít violate the integrity of the virtual machine.</P>
<P>Verification is another area in which implementations of the Java Virtual Machine have some flexibility. Implementation designers can decide how and when to verify types. The Java Virtual Machine specification lists all the exceptions that a virtual machine can throw and under what circumstances it must throw them. No matter what kind of trouble a Java Virtual Machine might encounter, there is an exception or error it is supposed to throw. The specification says what exception or error should be thrown in each situation. In some cases, the specification says exactly when the exception or error should be thrown, but usually doesnít dictate precisely how or when the error condition should be detected. </P>
<P>Nevertheless, certain kinds of checks are very likely to take place at certain times in most Java Virtual Machine implementations. For example, during the loading process, the virtual machine must parse the stream of binary data that represents the type and build internal data structures. At this point, certain checks will have to be done just to ensure the initial act of parsing the binary data wonít crash the virtual machine. During this parsing, implementations will likely check the binary data to make sure it has the expected overall format. Parsers of the Java class file format might check the magic number, make sure each component is in the right place and of the proper length, verify that the file isnít too short or too long, and so on. Although these checks take place during loading, before the official verification phase of linking, they are still logically part of the verification phase. The entire process of detecting any kind of problem with loaded types is placed under the category of verification.</P>
<P>Another check that likely occurs during loading is making sure that every class except <FONT FACE="Courier New">Object</FONT> has a superclass. This may be done during loading because when the virtual machine loads a class, it must also make sure all of the classís superclasses are loaded also. The only way a virtual machine can know the name of a given classís superclass is by peering into the binary data for the class. Since the virtual machine is looking at every classís superclass data during loading anyway, it may as well make this check during the loading phase.</P>
<P>Another check--one that likely occurs after the official verification phase in most implementations--is the verification of symbolic references. As described in earlier chapters, the process of dynamic linking involves locating classes, interfaces, fields, and methods referred to by symbolic references stored in the constant pool, and replacing the symbolic references with direct references. When the virtual machine searches for a symbolically referenced entity (type, field, or method), it must first make sure the entity exists. If the virtual machine finds that the entity exists, it must further check that the referencing type has permission to access the entity, given the entityís access permissions. These checks for existence and access permission are logically a part of verification, the first phase of linking, but most likely happen during resolution, the third phase of linking. Resolution itself can be delayed until each symbolic reference is first used by the program, so these checks may even take place after initialization.</P>
<P>So what gets checked during the official verification phase? Anything that hasnít already been checked before the official verification phase and that wonít get checked after it. Here two lists of some of the things that are good candidates for checking during the official verification phase. This first list is composed of checks that ensure classes are binary compatible with each other:</P>
<UL><LI> checking that final classes are not subclassed
<LI> checking that final methods are not overridden
<LI> if the type being checked is a non-abstract class, checking that all the methods declared in any interfaces implemented by the class are indeed implemented by the class
<LI> making sure no incompatible method declarations (such as two methods that have the same name, the same number, order, and types of parameters, but different return types) appear between the type and its supertypes</UL>
<P>Note that while these checks require looking at other types, they only require looking at supertypes. Superclasses need to be initialized before subclasses, so these classes are likely already loaded. Superinterfaces do not need to be initialized when a class that implements them is initialized. However, this verification step will require their loading. (They wonít be initialized, just loaded and possibly linked at the option of the virtual machine implementation.) All a classís supertypes will have to be loaded to make sure they are all still binary compatible.</P>
<UL><LI> checking that all constant pool entries are consistent with each other. (For example, the <FONT FACE="Courier New">string_index</FONT> item of a <FONT FACE="Courier New">CONSTANT_String_info</FONT> entry must be the index of a <FONT FACE="Courier New">CONSTANT_Utf8_info</FONT> entry.)
<LI> checking that all special strings contained in the constant pool (class names, field and method names, field and method descriptors) are well-formed
<LI> verifying the integrity of the bytecodes</UL>
<P>The most complicated task in the above list is the last one: bytecode verification. All Java Virtual Machines must in some way verify the integrity of the bytecodes for every method they execute. For example, implementations are not allowed to crash because a jump instruction sends the virtual machine beyond the end of a method. They must detect that the jump instruction is invalid through some process of bytecode verification, and throw an error.</P>
<P>Java Virtual Machine implementations are not required to verify bytecodes during the official verification phase of linking. Implementations are free, for example, to verify individual instructions as each instruction is executed. One of the design goals of the Java Virtual Machine instruction set, however, was that it yield bytecodes streams that can be verified all at once by a data flow analyzer. The ability to verify bytecode streams all at once during linking, rather than on the fly as the program runs, gives a big boost to the potential execution speed of Java programs.</P>
<P>When verifying bytecodes via a data flow analyzer, the virtual machine may have to load other classes to ensure that the semantics of the Java language are being followed. For example, imagine a class contained a method that assigned a reference to an instance of <FONT FACE="Courier New">java.lang.Float</FONT> to a field of type <FONT FACE="Courier New">java.lang.Number</FONT>. In this case, the virtual machine would have to load class <FONT FACE="Courier New">Float</FONT> during bytecode verification to make sure it was a subclass of class <FONT FACE="Courier New">Number</FONT>. It would have to load <FONT FACE="Courier New">Number</FONT> to make sure it wasnít declared final. The virtual machine must not initialize class <FONT FACE="Courier New">Float</FONT> at this time, just load it. <FONT FACE="Courier New">Float</FONT> will be initialized only upon its first active use.</P>
<P>For more information on the class verification process, see Chapter 3, &quot;Security.&quot;</P>
<H3><P>Preparation</P>
</H3><P>After a Java Virtual Machine has loaded a class and performed whatever verification it chooses to do up front, the class is ready for preparation. During the preparation phase, the Java Virtual Machine allocates memory for the class variables and sets them to default initial values. The class variables are not initialized to their proper initial values until the initialization phase. (No Java code is executed during the preparation step.) During preparation, the Java Virtual Machine sets the newly allocated memory for the class variables to a default value determined by the type of the variable. The default values for the various types are shown in Table 7-1.</P>
<P>Table 7-1. Default initial values for the primitive types</P>
<TABLE WIDTH="500">
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">int</FONT></TD><TD VALIGN="TOP"><FONT FACE="Courier New">0</FONT></TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">long</FONT></TD><TD VALIGN="TOP"><FONT FACE="Courier New">0L</FONT></TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">short</FONT></TD><TD VALIGN="TOP"><FONT FACE="Courier New">(short) 0</FONT></TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">char</FONT></TD><TD VALIGN="TOP"><FONT FACE="Courier New">'\u0000'</FONT></TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">byte</FONT></TD><TD VALIGN="TOP"><FONT FACE="Courier New">(byte) 0</FONT></TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">reference</FONT></TD><TD VALIGN="TOP"><FONT FACE="Courier New">null</FONT></TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">float</FONT></TD><TD VALIGN="TOP"><FONT FACE="Courier New">0.0f</FONT></TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">double</FONT></TD><TD VALIGN="TOP"><FONT FACE="Courier New">0.0d</FONT></TD></TR>
</TABLE>
<P>There is no <FONT FACE="Courier New">boolean</FONT> in Table 7-1, because <FONT FACE="Courier New">boolean</FONT> is not a primitive type in the Java Virtual Machine. Internally, <FONT FACE="Courier New">boolean</FONT> is implemented as an <FONT FACE="Courier New">int</FONT>, which gets set to zero (boolean <FONT FACE="Courier New">false</FONT>) by default. Therefore, <FONT FACE="Courier New">boolean</FONT> class variables are in effect initialized to boolean <FONT FACE="Courier New">false</FONT>.</P>
<P>During the preparation phase, Java Virtual Machine implementations may also allocate memory for data structures that are intended to improve the performance of the running program. An example of such a data structure is a method table, which contains a pointer to the data for every method in a class, including those inherited from its superclasses. A method table enables an inherited method to be invoked on an object without a search of superclasses at the point of invocation. Method tables are described in more detail in Chapter 8, &quot;The Linking Model.&quot;</P>
<H3><P>Resolution</P>
</H3><P>After a type has been through the first two phases of linking: verification and preparation, it is ready for the third and final phase of linking: resolution. Resolution is the process of locating classes, interfaces, fields, and methods referenced symbolically from a typeís constant pool, and replacing those symbolic references with direct references. As mentioned above, this phase of linking is optional until (and unless) each symbolic reference is first used by the program. Constant pool resolution is described in detail in Chapter 8, &quot;The Linking Model.&quot;</P>
<H3><P>Initialization</P>
</H3><P>The final step required to ready a class or interface for its first active use is initialization, the process of setting class variables to their proper initial values. As used here, a &quot;proper&quot; initial value is the programmerís desired starting value for a class variable. A proper initial value contrasts with the default initial value given to class variables during preparation. As described above, the virtual machine assigns default values based only on each variableís type. Proper initial values, by contrast, are based on some master plan known only to the programmer.</P>
<P>In Java code, a proper initial value is specified via a class variable initializer or static initializer. A class variable initializer is an equals sign and expression next to a class variable declaration, as in:</P>
<PRE><P><FONT FACE="Courier New">begin</FONT></P>
<FONT SIZE="2"><P></FONT><FONT FACE="Courier New">// On CD-ROM in file classlife/ex1/Example1a.java
<P>class Example1a {</P>
<P>&nbsp;</P>
<P>    // "= 3 * (int) (Math.random() * 5.0)" is the class variable</P>
<P>    // initializer</P>
<P>    static int size = 3 * (int) (Math.random() * 5.0);</P>
<P>}</P>
</FONT><FONT SIZE="2"><P>&nbsp;</P></FONT><FONT FACE="Courier New">end</FONT></P></PRE>
<P>A static initializer is a block of code introduced by the <FONT FACE="Courier New">static</FONT> keyword, as in:</P>
<PRE><P><FONT FACE="Courier New">begin</FONT></P>
<FONT SIZE="2"><P></FONT><FONT FACE="Courier New">// On CD-ROM in file classlife/ex1/Example1b.java
<P>class Example1b {</P>
<P>&nbsp;</P>
<P>    static int size;</P>
<P>&nbsp;</P>
<P>    // This is the static initializer</P>
<P>    static {</P>
<P>&nbsp;</P>
<P>        size = 3 * (int) (Math.random() * 5.0);</P>
<P>    }</P>
<P>}</P>
</FONT><FONT SIZE="2"><P>&nbsp;</P></FONT><FONT FACE="Courier New">end</FONT></P></PRE>
<P>All the class variable initializers and static initializers of a class are collected by the Java compiler and placed into one special method, the <I>class initialization method</I>. In the Java class file, the class initialization method is named &quot;<FONT FACE="Courier New">&lt;clinit</FONT>&quot;. Regular methods of a Java application cannot invoke a class initialization method. This kind of method can only be invoked by the Java Virtual Machine, which invokes it to set a classís static variables to their proper initial values.</P>
<P>Initialization of a class consists of two steps:</P>
<OL><LI>Initializing the classís direct superclass (if any), if the direct superclass hasnít already been initialized</P>
<LI>Executing the classís class initialization method, if it has one</OL>
<P>When initializing a classís direct superclass, the same two steps listed above must be followed. As a result, the first class that will be initialized will always be <FONT FACE="Courier New">Object</FONT>, then all the classes on down the inheritance hierarchy to the class being actively used. Superclasses will be initialized before subclasses.</P>
<P>Initialization of an interface does not require initialization of its superinterfaces. Initialization of an interface consists of only one step:</P>
<UL><LI> Executing the interfaceís class initialization method, if it has one</UL>
<P>The code of a <FONT FACE="Courier New">&lt;clinit</FONT>()</FONT> method does not explicitly invoke a superclassís <FONT FACE="Courier New">&lt;clinit</FONT>()</FONT> method. Before a Java Virtual Machine invokes the <FONT FACE="Courier New">&lt;clinit</FONT>()</FONT> method of a class, therefore, it must make certain the <FONT FACE="Courier New">&lt;clinit</FONT>()</FONT> methods of superclasses have been executed.</P>
<P>Java Virtual Machines must also make sure the initialization process is properly synchronized. If multiple threads need to initialize a class, only one thread should be allowed to perform the initialization while the other threads wait. After the active thread completes the initialization process, it must notify any waiting threads. See Chapter 20, &quot;Thread Synchronization,&quot; for information about synchronization, wait and notify.</P>
<P><H4><EM>The Class Initialization Method</P></EM></H4>
<P>As mentioned above, Java compilers place the code for class variable initializers and static initializers into the <FONT FACE="Courier New">&lt;clinit</FONT>()</FONT> method of the class file in the order in which they appear in the class declaration. For example, given this class:</P>
<PRE><P><FONT FACE="Courier New">begin</FONT></P>
<FONT SIZE="2"><P></FONT><FONT FACE="Courier New">// On CD-ROM in file classlife/ex1/Example1c.java
<P>class Example1c {</P>
<P>&nbsp;</P>
<P>    static int width;</P>
<P>    static int height = (int) (Math.random() * 2.0);</P>
<P>&nbsp;</P>
<P>    // This is the static initializer</P>
<P>    static {</P>
<P>&nbsp;</P>
<P>        width = 3 * (int) (Math.random() * 5.0);</P>
<P>    }</P>
<P>}</P>
</FONT><FONT SIZE="2"><P>&nbsp;</P></FONT><FONT FACE="Courier New">end</FONT></P></PRE>
<P>The Java compiler generates the following <FONT FACE="Courier New">&lt;clinit</FONT>()</FONT> method:</P>
<PRE><P><FONT FACE="Courier New">begin</FONT></P>
<FONT SIZE="2"><P></FONT><FONT FACE="Courier New">// The code for height's class variable initializer begins here
<P>                           // Invoke Math.random(), which will push</P>
<P>                           // a double return value</P>
<P> 0 invokestatic #6 &lt;Method double random()</FONT></P>
<P> 3 ldc2_w #8 &lt;Double 2.0</FONT>  // Push double constant 2.0</P>
<P> 6 dmul                    // Pop two doubles, multiply, push result</P>
<P> 7 d2i                     // Pop double, convert to int, push int</P>
<P>                           // Pop int, store into class variable</P>
<P>                           // height</P>
<P> 8 putstatic #5 &lt;Field int height</FONT></P>
<P>&nbsp;</P>
<P>// The code for the static initializer begins here</P>
<P>11 iconst_3                // Push int constant 3</P>
<P>                           // Invoke Math.random(), which will push</P>
<P>                           // a double return value</P>
<P>12 invokestatic #6 &lt;Method double random()</FONT></P>
<P>15 ldc2_w #10 &lt;Double 5.0</FONT>  // Push double constant 5.0</P>
<P>18 dmul                    // Pop two doubles, multiply, push result</P>
<P>19 d2i                     // Pop double, convert to int, push int</P>
<P>20 imul                    // Pop two ints, multiply, push int result</P>
<P>                           // Pop int, store into class variable</P>
<P>                           // width</P>
<P>21 putstatic #7 &lt;Field int width</FONT></P>
<P>24 return                  // Return void from &lt;clinit</FONT> method</P>
</FONT><FONT SIZE="2"><P>&nbsp;</P></FONT><FONT FACE="Courier New">end</FONT></P></PRE>
<P>This <FONT FACE="Courier New">&lt;clinit</FONT>()</FONT> method first executes the code for <FONT FACE="Courier New">Example1c</FONT>ís only class variable initializer, which initializes <FONT FACE="Courier New">height</FONT>, then executes the code for the static initializer, which initializes <FONT FACE="Courier New">width</FONT>. The initialization is done in this order because the class variable initializer appears textually before the static initializer in the source code of the <FONT FACE="Courier New">Example1c</FONT> class.</P>
<P>Not all classes will necessarily have a <FONT FACE="Courier New">&lt;clinit</FONT>()</FONT> method in their class file. If a class declares no class variables, it wonít have a <FONT FACE="Courier New">&lt;clinit</FONT>()</FONT> method. If a class declares class variables, but doesnít explicitly initialize them with class variable initializers or static initializers, it wonít have a <FONT FACE="Courier New">&lt;clinit</FONT>()</FONT> method. If a class contains only class variable initializers for static final variables, and those class variable initializers use compile-time constant expressions, that class wonít have a <FONT FACE="Courier New">&lt;clinit</FONT>()</FONT> method. Only those classes that actually require Java code to be executed to initialize class variables to proper initial values will have a class initialization method.</P>
<P>Hereís an example of a class that wonít be awarded a <FONT FACE="Courier New">&lt;clinit</FONT>()</FONT> method by the Java compiler:</P>
<PRE><P><FONT FACE="Courier New">begin</FONT></P>
<FONT SIZE="2"><P></FONT><FONT FACE="Courier New">// On CD-ROM in file classlife/ex1/Example1d.java
<P>class Example1d {</P>
<P>&nbsp;</P>
<P>    static final int angle = 35;</P>
<P>    static final int length = angle * 2;</P>
<P>}</P>
</FONT><FONT SIZE="2"><P>&nbsp;</P></FONT><FONT FACE="Courier New">end</FONT></P></PRE>
<P>Class <FONT FACE="Courier New">Example1d</FONT> declares two constants, <FONT FACE="Courier New">angle</FONT> and <FONT FACE="Courier New">length</FONT>, and initializes them with expressions that are compile-time constants. The compiler knows that <FONT FACE="Courier New">angle</FONT> represents the value 35 and <FONT FACE="Courier New">length</FONT> represents the value 70. When the <FONT FACE="Courier New">Example1d</FONT> class is loaded by a Java Virtual Machine, <FONT FACE="Courier New">angle</FONT> and <FONT FACE="Courier New">length</FONT> are not stored as class variables in the method area. As a result, no <FONT FACE="Courier New">&lt;clinit</FONT>()</FONT> method is needed to initialize them. The <FONT FACE="Courier New">angle</FONT> and <FONT FACE="Courier New">length</FONT> fields are not class variables, they are constants, which are treated specially by the Java compiler.</P>
<P>Instead of treating <FONT FACE="Courier New">Example1d</FONT>ís <FONT FACE="Courier New">angle</FONT> and <FONT FACE="Courier New">length</FONT> fields as class variables, the Java compiler places the constant <FONT FACE="Courier New">int</FONT> values they represent into the constant pool or bytecode streams of any class that uses them. For example, if a class uses <FONT FACE="Courier New">Example1d</FONT>ís <FONT FACE="Courier New">angle</FONT> field, that class will not have in its constant pool a symbolic reference to the <FONT FACE="Courier New">angle</FONT> field of class <FONT FACE="Courier New">Example1d</FONT>. Instead, the class will have operands embedded in its bytecode streams that have the value 35. If the constant value of <FONT FACE="Courier New">angle</FONT> were outside the range of a <FONT FACE="Courier New">short</FONT> (-32,768 to 32,767), say 35,000, the class would have a <FONT FACE="Courier New">CONSTANT_Integer_info</FONT> entry in its constant pool with the value of 35,000.</P>
<P>Hereís a class that uses both a constant and a class variable from other classes:</P>
<PRE><P><FONT FACE="Courier New">begin</FONT></P>
<FONT SIZE="2"><P></FONT><FONT FACE="Courier New">// On CD-ROM in file classlife/ex1/Example1e.java
<P>class Example1e {</P>
<P>&nbsp;</P>
<P>    // The class variable initializer for symbolicRef uses a symbolic</P>
<P>    // reference to the size class variable of class Example1a</P>
<P>    static int symbolicRef = Example1a.size;</P>
<P>&nbsp;</P>
<P>    // The class variable initializer for localConst doesn't use a</P>
<P>    // symbolic reference to the length field of class Example1d.</P>
<P>    // Instead, it just uses a copy of the constant value 70.</P>
<P>    static int localConst = Example1d.length * (int) (Math.random()</P>
<P>        * 3.0);</P>
<P>}</P>
</FONT><FONT SIZE="2"><P>&nbsp;</P></FONT><FONT FACE="Courier New">end</FONT></P></PRE>
<P>The Java compiler generates the following <FONT FACE="Courier New">&lt;clinit</FONT>()</FONT> method for class Example1e:</P>
<PRE><P><FONT FACE="Courier New">begin</FONT></P>
<FONT SIZE="2"><P></FONT><FONT FACE="Courier New">// The code for symbolicRef's class variable initializer begins here:
<P>                           // Push int value from Example1a.size.</P>
<P>                           // This getstatic instruction refers to a</P>
<P>                           // symbolic reference to Example1a.size.</P>
<P> 0 getstatic #9 &lt;Field int size</FONT></P>
<P>                           // Pop int, store into class variable</P>
<P>                           // symbolicRef</P>
<P> 3 putstatic #10 &lt;Field int symbolicRef</FONT></P>
<P>&nbsp;</P>
<P>// The code for localConst's class variable intializer begins here:</P>
<P>                           // Expand byte operand to int, push int</P>
<P>                           // result. This is the local copy of</P>
<P> 6 bipush 70               // Example1d's length constant, 70.</P>
<P>                           // Invoke Math.random(), which will push</P>
<P>                           // a double return value</P>
<P> 8 invokestatic #8 &lt;Method double random()</FONT></P>
<P>11 ldc2_w #11 &lt;Double 3.0</FONT> // Push double constant 3.0</P>
<P>14 dmul                    // Pop two doubles, multiply, push result</P>
<P>15 d2i                     // Pop double, convert to int, push int</P>
<P>16 imul                    // Pop two ints, multiply, push int result</P>
<P>                           // Pop int, store into class variable</P>
<P>                           // localConst</P>
<P>17 putstatic #7 &lt;Field int localConst</FONT></P>
<P>20 return                  // Return void from &lt;clinit</FONT> method</P>
</FONT><FONT SIZE="2"><P>&nbsp;</P></FONT><FONT FACE="Courier New">end</FONT></P></PRE>
<P>The <FONT FACE="Courier New">getstatic</FONT> instruction at offset zero uses a symbolic reference (in constant pool entry nine) to the <FONT FACE="Courier New">size</FONT> field of class <FONT FACE="Courier New">Example1a</FONT>. The <FONT FACE="Courier New">bipush</FONT> instruction at offset six is followed by a byte that contains the constant value represented by <FONT FACE="Courier New">Example1d.length</FONT>. <FONT FACE="Courier New">Example1e</FONT>ís constant pool contains no symbolic reference to anything in class <FONT FACE="Courier New">Example1d</FONT>.</P>
<P>Interfaces may also be awarded a <FONT FACE="Courier New">&lt;clinit</FONT>()</FONT> method in the class file. All fields declared in an interface are implicitly public, static, and final and must be initialized with a field initializer. If an interface has any field initializers that donít resolve at compile-time to a constant, that interface will have a <FONT FACE="Courier New">&lt;clinit</FONT>()</FONT> method. Hereís an example:</P>
<PRE><P><FONT FACE="Courier New">begin</FONT></P>
<FONT SIZE="2"><P></FONT><FONT FACE="Courier New">// On CD-ROM in file classlife/ex1/Example1f.java
<P>interface Example1f {</P>
<P>&nbsp;</P>
<P>    int ketchup = 5;</P>
<P>    int mustard = (int) (Math.random() * 5.0);</P>
<P>}</P>
</FONT><FONT SIZE="2"><P>&nbsp;</P></FONT><FONT FACE="Courier New">end</FONT></P></PRE>
<P>The Java compiler generates the following <FONT FACE="Courier New">&lt;clinit</FONT>()</FONT> method for interface <FONT FACE="Courier New">Example1f</FONT>:</P>
<PRE><P><FONT FACE="Courier New">begin</FONT></P>
<FONT SIZE="2"><P></FONT><FONT FACE="Courier New">// The code for mustard's class variable initializer begins here
<P>                          // Invoke Math.random(), which will push</P>
<P>                          // a double return value</P>
<P> 0 invokestatic #6 &lt;Method double random()</FONT></P>
<P> 3 ldc2_w #7 &lt;Double 5.0</FONT> // Push double constant 2.0</P>
<P> 6 dmul                   // Pop two doubles, multiply, push result</P>
<P> 7 d2i                    // Pop double, convert to int, push int</P>
<P>                          // Pop int, store into class variable</P>
<P>                          // mustard</P>
<P> 8 putstatic #5 &lt;Field int mustard</FONT></P>
<P>11 return                 // Return void from &lt;clinit</FONT> method</P>
</FONT><FONT SIZE="2"><P>&nbsp;</P></FONT><FONT FACE="Courier New">end</FONT></P></PRE>
<P>Note that only the <FONT FACE="Courier New">mustard</FONT> field is initialized by this <FONT FACE="Courier New">&lt;clinit</FONT>()</FONT> method. Because the <FONT FACE="Courier New">ketchup</FONT> field is initialized to a compile-time constant, it is treated specially by the compiler. Although types that use <FONT FACE="Courier New">Example1f.mustard</FONT> will contain a symbolic reference to the field, types that use <FONT FACE="Courier New">Example1f.ketchup</FONT> will contain a local copy of <FONT FACE="Courier New">ketchup</FONT>ís constant value, 5.</P>
<P><H4><EM>Active versus Passive Use</P></EM></H4>
<P>As mentioned above, the Java Virtual Machine initializes types on their first active use or, in the case of classes, upon the first active use of a subclass. Only four activities constitute an active use: invoking a class initialization method on a new instance of a class, creating an array whose element type is the class, invoking a method declared in a class, and accessing a non-constant field declared in a class or interface.</P>
<P>A use of a non-constant field is an active use of only the class or interface that actually declares the field. For example, a field declared in a class may be referred to via a subclass. A field declared in an interface may be referred to via a subinterface or class that implements the interface. These are passive uses of the subclass, subinterface, or class that implements the interface--uses that wonít trigger their initialization. They are an active use only of the class or interface in which the field is actually declared. Hereís an example that illustrates this principle:</P>
<PRE><P><FONT FACE="Courier New">begin</FONT></P>
<FONT SIZE="2"><P></FONT><FONT FACE="Courier New">// On CD-ROM in file classlife/ex2/NewParent.java
<P>class NewParent {</P>
<P>&nbsp;</P>
<P>    static int hoursOfSleep = (int) (Math.random() * 3.0);</P>
<P>&nbsp;</P>
<P>    static {</P>
<P>        System.out.println("NewParent was initialized.");</P>
<P>    }</P>
<P>}</P>
</FONT><FONT SIZE="2"><P>&nbsp;</P></P>
<P></FONT><FONT FACE="Courier New">// On CD-ROM in file classlife/ex2/NewbornBaby.java
<P>class NewbornBaby extends NewParent {</P>
<P>&nbsp;</P>
<P>    static int hoursOfCrying = 6 + (int) (Math.random() * 2.0);</P>
<P>&nbsp;</P>
<P>    static {</P>
<P>        System.out.println("NewbornBaby was initialized.");</P>
<P>    }</P>
<P>}</P>
</FONT><FONT SIZE="2"><P>&nbsp;</P></P>
<P></FONT><FONT FACE="Courier New">// On CD-ROM in file classlife/ex2/Example2.java
<P>class Example2 {</P>
<P>&nbsp;</P>
<P>    // Invoking main() is an active use of Example2</P>
<P>    public static void main(String[] args) {</P>
<P>&nbsp;</P>
<P>        // Using hoursOfSleep is an active use of Parent, but a</P>
<P>        // passive use of NewbornBaby</P>
<P>        int hours = NewbornBaby.hoursOfSleep;</P>
<P>        System.out.println(hours);</P>
<P>    }</P>
<P>&nbsp;</P>
<P>    static {</P>
<P>        System.out.println("Example2 was initialized.");</P>
<P>    }</P>
<P>}</P>
</FONT><FONT SIZE="2"><P>&nbsp;</P></FONT><FONT FACE="Courier New">end</FONT></P></PRE>
<P>In the above example, executing <FONT FACE="Courier New">main()</FONT> of <FONT FACE="Courier New">Example2</FONT> causes only <FONT FACE="Courier New">Example2</FONT> and <FONT FACE="Courier New">Parent</FONT> to be initialized. <FONT FACE="Courier New">NewbornBaby</FONT> is not initialized and need not be loaded. The following text is printed to the standard output:</P>
<PRE><P><FONT FACE="Courier New">begin</FONT></P>
<FONT FACE="Courier New"><P>Example2 was initialized.</P>
<P>NewParent was initialized.</P>
<P>2</P>
</FONT><P><FONT FACE="Courier New">end</FONT></P></PRE>
<P>A use of a field that is both <FONT FACE="Courier New">static</FONT> and <FONT FACE="Courier New">final</FONT>, and initialized by a compile-time constant expression, is not an active use of the type that declares the field. As mentioned above, the Java compiler resolves references to such fields to a local copy of the constant value that resides either in the referring classes constant pool, in its bytecode streams, or both. Hereís an example that illustrates this special treatment of static final fields:</P>
<PRE><P><FONT FACE="Courier New">begin</FONT></P>
<FONT SIZE="2"><P></FONT><FONT FACE="Courier New">// On CD-ROM in file classlife/ex3/Angry.java
<P>interface Angry {</P>
<P>&nbsp;</P>
<P>    String greeting = "Grrrr!";</P>
<P>&nbsp;</P>
<P>    int angerLevel = Dog.getAngerLevel();</P>
<P>}</P>
</FONT><FONT SIZE="2"><P>&nbsp;</P></P>
<P></FONT><FONT FACE="Courier New">// On CD-ROM in file classlife/ex3/Dog.java
<P>class Dog {</P>
<P>&nbsp;</P>
<P>    static final String greeting = "Woof, woof, world!";</P>
<P>&nbsp;</P>
<P>    static {</P>
<P>        System.out.println("Dog was initialized.");</P>
<P>    }</P>
<P>&nbsp;</P>
<P>    static int getAngerLevel() {</P>
<P>&nbsp;</P>
<P>        System.out.println("Anger was initialized");</P>
<P>        return 1;</P>
<P>    }</P>
<P>}</P>
</FONT><FONT SIZE="2"><P>&nbsp;</P></P>
<P></FONT><FONT FACE="Courier New">// On CD-ROM in file classlife/ex3/Example3.java
<P>class Example3 {</P>
<P>&nbsp;</P>
<P>    // Invoking main() is an active use of Example4</P>
<P>    public static void main(String[] args) {</P>
<P>&nbsp;</P>
<P>        // Using Angry.greeting is a passive use of Angry</P>
<P>        System.out.println(Angry.greeting);</P>
<P>    </P>
<P>&nbsp;</P>
<P>        // Using Dog.greeting is a passive use of Dog</P>
<P>        System.out.println(Dog.greeting);</P>
<P>    }</P>
<P>&nbsp;</P>
<P>    static {</P>
<P>        System.out.println("Example3 was initialized.");</P>
<P>    }</P>
<P>}</P>
</FONT><FONT SIZE="2"><P>&nbsp;</P></FONT><FONT FACE="Courier New">end</FONT></P></PRE>
<P>Running the <FONT FACE="Courier New">Example4</FONT> application yields the following output:</P>
<PRE><P><FONT FACE="Courier New">begin</FONT></P>
<FONT FACE="Courier New"><P>Example3 was initialized.</P>
<P>Grrrr!</P>
<P>Woof, woof, world!</P>
</FONT><P><FONT FACE="Courier New">end</FONT></P></PRE>
<P>Had <FONT FACE="Courier New">Angry</FONT> been initialized, the string <FONT FACE="Courier New">"Angry was initialized."</FONT> would have been written to the standard output. Likewise, had <FONT FACE="Courier New">Dog</FONT> been initialized, the string <FONT FACE="Courier New">"Dog was initialized."</FONT> would have been written to the standard output. As you can see from the above output, neither interface <FONT FACE="Courier New">Angry</FONT> or class <FONT FACE="Courier New">Dog</FONT> were ever initialized during the execution of the <FONT FACE="Courier New">Example3</FONT> application.</P>
<P>For more information about this special treatment of static final variables, see Chapter 8, &quot;The Linking Model.&quot;</P>
<H3><EM><P>The Lifetime of an Object</P>
</EM></H3><P>Once a class has been loaded, linked, and initialized, it is ready for use. The program can access its static fields, invoke its static methods, or create instances of it. This section describes class instantiation and initialization, activities that take place at the beginning of an objectís lifetime, and garbage collection and finalization, activities that mark the end of an objectís lifetime.</P>
<H3><P>Class Instantiation</P>
</H3><P>In Java programs, classes can be instantiated explicitly or implicitly. The three ways a class can be instantiated explicitly are with the <FONT FACE="Courier New">new</FONT> operator, by invoking <FONT FACE="Courier New">newInstance()</FONT>on a <FONT FACE="Courier New">Class</FONT> object, or by invoking <FONT FACE="Courier New">clone()</FONT> on any existing object. Here is an example showing each way to create a new class instance:</P>
<PRE><P><FONT FACE="Courier New">begin</FONT></P>
<FONT SIZE="2"><P></FONT><FONT FACE="Courier New">// On CD-ROM in file classlife/ex4/Example4.java
<P>class Example4 implements Cloneable {</P>
<P>&nbsp;</P>
<P>    Example4() {</P>
<P>        System.out.println("Created by invoking newInstance()");</P>
<P>    }</P>
<P>&nbsp;</P>
<P>    Example4(String msg) {</P>
<P>        System.out.println(msg);</P>
<P>    }</P>
<P>&nbsp;</P>
<P>    public static void main(String[] args)</P>
<P>        throws ClassNotFoundException, InstantiationException,</P>
<P>        IllegalAccessException, CloneNotSupportedException {</P>
<P>&nbsp;</P>
<P>        // Create a new Example4 object with the new operator</P>
<P>        Example4 obj1 = new Example4("Created with new.");</P>
<P>&nbsp;</P>
<P>        // Get a reference to the Class instance for Example4, then</P>
<P>        // invoke newInstance() on it to create a new Example4 object</P>
<P>        Class myClass = Class.forName("Example4"); </P>
<P>        Example4 obj2 = (Example4) myClass.newInstance();</P>
<P>&nbsp;</P>
<P>        // Make an identical copy of the the second Example4 object</P>
<P>        Example4 obj3 = (Example4) obj2.clone();</P>
<P>    }</P>
<P>}</P>
</FONT><FONT SIZE="2"><P>&nbsp;</P></FONT><FONT FACE="Courier New">end</FONT></P></PRE>
<P>When executed, the <FONT FACE="Courier New">Example4</FONT> application prints this output:</P>
<PRE><P><FONT FACE="Courier New">begin</FONT></P>
<FONT SIZE="2"><P></FONT><FONT FACE="Courier New">Created with new.
<P>Created by invoking newInstance()</P>
</FONT><FONT SIZE="2"><P>&nbsp;</P></FONT><FONT FACE="Courier New">end</FONT></P></PRE>
<P>Besides the three ways listed above to explicitly instantiate objects in Java source code, there are several situations in which objects will be instantiated implicitly--without an explicit <FONT FACE="Courier New">new</FONT>, <FONT FACE="Courier New">newInstance()</FONT>, or <FONT FACE="Courier New">clone()</FONT> appearing in the source.</P>
<P>Possibly the first implicitly instantiated objects of any Java application are the <FONT FACE="Courier New">String</FONT> objects that hold the command line arguments. References to these objects, one for each command-line argument, are delivered in the <FONT FACE="Courier New">String</FONT> array passed as the sole parameter to the <FONT FACE="Courier New">main()</FONT> method of every application.</P>
<P>Two other ways a class can be instantiated implicitly involve the process of class loading. First, for every type a Java Virtual Machine loads, it implicitly instantiates a new <FONT FACE="Courier New">Class</FONT> object to represent that type. Second, when the Java Virtual Machine loads a class that contains <FONT FACE="Courier New">CONSTANT_String_info</FONT> entries in its constant pool, it may instantiate new <FONT FACE="Courier New">String</FONT> objects to represent those constant string literals. The process of transforming a <FONT FACE="Courier New">CONSTANT_String_info</FONT> entry in the method area to a <FONT FACE="Courier New">String</FONT> instance on the heap is part of the process of constant pool resolution. This process is described in detail in Chapter 8, &quot;The Linking Model.&quot;</P>
<P>Another way objects can be created implicitly is through the process of evaluating an expression that involves the string concatenation operator. If such an expression is not a compile-time constant, intermediate <FONT FACE="Courier New">String</FONT> and <FONT FACE="Courier New">StringBuffer</FONT> objects will be created in the process of evaluating the expression. Hereís an example:</P>
<PRE><P><FONT FACE="Courier New">begin</FONT></P>
<FONT SIZE="2"><P></FONT><FONT FACE="Courier New">// On CD-ROM in file classlife/ex5/Example5.java
<P>class Example5 {</P>
<P>&nbsp;</P>
<P>    public static void main(String[] args) {</P>
<P>&nbsp;</P>
<P>        if (args.length &lt; 2) {</P>
<P>            System.out.println("Must enter any two args.");</P>
<P>            return;</P>
<P>        }</P>
<P>&nbsp;</P>
<P>        System.out.println(args[0] + args[1]);</P>
<P>    }</P>
<P>}</P>
</FONT><FONT SIZE="2"><P>&nbsp;</P></FONT><FONT FACE="Courier New">end</FONT></P></PRE>
<P><FONT FACE="Courier New">javac</FONT> generates these bytecodes for <FONT FACE="Courier New">Example5</FONT>ís <FONT FACE="Courier New">main()</FONT> method:</P>
<PRE><P><FONT FACE="Courier New">begin</FONT></P>
<FONT SIZE="2"><P></FONT><FONT FACE="Courier New"> 0 aload_0      // Push the objref from loc var 0 (args)
<P> 1 arraylength  // Pop arrayref, calc array length, push int length</P>
<P> 2 iconst_2     // Push int constant 2</P>
<P>                // Pop 2 ints, compare, branch if (length </FONT> 2) to</P>
<P> 3 if_icmpge 15 // offset 15.</P>
<P>                // Push objref from System.out</P>
<P> 6 getstatic #11 &lt;Field java.io.PrintStream out</FONT></P>
<P>                // Push objref of string literal</P>
<P> 9 ldc #1 &lt;String "Must enter any two args."</FONT></P>
<P>                // Pop objref to String param, objref to System.out,</P>
<P>                // invoke println()</P>
<P>11 invokevirtual #12 &lt;Method void println(java.lang.String)</FONT></P>
<P>14 return       // Return void from main()</P>
<P>                // Push objref from System.out</P>
<P>15 getstatic #11 &lt;Field java.io.PrintStream out</FONT></P>
<P>&nbsp;</P>
<P>// The string concatenation operation begins here</P>
<P>                // Allocate mem for new StringBuffer object, and</P>
<P>                // initialize mem to default initial values, push</P>
<P>                // objref to new object</P>
<P>18 new #6 &lt;Class java.lang.StringBuffer</FONT></P>
<P>21 dup          // Duplicate objref to StringBuffer object</P>
<P>22 aload_0      // Push ref from loc var 0 (args)</P>
<P>23 iconst_0     // Push int constant 0</P>
<P>                // Pop int, arrayref, push String at arrayref[int],</P>
<P>24 aaload       // which is args[0]</P>
<P>                // Pop objref, invoke String's class method</P>
<P>                // valueOf(), passing it the objref to the args[0]</P>
<P>                // String object. valueOf() calls toString() on the</P>
<P>                // ref, and returns (and pushes) the result, which</P>
<P>                // happens to be the original args[0] String. In this</P>
<P>                // case, the stack will look precisely the same</P>
<P>                // before and after this instruction is executed.</P>
<P>                // Thus here, the 1.1 javac compiler has</P>
<P>                // over-enthusiastically generated an unnecessary</P>
<P>                // instruction.</P>
<P>25 invokestatic #14 &lt;Method java.lang.String valueOf(</P>
<P>        java.lang.Object)</FONT></P>
<P>                // Pop objref to args[0] String, objref of the</P>
<P>                // StringBuffer object, invoke &lt;init</FONT>() method on the</P>
<P>                // StringBuffer object passing the args[0] objref as</P>
<P>                // the only parameter.</P>
<P>28 invokespecial #9 &lt;Method java.lang.StringBuffer(java.lang.String)</FONT></P>
<P>31 aload_0      // Push objref from loc var 0 (args)</P>
<P>32 iconst_1     // Push int constant 1</P>
<P>                // Pop int, arrayref, push String at arrayref[int],</P>
<P>33 aaload       // which is args[1]</P>
<P>                // Pop objref to args[1] String, objref of the</P>
<P>                // StringBuffer object (there's still another objref</P>
<P>                // to this same object on the stack because of the</P>
<P>                // dup instruction above), invoke append() method on</P>
<P>                // StringBuffer object, passing args[1] as the only</P>
<P>                // parameter. append() will return an objref to this</P>
<P>                // StringBuffer object, which will be pushed back</P>
<P>                // onto the stack.</P>
<P>34 invokevirtual #10 &lt;Method java.lang.StringBuffer append(java.lang.String)</FONT></P>
<P>                // Pop objref to StringBuffer (pushed by append()),</P>
<P>                // invoke toString() on it, which returns the value</P>
<P>                // of the StringBuffer as a String object. Push</P>
<P>                // objref of String object.</P>
<P>37 invokevirtual #13 &lt;Method java.lang.String toString()</FONT></P>
<P>// The string concatenation operation is now complete</P>
<P>&nbsp;</P>
<P>                // Pop objref of concatenated String, objref of</P>
<P>                // System.out that was pushed by the getstatic</P>
<P>                // instruction at offset 15. Invoke println() on</P>
<P>                // System.out, passing the concatenated String as</P>
<P>                // the only parameter.</P>
<P>40 invokevirtual #12 &lt;Method void println(java.lang.String)</FONT></P>
<P>43 return       // Return void from main()</P>
</FONT><FONT SIZE="2"><P>&nbsp;</P></FONT><FONT FACE="Courier New">end</FONT></P></PRE>
<P>The bytecodes for <FONT FACE="Courier New">Example5</FONT>ís <FONT FACE="Courier New">main()</FONT> method contain three implicitly generated <FONT FACE="Courier New">String</FONT> objects and one implicitly generated <FONT FACE="Courier New">StringBuffer</FONT> object. References to two of the <FONT FACE="Courier New">String</FONT> objects appear as arguments passed to <FONT FACE="Courier New">main()</FONT> in the <FONT FACE="Courier New">args</FONT> array, which are pushed onto the stack by the <FONT FACE="Courier New">aaload</FONT> instructions at offset 23 and 33. The <FONT FACE="Courier New">StringBuffer</FONT> is created with the <FONT FACE="Courier New">new</FONT> instruction at offset 18 and initialized with the <FONT FACE="Courier New">invokespecial</FONT> instruction at offset 28. The final <FONT FACE="Courier New">String</FONT>, which represents the concatenation of <FONT FACE="Courier New">args[0]</FONT> and <FONT FACE="Courier New">args[1]</FONT>, is created by calling <FONT FACE="Courier New">toString()</FONT> on the <FONT FACE="Courier New">StringBuffer</FONT> object via the <FONT FACE="Courier New">invokevirtual</FONT> instruction at offset 37.</P>
<P>When the Java Virtual Machine creates a new instance of a class, either implicitly or explicitly, it first allocates memory on the heap to hold the objectís instance variables. Memory is allocated for all variables declared in the objectís class and in all its superclasses, including instance variables that are hidden. As described in Chapter 5, &quot;The Java Virtual Machine,&quot; memory for other implementation-dependent components of an objectís image on the heap, such as a pointer to class data in the method area, are also likely allocated at this point. As soon as the virtual machine has set aside the heap memory for a new object, it immediately initializes the instance variables to default initial values. These are the same values shown above in Table 7-1 as default initial values for class variables.</P>
<P>Once the virtual machine has allocated memory for the new object and initialized the instance variables to default values, it is ready to give the instance variables their proper initial values. The Java Virtual Machine uses two techniques to do this, depending upon whether the object is being created because of a <FONT FACE="Courier New">clone()</FONT> invocation. If the object is being created because of a <FONT FACE="Courier New">clone()</FONT>, the virtual machine copies the values of the instance variables of the object being cloned into the new object. Otherwise, the virtual machine invokes an <I>instance initialization method</I> on the object. The instance initialization method initializes the objectís instance variables to their proper initial values.</P>
<P>The Java compiler generates at least one instance initialization method for every class it compiles. In the Java class file, the instance initialization method is named &quot;<FONT FACE="Courier New">&lt;init</FONT>.&quot; For each constructor in the source code of a class, the Java compiler generates one <FONT FACE="Courier New">&lt;init</FONT>()</FONT> method. If the class declares no constructors explicitly, the compiler generates a default no-arg constructor that just invokes the superclassís no-arg constructor. As with any other constructor, the compiler creates an <FONT FACE="Courier New">&lt;init</FONT>()</FONT> method in the class file that corresponds to this default constructor.</P>
<P>An <FONT FACE="Courier New">&lt;init</FONT>()</FONT> method can contain three kinds of code: an invocation of another <FONT FACE="Courier New">&lt;init</FONT>()</FONT> method, code that implements any instance variable initializers, and code for the body of the constructor. If a constructor begins with an explicit invocation of another constructor in the same class (a <FONT FACE="Courier New">this()</FONT> invocation) its corresponding <FONT FACE="Courier New">&lt;init</FONT>()</FONT> method will be composed of two parts:</P>
<UL><LI> an invocation of the same-class <FONT FACE="Courier New">&lt;init</FONT>()</FONT> method
<LI> the bytecodes that implement the body of the corresponding constructor</UL>
<P>If a constructor does not begin with a <FONT FACE="Courier New">this()</FONT> invocation and the class is not <FONT FACE="Courier New">Object</FONT>, the <FONT FACE="Courier New">&lt;init</FONT>()</FONT> method will have three components:</P>
<UL><LI> an invocation of a superclass <FONT FACE="Courier New">&lt;init</FONT>()</FONT> method
<LI> the bytecodes for any instance variable initializers
<LI> the bytecodes that implement the body of the corresponding constructor</UL>
<P>If a constructor does not begin with a <FONT FACE="Courier New">this()</FONT> invocation and the class <I>is</I> <FONT FACE="Courier New">Object</FONT>, the first component in the above list is missing. Because <FONT FACE="Courier New">Object</FONT> has no superclass, its <FONT FACE="Courier New">&lt;init</FONT>()</FONT> methodís canít begin with a superclass <FONT FACE="Courier New">&lt;init</FONT>()</FONT> method invocation.</P>
<P>If a constructor begins with an explicit invocation of a superclass constructor ( a <FONT FACE="Courier New">super()</FONT> invocation), its <FONT FACE="Courier New">&lt;init</FONT>()</FONT> method will invoke the corresponding superclass <FONT FACE="Courier New">&lt;init</FONT>()</FONT> method. For example, if a constructor begins with an explicit invocation of the  &quot;<FONT FACE="Courier New">super(int, String)</FONT> constructor,&quot; the corresponding <FONT FACE="Courier New">&lt;init</FONT>()</FONT> method will begin by invoking the superclassís &quot;<FONT FACE="Courier New">&lt;init</FONT>(int, String)</FONT>&quot; method. If a constructor does not begin with an explicit <FONT FACE="Courier New">this()</FONT> or <FONT FACE="Courier New">super()</FONT> invocation, the corresponding <FONT FACE="Courier New">&lt;init</FONT>()</FONT> method will invoke the superclassís no-arg <FONT FACE="Courier New">&lt;init</FONT>()</FONT> method by default.</P>
<P>Hereís an example with three constructors, numbered one through three:</P>
<PRE><P><FONT FACE="Courier New">begin</FONT></P>
<FONT SIZE="2"><P></FONT><FONT FACE="Courier New">// On CD-ROM in file classlife/ex6/Example6.java
<P>class Example6 {</P>
<P>&nbsp;</P>
<P>    private int width = 3;</P>
<P>&nbsp;</P>
<P>    // Constructor one:</P>
<P>    // This constructor begins with a this() constructor invocation,</P>
<P>    // which gets compiled to a same-class &lt;init</FONT>() method</P>
<P>    // invocation.</P>
<P>    Example6() {</P>
<P>        this(1);</P>
<P>        System.out.println("Example6(), width = " + width);</P>
<P>    }</P>
<P>&nbsp;</P>
<P>    // Constructor two:</P>
<P>    // This constructor begins with no explicit invocation of another</P>
<P>    // constructor, so it will get compiled to an &lt;init</FONT>() method</P>
<P>    // that begins with an invocation of the superclass's no-arg</P>
<P>    // &lt;init</FONT>() method.</P>
<P>    Example6(int width) {</P>
<P>        this.width = width;</P>
<P>        System.out.println("Example6(int), width = " + width);</P>
<P>    }</P>
<P>&nbsp;</P>
<P>    // Constructor three:</P>
<P>    // This constructor begins with super(), an explicit invocation</P>
<P>    // of the superclass's no-arg constructor. Its &lt;init</FONT>() method</P>
<P>    // will begin with an invocation of the superclass's no-arg</P>
<P>    // &lt;init</FONT>() method.</P>
<P>    Example6(String msg) {</P>
<P>        super();</P>
<P>        System.out.println("Example6(String), width = " + width);</P>
<P>        System.out.println(msg);</P>
<P>    }</P>
<P>&nbsp;</P>
<P>    public static void main(String[] args) {</P>
<P>        String msg</P>
<P>            = "The Agapanthus is also known as Lilly of the Nile.";</P>
<P>        Example6 one = new Example6();</P>
<P>        Example6 two = new Example6(2);</P>
<P>        Example6 three = new Example6(msg);</P>
<P>    }</P>
<P>}</P>
</FONT><FONT SIZE="2"><P>&nbsp;</P></FONT><FONT FACE="Courier New">end</FONT></P></PRE>
<P>When executed, the <FONT FACE="Courier New">Example6</FONT> application prints this output:</P>
<PRE><P><FONT FACE="Courier New">begin</FONT></P>
<FONT SIZE="2"><P></FONT><FONT FACE="Courier New">Example6(int), width = 1
<P>Example6(), width = 1</P>
<P>Example6(int), width = 2</P>
<P>Example6(String), width = 3</P>
<P>The Agapanthus is also known as Lilly of the Nile.</P>
</FONT><FONT SIZE="2"><P>&nbsp;</P></FONT><FONT FACE="Courier New">end</FONT></P></PRE>
<P>The bytecodes for <FONT FACE="Courier New">Example6</FONT>ís no-arg <FONT FACE="Courier New">&lt;init</FONT>()</FONT> method (the <FONT FACE="Courier New">&lt;init</FONT>()</FONT> method that corresponds to constructor one) are:</P>
<PRE><P><FONT FACE="Courier New">begin</FONT></P>
<FONT SIZE="2"><P></FONT><FONT FACE="Courier New">// The first component, the same-class &lt;init</FONT>() invocation, begins
<P>// here:</P>
<P> 0 aload_0      // Push the objref from loc var 0 (this)</P>
<P> 1 iconst_1     // Push int constant 1</P>
<P>                // Pop int and objref, invoke &lt;init</FONT>() method on</P>
<P>                // objref (this), passing the int (a 1) as the</P>
<P>                // only parameter.</P>
<P> 2 invokespecial #12 &lt;Method Example6(int)</FONT></P>
<P>&nbsp;</P>
<P>// The second component, the body of the constructor, begins</P>
<P>// here:</P>
<P>                // Push objref from System.out</P>
<P> 5 getstatic #16 &lt;Field java.io.PrintStream out</FONT></P>
<P>                // Allocate mem for new StringBuffer object, and</P>
<P>                // initialize mem to default initial values, push</P>
<P>                // objref to new object</P>
<P> 8 new #8 &lt;Class java.lang.StringBuffer</FONT></P>
<P>11 dup          // Duplicate objref to StringBuffer object</P>
<P>                // Push objref to String literal from constant pool</P>
<P>12 ldc #1 &lt;String "Example6(), width = "</FONT></P>
<P>                // Pop objref to literal String, pop objref of the</P>
<P>                // StringBuffer object, invoke &lt;init</FONT>() method on the</P>
<P>                // StringBuffer object passing the args[0] objref as</P>
<P>                // the only parameter.</P>
<P>14 invokespecial #14 &lt;Method java.lang.StringBuffer(</P>
<P>        java.lang.String)</FONT></P>
<P>17 aload_0      // Push objref from loc var 0 (this)</P>
<P>                // Pop this reference, Push int value of width field</P>
<P>18 getfield #19 &lt;Field int width</FONT></P>
<P>                // Pop int (width), pop objref (StringBuffer object),</P>
<P>                // invoke append() on StringBuffer object passing the</P>
<P>                // width int as the only parameter. append() will add</P>
<P>                // the string representation of the int to the end of</P>
<P>                // the buffer, and return an objref to the same</P>
<P>                // StringBuffer object.</P>
<P>21 invokevirtual #15 &lt;Method java.lang.StringBuffer append(int)</FONT></P>
<P>                // Pop objref to StringBuffer (pushed by append()),</P>
<P>                // invoke toString() on it, which returns the value</P>
<P>                // of the StringBuffer as a String object. Push</P>
<P>                // objref of String object.</P>
<P>24 invokevirtual #18 &lt;Method java.lang.String toString()</FONT></P>
<P>                // Pop objref of String, pop objref of System.out</P>
<P>                // that was pushed by the getstatic instruction at</P>
<P>                // offset 5. Invoke println() on System.out,</P>
<P>                // passing the String as the only parameter:</P>
<P>                // System.out.println("Example6(), width = "</P>
<P>                //     + width);</P>
<P>27 invokevirtual #17 &lt;Method void println(java.lang.String)</FONT></P>
<P>30 return       // Return void from &lt;init</FONT>()</P>
</FONT><FONT SIZE="2"><P>&nbsp;</P></FONT><FONT FACE="Courier New">end</FONT></P></PRE>
<P>Note that the <FONT FACE="Courier New">&lt;init</FONT>()</FONT> method for constructor one begins with an invocation of a same-class <FONT FACE="Courier New">&lt;init</FONT>()</FONT> method, then executes the body of the corresponding constructor. Because the constructor begins with a <FONT FACE="Courier New">this()</FONT> invocation, its corresponding <FONT FACE="Courier New">&lt;init</FONT>()</FONT> method doesnít contain bytecodes for the instance variable initializer.</P>
<P>The bytecodes for <FONT FACE="Courier New">Example6</FONT>ís <FONT FACE="Courier New">&lt;init</FONT>()</FONT> method that takes an <FONT FACE="Courier New">int</FONT> parameter (the <FONT FACE="Courier New">&lt;init</FONT>()</FONT> method that corresponds to constructor two) is:</P>
<PRE><P><FONT FACE="Courier New">begin</FONT></P>
<FONT SIZE="2"><P></FONT><FONT FACE="Courier New">// The first component, the superclass &lt;init</FONT>() invocation, begins
<P>// here:</P>
<P> 0 aload_0      // Push the objref from loc var 0 (this)</P>
<P>                // Pop objref (this), invoke the superclass's</P>
<P>                // no-arg&lt;init</FONT>() method on objref.</P>
<P> 1 invokespecial #11 &lt;Method java.lang.Object()</FONT></P>
<P>&nbsp;</P>
<P>// The second component, the instance variable initializers, begins</P>
<P>// here:</P>
<P> 4 aload_0      // Push the objref from loc var 0 (this)</P>
<P> 5 iconst_3     // Push int constant 3</P>
<P>                // Pop int (3), pop objref (this), store 3 into</P>
<P>                // width instance variable of this object</P>
<P> 6 putfield #19 &lt;Field int width</FONT></P>
<P>&nbsp;</P>
<P>// The third component, the body of the constructor, begins</P>
<P>// here:</P>
<P> 9 aload_0      // Push the objref from loc var 0 (this)</P>
<P>10 iload_1      // Push int from loc var 1 (int param width)</P>
<P>                // Pop int (param width), pop objref (this), store</P>
<P>                // int param value into width field of this object:</P>
<P>                // this.width = width</P>
<P>11 putfield #19 &lt;Field int width</FONT></P>
<P>                // Push objref from System.out</P>
<P>14 getstatic #16 &lt;Field java.io.PrintStream out</FONT></P>
<P>                // Allocate mem for new StringBuffer object, and</P>
<P>                // initialize mem to default initial values, push</P>
<P>                // objref to new object</P>
<P>17 new #8 &lt;Class java.lang.StringBuffer</FONT></P>
<P>20 dup          // Duplicate objref to StringBuffer object</P>
<P>                // Push objref to String literal from constant pool</P>
<P>21 ldc #3 &lt;String "Example6(int), width = "</FONT></P>
<P>                // Pop objref to literal String, pop objref of the</P>
<P>                // StringBuffer object, invoke &lt;init</FONT>() method on the</P>
<P>                // StringBuffer object passing the args[0] objref as</P>
<P>                // the only parameter.</P>
<P>23 invokespecial #14 &lt;Method java.lang.StringBuffer(</P>
<P>        java.lang.String)</FONT></P>
<P>26 iload_1      // Push int from loc var 1 (int param width)</P>
<P>                // Pop int (width), pop objref (StringBuffer object),</P>
<P>                // invoke append() on StringBuffer object passing the</P>
<P>                // width int as the only parameter. append() will add</P>
<P>                // the string representation of the int to the end of</P>
<P>                // the buffer, and return an objref to the same</P>
<P>                // StringBuffer object.</P>
<P>27 invokevirtual #15 &lt;Method java.lang.StringBuffer append(int)</FONT></P>
<P>                // Pop objref to StringBuffer (pushed by append()),</P>
<P>                // invoke toString() on it, which returns the value</P>
<P>                // of the StringBuffer as a String object. Push</P>
<P>                // objref of String object.</P>
<P>30 invokevirtual #18 &lt;Method java.lang.String toString()</FONT></P>
<P>                // Pop objref of String, pop objref of System.out</P>
<P>                // that was pushed by the getstatic instruction at</P>
<P>                // offset 14. Invoke println() on System.out,</P>
<P>                // passing the String as the only parameter:</P>
<P>                // System.out.println("Example6(int), width = "</P>
<P>                //     + width);</P>
<P>33 invokevirtual #17 &lt;Method void println(java.lang.String)</FONT></P>
<P>36 return       // Return void from &lt;init</FONT>()</P>
</FONT><FONT SIZE="2"><P>&nbsp;</P></FONT><FONT FACE="Courier New">end</FONT></P></PRE>
<P>The <FONT FACE="Courier New">&lt;init</FONT>()</FONT> method for constructor two has three components. First it has an invocation of the superclassís (<FONT FACE="Courier New">Object</FONT>ís) no-arg <FONT FACE="Courier New">&lt;init</FONT>()</FONT> method. The compiler generated this invocation by default, because no explicit <FONT FACE="Courier New">super()</FONT> invocation appears as the first statement in the body of constructor two. Following the superclass <FONT FACE="Courier New">&lt;init</FONT>()</FONT> invocation is the second component: the bytecodes for widthís instance variable initializer. Third, the <FONT FACE="Courier New">&lt;init</FONT>()</FONT> method contains the bytecodes for the body of constructor two.</P>
<P>The bytecodes for <FONT FACE="Courier New">Example6</FONT>ís <FONT FACE="Courier New">&lt;init</FONT>()</FONT> method that takes a <FONT FACE="Courier New">String</FONT> parameter (the <FONT FACE="Courier New">&lt;init</FONT>()</FONT> method that corresponds to constructor three) are:</P>
<PRE><P><FONT FACE="Courier New">begin</FONT></P>
<FONT SIZE="2"><P></FONT><FONT FACE="Courier New">// The first component, the superclass &lt;init</FONT>() invocation, begins
<P>// here:</P>
<P> 0 aload_0      // Push the objref from loc var 0 (this)</P>
<P>                // Pop objref (this), invoke the superclass's</P>
<P>                // no-arg&lt;init</FONT>() method on objref.</P>
<P> 1 invokespecial #11 &lt;Method java.lang.Object()</FONT></P>
<P>&nbsp;</P>
<P>// The second component, the instance variable initializers, begins</P>
<P>// here:</P>
<P> 4 aload_0      // Push the objref from loc var 0 (this)</P>
<P> 5 iconst_3     // Push int constant 3</P>
<P>                // Pop int (3), pop objref (this), store 3 into</P>
<P>                // width instance variable of this object</P>
<P> 6 putfield #19 &lt;Field int width</FONT></P>
<P>&nbsp;</P>
<P>// The third component, the body of the constructor, begins</P>
<P>// here:</P>
<P>                // Push objref from System.out</P>
<P> 9 getstatic #16 &lt;Field java.io.PrintStream out</FONT></P>
<P>                // Allocate mem for new StringBuffer object, and</P>
<P>                // initialize mem to default initial values, push</P>
<P>                // objref to new object</P>
<P>12 new #8 &lt;Class java.lang.StringBuffer</FONT></P>
<P>15 dup          // Duplicate objref to StringBuffer object</P>
<P>                // Push objref to String literal from constant pool</P>
<P>16 ldc #2 &lt;String "Example6(String), width = "</FONT></P>
<P>                // Pop objref to literal String, pop objref of the</P>
<P>                // StringBuffer object, invoke &lt;init</FONT>() method on the</P>
<P>                // StringBuffer object passing the args[0] objref as</P>
<P>                // the only parameter.</P>
<P>18 invokespecial #14 &lt;Method java.lang.StringBuffer(</P>
<P>        java.lang.String)</FONT></P>
<P>21 aload_0      // Push objref from loc var 0 (this)</P>
<P>                // Pop this reference, Push int value of width field</P>
<P>22 getfield #19 &lt;Field int width</FONT></P>
<P>                // Pop int (width), pop objref (StringBuffer object),</P>
<P>                // invoke append() on StringBuffer object passing the</P>
<P>                // width int as the only parameter. append() will add</P>
<P>                // the string representation of the int to the end of</P>
<P>                // the buffer, and return an objref to the same</P>
<P>                // StringBuffer object.</P>
<P>25 invokevirtual #15 &lt;Method java.lang.StringBuffer append(int)</FONT></P>
<P>                // Pop objref to StringBuffer (pushed by append()),</P>
<P>                // invoke toString() on it, which returns the value</P>
<P>                // of the StringBuffer as a String object. Push</P>
<P>                // objref of String object.</P>
<P>28 invokevirtual #18 &lt;Method java.lang.String toString()</FONT></P>
<P>                // Pop objref of String, pop objref of System.out</P>
<P>                // that was pushed by the getstatic instruction at</P>
<P>                // offset 9. Invoke println() on System.out,</P>
<P>                // passing the String as the only parameter:</P>
<P>                // System.out.println("Example6(String), width = "</P>
<P>                //     + width);</P>
<P>31 invokevirtual #17 &lt;Method void println(java.lang.String)</FONT></P>
<P>                // Push objref from System.out</P>
<P>34 getstatic #16 &lt;Field java.io.PrintStream out</FONT></P>
<P>37 aload_1      // Push objref from loc var 1 (param msg)</P>
<P>                // Pop objref of String, pop objref of System.out</P>
<P>                // that was pushed by the getstatic instruction at</P>
<P>                // offset 37. Invoke println() on System.out,</P>
<P>                // passing the String as the only parameter:</P>
<P>                // System.out.println(msg);</P>
<P>38 invokevirtual #17 &lt;Method void println(java.lang.String)</FONT></P>
<P>41 return       // Return void from &lt;init</FONT>()</P>
</FONT><FONT SIZE="2"><P>&nbsp;</P></FONT><FONT FACE="Courier New">end</FONT></P></PRE>
<P>The <FONT FACE="Courier New">&lt;init</FONT>()</FONT> method for constructor three has the same three components as the <FONT FACE="Courier New">&lt;init</FONT>()</FONT> method for constructor two: a superclass <FONT FACE="Courier New">&lt;init</FONT>()</FONT> invocation, the bytecodes for widthís initializer, and the bytecodes for the constructor body. One difference between constructor two and three is that constructor two does not begin with an explicit <FONT FACE="Courier New">this()</FONT> or <FONT FACE="Courier New">super()</FONT> invocation. As a result, the compiler places an invocation of the superclassís no-arg <FONT FACE="Courier New">&lt;init</FONT>()</FONT> method in constructor twoís <FONT FACE="Courier New">&lt;init</FONT>()</FONT> method. By contrast, constructor three begins with an explicit <FONT FACE="Courier New">super()</FONT> invocation, which the compiler converts into the corresponding superclass <FONT FACE="Courier New">&lt;init</FONT>()</FONT> invocation in constructor threeís <FONT FACE="Courier New">&lt;init</FONT>()</FONT> method.</P>
<P>For every class except <FONT FACE="Courier New">Object</FONT>, an <FONT FACE="Courier New">&lt;init</FONT>()</FONT> method must begin with an invocation of another <FONT FACE="Courier New">&lt;init</FONT>()</FONT> method belonging either to the same class or to the direct superclass. <FONT FACE="Courier New">&lt;init</FONT>()</FONT> methods are not allowed to catch exceptions thrown by the <FONT FACE="Courier New">&lt;init</FONT>()</FONT> method they invoke. If a subclass <FONT FACE="Courier New">&lt;init</FONT>()</FONT> method invokes a superclass <FONT FACE="Courier New">&lt;init</FONT>()</FONT> method that completes abnormally, for example, the subclass <FONT FACE="Courier New">&lt;init</FONT>()</FONT> method must also complete abnormally.</P>
<H3><P>Garbage Collection and Finalization of Objects</P>
</H3><P>As mentioned in earlier chapters, implementations of the Java Virtual Machine must have some kind of automatic storage management strategy for the heap, most likely a garbage collector. Applications can allocate memory for objects via the explicit and implicit ways described earlier in this chapter, but cannot explicitly free that memory. When an object becomes unreferenced by the application, the virtual machine may reclaim (garbage collect) that memory. Implementations can decide when to garbage collect unreferenced objects--even whether to garbage collect them at all. Java Virtual Machine implementations are not required to free memory occupied by unreferenced objects.</P>
<P>If a class declares a method named <FONT FACE="Courier New">finalize()</FONT> that returns <FONT FACE="Courier New">void</FONT>, the garbage collector will execute that method (called a &quot;finalizer&quot;) once on an instance of that class, before it frees the memory space occupied by that instance. Hereís an example of a class that declares a finalizer:</P>
<PRE><P><FONT FACE="Courier New">begin</FONT></P>
<FONT SIZE="2"><P></FONT><FONT FACE="Courier New">// On CD-ROM in file classlife/ex7/Finale.java
<P>class Finale {</P>
<P>    protected void finalize() {</P>
<P>        System.out.println("A Finale object was finalized.");</P>
<P>        //...</P>
<P>    }</P>
<P>    //...</P>
<P>}</P>
</FONT><FONT SIZE="2"><P>&nbsp;</P></FONT><FONT FACE="Courier New">end</FONT></P></PRE>
<P>Because a finalizer is a regular Java method, it may be invoked directly by the application. Such a direct invocation will not affect the automatic invocation of the finalizer by the garbage collector. The garbage collector may invoke an objectís finalizer at most once, sometime after the object becomes unreferenced and before the memory it occupies is reused. If the object becomes referenced again (resurrected) as a result of executing the finalizer code, and then becomes unreferenced again later, the garbage collector must not automatically invoke the finalizer a second time.</P>
<P>Any exceptions thrown by the <FONT FACE="Courier New">finalize()</FONT> method during its automatic invocation by the garbage collector are ignored. The garbage collector may invoke <FONT FACE="Courier New">finalize()</FONT> methods in any order, using any thread, or even concurrently via multiple threads. Finalization is described in more detail in Chapter 9, &quot;Garbage Collection.&quot;</P>
<H3><EM><P>Unloading and Finalization of Classes</P>
</EM></H3><P>In many ways, the lifetime of a class in the Java Virtual Machine is similar to the lifetime of an object. The virtual machine creates and initializes objects, allows the program to use the objects, and optionally garbage collects the objects after they are no longer referenced by the program. Similarly, the virtual machine loads, links, and initializes classes, allows the program to use the classes, and optionally unloads the classes after they are no longer referenced by the program. Just as the Java Virtual Machine will run an objectís <FONT FACE="Courier New">finalize()</FONT> method (if its class declares one) before it garbage collects the object, the Java Virtual Machine will run a classís <FONT FACE="Courier New">classFinalize()</FONT> method (if the class declares one) before it unloads the class.</P>
<P>Garbage collection and unloading of classes is important in the Java Virtual Machine because Java programs can be dynamically extended at runtime by loading types through class loader objects. All loaded types occupy memory space in the method area. If a Java application continuously loads types through class loader objects, the memory footprint of the method area will continuously grow. If some of the dynamically loaded types are needed only temporarily, the memory space occupied by those types can be freed by unloading the types after they are no longer needed.</P>
<P>The way in which a Java Virtual Machine can tell whether a dynamically loaded type is still needed by the application is similar to the way it tells whether an object is still needed by the program. If the application has no references to the type, then the type canít affect the future course of computation. The type is unreachable and can be garbage collected.</P>
<P>Types loaded through the primordial class loader will always be reachable and never be unloaded. Only dynamically loaded types--those loaded through class loader objects--can become unreachable and be unloaded by the virtual machine. A dynamically loaded type is unreachable if its <FONT FACE="Courier New">Class</FONT> instance is found to be unreachable through the normal process of garbage collecting the heap.</P>
<P>There are two ways a <FONT FACE="Courier New">Class</FONT> instance of a dynamically loaded type can be reachable through the normal process of garbage collection. First and most obviously, a <FONT FACE="Courier New">Class</FONT> instance will be reachable if the application holds an explicit reference to it. Second, a <FONT FACE="Courier New">Class</FONT> instance will be reachable if there is a reachable object on the heap whose type data in the method area refers to the <FONT FACE="Courier New">Class</FONT> instance. As mentioned in Chapter 5, &quot;The Java Virtual Machine,&quot; implementations must be able to locate the type data in the method are for an objectís class, given only a reference to the object. For this reason, the image of an object on the heap likely includes some kind of pointer to its type data in the method area. From the type data, the virtual machine must be able to locate the <FONT FACE="Courier New">Class</FONT> instances for the objectís class, all its superclasses, and all its superinterfaces. See Figure 7-2 for a graphical depiction of this way of &quot;reaching&quot; <FONT FACE="Courier New">Class</FONT> instances.</P>
<P><IMG SRC="fig7-2.gif" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/venners/images/fig7-2.gif" ALT="Figure 7-2"></P>

<P>Figure 7-2 shows the paths a garbage collector must traverse from a reachable object of class <FONT FACE="Courier New">MyThread</FONT> through the type data in the method area to find reachable <FONT FACE="Courier New">Class</FONT> instances. In this figure, objects on the heap are shown as light gray circles; type data in the method are is shown as dark gray rectangles. The <FONT FACE="Courier New">MyThread</FONT> class has the following declaration:</P>
<PRE><P><FONT FACE="Courier New">begin</FONT></P>
<FONT SIZE="2"><P></FONT><FONT FACE="Courier New">// On CD-ROM in file classlife/ex8/MyThread.java
<P>class MyThread extends Thread implements Cloneable {</P>
<P>}</P>
</FONT><FONT SIZE="2"><P>&nbsp;</P></FONT><FONT FACE="Courier New">end</FONT></P></PRE>
<P>From the reachable <FONT FACE="Courier New">MyThread</FONT> object (shown in the bottom right hand corner of the figure), the garbage collector follows a pointer to <FONT FACE="Courier New">MyThread</FONT>ís type data, where it finds:</P>
<UL><LI> A reference to <FONT FACE="Courier New">MyThread</FONT>ís <FONT FACE="Courier New">Class</FONT> instance on the heap
<LI> A pointer to the type data for <FONT FACE="Courier New">MyThread</FONT>ís direct superinterface, <FONT FACE="Courier New">Cloneable</FONT>
<LI> A pointer to the type data for <FONT FACE="Courier New">MyThread</FONT>ís direct superclass, <FONT FACE="Courier New">Thread</FONT></UL>
<P>From the type data for <FONT FACE="Courier New">Cloneable</FONT>, the garbage collector finds:</P>
<UL><LI> A reference to <FONT FACE="Courier New">Cloneable</FONT>ís <FONT FACE="Courier New">Class</FONT> instance on the heap</UL>
<P>From the type data for <FONT FACE="Courier New">Thread</FONT>, the garbage collector finds:</P>
<UL><LI> A reference to <FONT FACE="Courier New">Thread</FONT>ís <FONT FACE="Courier New">Class</FONT> instance on the heap
<LI> A pointer to the type data for <FONT FACE="Courier New">Thread</FONT>ís direct superinterface, <FONT FACE="Courier New">Runnable</FONT>
<LI> A pointer to the type data for <FONT FACE="Courier New">Thread</FONT>ís direct superclass, <FONT FACE="Courier New">Object</FONT></UL>
<P>From the type data for <FONT FACE="Courier New">Runnable</FONT>, the garbage collector finds:</P>
<UL><LI> A reference to <FONT FACE="Courier New">Runnable</FONT>ís <FONT FACE="Courier New">Class</FONT> instance on the heap</UL>
<P>From the type data for <FONT FACE="Courier New">Object</FONT>, the garbage collector finds:</P>
<UL><LI> A reference to <FONT FACE="Courier New">Objects</FONT>ís <FONT FACE="Courier New">Class</FONT> instance on the heap</UL>
<P>Thus, given only a reference to a reachable instance of class <FONT FACE="Courier New">MyThread</FONT>, the garbage collector is able to &quot;reach&quot; the <FONT FACE="Courier New">Class</FONT> instances for <FONT FACE="Courier New">MyThread</FONT> and all its supertypes: <FONT FACE="Courier New">Cloneable</FONT>, <FONT FACE="Courier New">Thread</FONT>, <FONT FACE="Courier New">Runnable</FONT>, and <FONT FACE="Courier New">Object</FONT>.</P>
<P> If a class declares a method, named <FONT FACE="Courier New">classFinalize()</FONT>, that is static, takes no parameters, and returns <FONT FACE="Courier New">void</FONT>, the Java Virtual Machine will execute that method (called a &quot;class finalizer&quot;) before it unloads the class. The class finalizer may have any access permission. Hereís an example:</P>
<PRE><P><FONT FACE="Courier New">begin</FONT></P>
<FONT SIZE="2"><P></FONT><FONT FACE="Courier New">// On CD-ROM in file classlife/ex7/GrandFinale.java
<P>class GrandFinale {</P>
<P>    static void classFinalize() {</P>
<P>        System.out.println(</P>
<P>            "Class GrandFinale was finally finalized.");</P>
<P>        //...</P>
<P>    }</P>
<P>    //...</P>
<P>}</P>
</FONT><FONT SIZE="2"><P>&nbsp;</P></FONT><FONT FACE="Courier New">end</FONT></P></PRE>
<P>Similar to the <FONT FACE="Courier New">finalize()</FONT> method, the <FONT FACE="Courier New">classFinalize()</FONT> method will be called only once by the Java Virtual Machine. If a classís <FONT FACE="Courier New">classFinalize()</FONT> method resurrects the class (makes it reachable again), the next time the class is unloaded its <FONT FACE="Courier New">classFinalize()</FONT> method wonít be invoked.</P>
<P>An example of dynamically loaded classes becoming unreachable and available for unloading is given at the end of Chapter 8, &quot;The Linking Model.&quot;</P>
<H3><EM><P>On the CD-ROM</P>
</EM></H3><P>The CD-ROM contains the source code examples from this chapter in the <FONT FACE="Courier New">classlife</FONT> directory.</P>
<H3><EM><P>The Resources Page</P>
</EM></H3><P>For more information about the material presented in this chapter, visit the resources page: <FONT FACE="Courier New"><A HREF="http://www.artima.com/insidejvm/classlife.html" tppabs="http://www.artima.com/insidejvm/classlife.html">http://www.artima.com/insidejvm/classlife.html</A></FONT>.</P>
<TABLE BORDER="0" WIDTH="100%">
<TR><TD><A HREF="http://www.pbg.mcgraw-hill.com/betabooks/stores.html" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/stores.html" target="bottom"><IMG SRC="hotkey.gif" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/images/hotkey.gif" ALIGN="LEFT" BORDER="0" WIDTH="40" HEIGHT="40" ALT="Orders"></A>
<IMG SRC="order_text.gif" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/images/order_text.gif" WIDTH="103" HEIGHT="41" ALT="Orders"></TD>
<TD ALIGN="RIGHT"><A HREF="chap06.html" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/venners/chap06.html"><IMG SRC="backward.gif" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/images/backward.gif" BORDER="0" ALT="Backward" WIDTH="32" HEIGHT="32"></A>&nbsp;<A HREF="chap08.html" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/venners/chap08.html"><IMG SRC="forward.gif" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/images/forward.gif" BORDER="0" ALT="Forward" WIDTH="32" HEIGHT="32"></A></TD></TR>
<TR><TD COLSPAN="2"><A HREF="mailto:computing@mcgraw-hill.com"><IMG SRC="hotkey.gif" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/images/hotkey.gif" ALIGN="LEFT" BORDER="0" WIDTH="40" HEIGHT="40" ALT="Comments"></A>
<IMG SRC="comment_text.gif" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/images/comment_text.gif" WIDTH="73" HEIGHT="39" ALT="Comments"></TD></TR>

</TABLE>
<HR>
<P ALIGN=CENTER>&nbsp;<A HREF="http://www.pbg.mcgraw-hill.com/computing/computing-home.html" tppabs="http://www.pbg.mcgraw-hill.com/computing/computing-home.html" TARGET="_top">COMPUTING
MCGRAW-HILL</A> | <A HREF="http://www.pbg.mcgraw-hill.com/betabooks/betabooks-home.html" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/betabooks-home.html" TARGET="_top">Beta Books</A>
| <A HREF="http://www.pbg.mcgraw-hill.com/computing/contact.html" tppabs="http://www.pbg.mcgraw-hill.com/computing/contact.html" TARGET="_top">Contact Us</A>
| <A HREF="http://www.pbg.mcgraw-hill.com/betabooks/stores.html" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/stores.html" TARGET="_top">Order Information</A>
| <A HREF="http://mcgraw-hill.inforonics.com/compsearch.shtml" tppabs="http://mcgraw-hill.inforonics.com/compsearch.shtml" TARGET="_top">Online Catalog</A></P>

<P ALIGN=CENTER><FONT SIZE="-1"><A HREF="http://www.pbg.mcgraw-hill.com/computing/computing-home.html" tppabs="http://www.pbg.mcgraw-hill.com/computing/computing-home.html" TARGET="_top">Computing McGraw-Hill</A> is an imprint of the <A HREF="http://www.pbg.mcgraw-hill.com/pbg-home.html" tppabs="http://www.pbg.mcgraw-hill.com/pbg-home.html" TARGET="_top">McGraw-Hill Professional Book Group</A>.</FONT></P>

<!-- begin footer -->
<HR>
<A HREF="http://www.mcgraw-hill.com/" tppabs="http://www.mcgraw-hill.com/" TARGET="_top"><IMG SRC="division-white.gif" tppabs="http://www.pbg.mcgraw-hill.com/images/division-white.gif" WIDTH="350" HEIGHT="44" ALT="A Division of the McGraw-Hill Companies" BORDER="0"></A><BR>
<FONT SIZE="-2">Copyright &copy; 1997 <A HREF="http://www.mcgraw-hill.com/" tppabs="http://www.mcgraw-hill.com/" TARGET="_top">
The McGraw-Hill Companies</A>. All rights reserved. Any use is subject to the 
<A HREF="http://www.mcgraw-hill.com/corporate/news_info/copyrttm.htm" tppabs="http://www.mcgraw-hill.com/corporate/news_info/copyrttm.htm" TARGET="_top">
Terms of Use</A>; the corporation also has a comprehensive <A HREF="http://www.mcgraw-hill.com/corporate/news_info/privacy.html" tppabs="http://www.mcgraw-hill.com/corporate/news_info/privacy.html" TARGET="_top">
Privacy Policy</A> governing information we may collect from our customers.</FONT>
<!-- end footer -->
</BODY>
</HTML>
