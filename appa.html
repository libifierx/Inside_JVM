<!-- All material contained herein is copyright (c) McGraw-Hill Professional Books
All Rights Reserved. No use of this material may be made without express written
permission of the copyright holder. HTML conversions by Mega Space [barry@megaspace.com] -->

<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=ISO-8859-1">
<TITLE>Understanding Digital Signatures: Inside the Java Virtual Machine
 by Bill Venners - Beta Version</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<TABLE BORDER="0" WIDTH="100%">
<TR><TD><A HREF="http://www.pbg.mcgraw-hill.com/betabooks/stores.html" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/stores.html" target="bottom"><IMG SRC="hotkey.gif" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/images/hotkey.gif" ALIGN="LEFT" BORDER="0" WIDTH="40" HEIGHT="40" ALT="Orders"></A>
<IMG SRC="order_text.gif" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/images/order_text.gif" WIDTH="103" HEIGHT="41" ALT="Orders"></TD>
<TD ALIGN="RIGHT"><A HREF="chap20.html" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/venners/chap20.html"><IMG SRC="backward.gif" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/images/backward.gif" BORDER="0" ALT="Backward" WIDTH="32" HEIGHT="32"></A>&nbsp;<A HREF="appb.html" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/venners/appb.html"><IMG SRC="forward.gif" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/images/forward.gif" BORDER="0" ALT="Forward" WIDTH="32" HEIGHT="32"></A></TD></TR>
<TR><TD COLSPAN="2"><A HREF="mailto:computing@mcgraw-hill.com"><IMG SRC="hotkey.gif" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/images/hotkey.gif" ALIGN="LEFT" BORDER="0" WIDTH="40" HEIGHT="40" ALT="Comments"></A>
<IMG SRC="comment_text.gif" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/images/comment_text.gif" WIDTH="73" HEIGHT="39" ALT="Comments"></TD></TR>

<TR><TD COLSPAN="2"><FONT FACE="ARIEL,HELVETICA" SIZE="-1"><I>&copy; 1997 The McGraw-Hill Companies, Inc.  All rights reserved.  <BR>Any use of this Beta Book is subject to the rules stated in the <A HREF="http://www.mcgraw-hill.com/corporate/news_info/copyrttm.htm" tppabs="http://www.mcgraw-hill.com/corporate/news_info/copyrttm.htm" target="_top">Terms of Use</A>.</I></FONT><br>
<script language="javascript">
    document.write("<a href='http://banners.linkbuddies.com/click.php?id=237296'><img src='http://banners.linkbuddies.com/image.php?id=237296&ref=" + document.referrer + "' width=468 height=60 alt='Click Here' border=0></a>");
</script></TD></TR>

</TABLE>
<HR>
<P><H1>Appendix A</H1></P>
<P><H2>Instruction Set by Opcode Mnemonic</H2></P>
<P>Appendix A lists Java Virtual Machine instructions in alphabetical order by opcode mnemonic. All 201 instructions that may legally appear in the bytecode streams stored in Java class files are described in detail in Appendix A.</P>
<P>Besides the opcodes for the 201 instructions that may appear in class files, the Java Virtual Machine specification describes two other families of opcodes: the reserved opcodes and the &quot;<FONT FACE="Courier New">_quick</FONT>&quot; opcodes. None of these opcodes can legally appear in the bytecode streams of Java class files.</P>
<P>The Java Virtual Machine specification lists three reserved opcodes, which are shown in Table A-1. These opcodes are reserved for internal use by Java Virtual Machine implementations and tools. The specification guarantees that these three opcodes will not be part of any future extension of the Java Virtual Machineís instruction set. As you may have guessed, the intended purpose of the <FONT FACE="Courier New">breakpoint</FONT> opcode is to provide a way for debuggers to implement breakpoints. The intended purpose of the other two reserved opcodes, <FONT FACE="Courier New">impdep1</FONT> and <FONT FACE="Courier New">impdep2</FONT>, is to serve as &quot;back doors&quot; to implementation-dependent software functionality or &quot;traps&quot; to implementation-dependent hardware functionality. </P>
<P>Table A-1. The reserved opcodes</P>
<TABLE WIDTH="500">
<TR><TD VALIGN="TOP"><STRONG>mnemonic</STRONG></TD><TD VALIGN="TOP"><STRONG>byte value</STRONG></TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">breakpoint</FONT></TD><TD VALIGN="TOP">202 (0xca)</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">impdep1</FONT></TD><TD VALIGN="TOP">254 (0xfe)</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">impdep2</FONT></TD><TD VALIGN="TOP">255 (0xff)</TD></TR>
</TABLE>
<P>The Java Virtual Machine specification also lists 25 &quot;<FONT FACE="Courier New">_quick</FONT>&quot; opcodes, which Sunís virtual machine implementation uses internally to speed up the interpreted execution of bytecodes. This optimization technique is described in general in this book in Chapter 8, &quot;The Linking Model,&quot; but the individual &quot;<FONT FACE="Courier New">_quick</FONT>&quot; instructions are not described in detail in Appendix A. (The &quot;<FONT FACE="Courier New">_quick</FONT>&quot; opcodes do appear in Appendix C, which lists their mnemonics and corresponding opcode byte values.) Like the reserved opcodes, the &quot;<FONT FACE="Courier New">_quick</FONT>&quot; opcodes may not legally appear in Java class files. But unlike the reserved opcodes, the Java Virtual Machine specification leaves open the possibility that these opcodes will take on new meanings in future extensions of the instruction set.</P>
<P>For each instruction listed in Appendix A, you will find the following information:</P>
<UL>
<LI> the mnemonic
<LI> a short description
<LI> the opcodeís byte value in decimal and hex
<LI> the format of the instruction
<LI> the operand stack before and after the instruction is executed
<LI> a description of any constraints associated with the instruction
<LI> a description of the execution of the instruction
<LI> a description of any exceptions or errors that may be thrown by the instruction
</UL>
<P>The format of each instruction appears as a list of comma-separated items next to the label &quot;Instruction Format,&quot; with each item representing one byte in the bytecode stream. The opcode mnemonic appears first (in fixed-width font), followed by any operands (shown in italics).</P>
<P>For each instruction, Appendix A shows two snapshots of the operand stack. One snapshot, labelled &quot;Before,&quot; shows the contents of the current methodís operand stack just before the instruction is executed. The other snapshot, labelled &quot;After,&quot; shows the operand stack immediately after execution of the instruction.  In both snapshots, the operand stack appears as a list of comma-separated items, with each item representing one word. Although everywhere else in this book the operand stack is shown growing downwards (the top of the stack appears at the bottom of the picture), in Appendix A the operand stack is shown growing sideways, from left to right. In each snapshot, the top of the stack is the rightmost item shown. Unaffected portions of the operand stack are shown as an elipsis, &quot;...&quot;.</P>
<P>For each instruction, the section labelled &quot;Description&quot; combines three kinds of information: constraints, the process of execution, and exceptions and errors. As mentioned in Chapter 3, &quot;Security,&quot; Java Virtual Machine implementations are required to enforce at run-time certain constraints on the bytecodes of every method they execute. Whenever you see the word &quot;must&quot; in an instructionís description in Appendix A, you are reading about a constraint every implementation must enforce when executing the instruction. For example, the <FONT FACE="Courier New">goto</FONT> instruction, which causes an unconditional jump, may only cause a jump to another opcode of the same method. In Appendix Aís description for <FONT FACE="Courier New">goto</FONT>, this constraint is stated as, &quot;The target address <I>must</I> be the address of an opcode within the same method as the <FONT FACE="Courier New">goto</FONT> opcode.&quot;</P>
<P>The designers of each individual Java Virtual Machine implementation can decide how and when to detect violations of the bytecode constraints. If any implementation detects a constraint violation, it must report the violation by throwing a <FONT FACE="Courier New">VerifyError</FONT> when (and if) the running program attempts to execute the instruction.</P>
<P>In addition to describing the constraints placed on each instruction, Appendix A describes the process of executing each instruction and lists any errors or exceptions that may be thrown during the course of executing the instruction. Besides the errors and exceptions explicitly listed in the instruction descriptions, one other family of errors, subclasses of <FONT FACE="Courier New">VirtualMachineError</FONT>, can be thrown at any time as the result of executing any instruction. Four subclasses of <FONT FACE="Courier New">VirtualMachineError</FONT>, and the circumstances under which they will be thrown, are:</P>
<UL>
<LI> <FONT FACE="Courier New">OutOfMemoryError</FONT> - the virtual machine has run out of real or virtual memory, and the garbage collector canít reclaim enough space to enable the thread to continue.
<LI> <FONT FACE="Courier New">StackOverflowError</FONT> - a thread has exhausted its supply of memory for stack space (usually because the application has an unbounded recursion).
<LI> <FONT FACE="Courier New">InternalError</FONT> - the virtual machine has encountered a bug in its own implementation that prevents it from properly implementing the semantics of the Java language.
<LI> <FONT FACE="Courier New">UnknownError</FONT> - the virtual machine has encountered some error condition, but is unable to report the actual condition by throwing the appropriate exception or error.
</UL>
<P><H3><FONT FACE="Courier New">aaload</H3></FONT> - Load <FONT FACE="Courier New">reference</FONT> from array</P>
<P><H3>Opcode:</H3> 50 (0x32)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">aaload</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., arrayref, index</P></EM></H4>
<P>After:<I>..., value</P></EM></H4>
<P><H3>Description:</H3></P>
<P>To execute the <FONT FACE="Courier New">iaload</FONT> instruction, the Java Virtual Machine first pops two words from the operand stack. The <I>arrayref</I> word must be a <FONT FACE="Courier New">reference</FONT> that refers to an array of <FONT FACE="Courier New">reference</FONT>s. The <I>index</I> word must be an <FONT FACE="Courier New">int</FONT>. The virtual machine retrieves from the <I>arrayref</I> array the <FONT FACE="Courier New">reference</FONT> <I>value</I> specified by <I>index</I> and pushes it onto the operand stack.</P>
<P>If <I>arrayref</I> is <FONT FACE="Courier New">null</FONT>, the Java Virtual Machine throws <FONT FACE="Courier New">NullPointerException</FONT>. Otherwise, if <I>index</I> is not a legal index into the <I>arrayref</I> array, the virtual machine throws <FONT FACE="Courier New">ArrayIndexOutOfBoundsException</FONT>.</P>
<P>For more information about the <FONT FACE="Courier New">aaload</FONT> instruction, see Chapter 15, &quot;Objects and Arrays.&quot;</P>
<P><H3><FONT FACE="Courier New">aastore</H3></FONT> - Store <FONT FACE="Courier New">reference</FONT> into array</P>
<P><H3>Opcode:</H3> 83 (0x53)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">aastore</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., arrayref, index, value</P></EM></H4>
<P>After:<I>...</P></EM></H4>
<P><H3>Description:</H3></P>
<P>To execute the <FONT FACE="Courier New">aaload</FONT> instruction, the Java Virtual Machine first pops three words from the operand stack. The <I>arrayref</I> word must be a <FONT FACE="Courier New">reference</FONT> that refers to an array of <FONT FACE="Courier New">float</FONT>s. The <I>index</I> word must be an <FONT FACE="Courier New">int</FONT>, and the <I>value</I> word must be a <FONT FACE="Courier New">reference</FONT>. The type of <I>value</I> must be assignment compatible with the component type of the <I>arrayref</I> array. The virtual machine stores <FONT FACE="Courier New">reference</FONT> <I>value</I> into the <I>arrayref</I> array location specified by <I>index</I>.</P>
<P>If <I>arrayref</I> is <FONT FACE="Courier New">null</FONT>, the Java Virtual Machine throws <FONT FACE="Courier New">NullPointerException</FONT>. Else, if <I>index</I> is not a legal index into the <I>arrayref</I> array, the virtual machine throws <FONT FACE="Courier New">ArrayIndexOutOfBoundsException</FONT>. Otherwise, if the actual type of <I>value</I> is not assignment compatible with the actual type of the components of the <I>arrayref</I> array, the virtual machine throws <FONT FACE="Courier New">ArrayStoreException</FONT>.</P>
<P>For more information about the <FONT FACE="Courier New">aastore</FONT> instruction, see Chapter 15, &quot;Objects and Arrays.&quot;</P>
<P><H3><FONT FACE="Courier New">aconst_null</H3></FONT> - Push <FONT FACE="Courier New">null</FONT> object reference</P>
<P><H3>Opcode:</H3> 1 (0x1)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">aconst_null</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>...</P></EM></H4>
<P>After:<I>..., null</P></EM></H4>
<P><H3>Description:</H3></P>
<P>To execute the <FONT FACE="Courier New">aconst_null</FONT> instruction, the Java Virtual Machine pushes a <FONT FACE="Courier New">null</FONT> object reference onto the operand stack. (Note that the Java Virtual Machine specification does not dictate any actual value for <FONT FACE="Courier New">null</FONT>. The specification leaves that decision to the designers of each individual implementation.)</P>
<P>For more information about the <FONT FACE="Courier New">aconst_null</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<P><H3><FONT FACE="Courier New">aload</H3></FONT> - Load <FONT FACE="Courier New">reference</FONT> from local variable</P>
<P><H3>Opcode:</H3> 25 (0x19)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">aload</FONT>, <I>index</P></EM></H4>
<P><H3>Stack:</H3></P>
<P>Before:<I>...</P></EM></H4>
<P>After:<I>..., value</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The <I>index</I> operand, which serves as an 8-bit unsigned index into the local variables of the current frame, must specify a local variable word that contains a <FONT FACE="Courier New">reference</FONT>. To execute the <FONT FACE="Courier New">aload</FONT> instruction, the Java Virtual Machine pushes onto the operand stack the <FONT FACE="Courier New">reference</FONT> contained in the local variable word specified by <I>index</I>.</P>
<P>Note that the <FONT FACE="Courier New">wide</FONT> instruction can precede the <FONT FACE="Courier New">aload</FONT> instruction, to allow a local variable to be accessed with a 16-bit unsigned offset.</P>
<P>Note also that even though the <FONT FACE="Courier New">astore</FONT> instruction may be used to pop a <FONT FACE="Courier New">returnAddress</FONT> value off the operand stack and into a local variable, the <FONT FACE="Courier New">aload</FONT> instruction cannot be used to push a <FONT FACE="Courier New">returnAddress</FONT> value back onto the operand stack. For more information about the use of <FONT FACE="Courier New">returnAddress</FONT>, see Chapter 18, &quot;Finally Clauses.&quot;</P>
<P>For more information about the <FONT FACE="Courier New">aload</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<P><H3><FONT FACE="Courier New">aload_0</H3></FONT> - Load <FONT FACE="Courier New">reference</FONT> from local variable 0</P>
<P><H3>Opcode:</H3> 42 (0x2a)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">aload_0</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>...</P></EM></H4>
<P>After:<I>..., value</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The local variable word at index zero must contain a <FONT FACE="Courier New">reference</FONT>. To execute the <FONT FACE="Courier New">aload_0</FONT> instruction, the Java Virtual Machine pushes onto the operand stack the <FONT FACE="Courier New">reference</FONT> <I>value</I> contained in the local variable word zero.</P>
<P>Note that even though the <FONT FACE="Courier New">astore_0</FONT> instruction may be used to pop a <FONT FACE="Courier New">returnAddress</FONT> value off the operand stack and into a local variable, the <FONT FACE="Courier New">aload_0</FONT> instruction cannot be used to push a <FONT FACE="Courier New">returnAddress</FONT> value back onto the operand stack. For more information about the use of <FONT FACE="Courier New">returnAddress</FONT>, see Chapter 18, &quot;Finally Clauses.&quot;</P>
<P>For more information about the <FONT FACE="Courier New">aload_0</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<P><H3><FONT FACE="Courier New">aload_1</H3></FONT> - Load <FONT FACE="Courier New">reference</FONT> from local variable 1</P>
<P><H3>Opcode:</H3> 43 (0x2b)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">aload_1</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>...</P></EM></H4>
<P>After:<I>..., value</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The local variable word at index one must contain a <FONT FACE="Courier New">reference</FONT>. To execute the <FONT FACE="Courier New">aload_1</FONT> instruction, the Java Virtual Machine pushes onto the operand stack the <FONT FACE="Courier New">reference</FONT> <I>value</I> contained in the local variable word one.</P>
<P>Note that even though the <FONT FACE="Courier New">astore_1</FONT> instruction may be used to pop a <FONT FACE="Courier New">returnAddress</FONT> value off the operand stack and into a local variable, the <FONT FACE="Courier New">aload_1</FONT> instruction cannot be used to push a <FONT FACE="Courier New">returnAddress</FONT> value back onto the operand stack. For more information about the use of <FONT FACE="Courier New">returnAddress</FONT>, see Chapter 18, &quot;Finally Clauses.&quot;</P>
<P>For more information about the <FONT FACE="Courier New">aload_1</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<P><H3><FONT FACE="Courier New">aload_2</H3></FONT> - Load <FONT FACE="Courier New">reference</FONT> from local variable 2</P>
<P><H3>Opcode:</H3> 44 (0x2c)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">aload_2</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>...</P></EM></H4>
<P>After:<I>..., value</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The local variable word at index two must contain a <FONT FACE="Courier New">reference</FONT>. To execute the <FONT FACE="Courier New">aload_2</FONT> instruction, the Java Virtual Machine pushes onto the operand stack the <FONT FACE="Courier New">reference</FONT> <I>value</I> contained in the local variable word two.</P>
<P>Note that even though the <FONT FACE="Courier New">astore_2</FONT> instruction may be used to pop a <FONT FACE="Courier New">returnAddress</FONT> value off the operand stack and into a local variable, the <FONT FACE="Courier New">aload_2</FONT> instruction cannot be used to push a <FONT FACE="Courier New">returnAddress</FONT> value back onto the operand stack. For more information about the use of <FONT FACE="Courier New">returnAddress</FONT>, see Chapter 18, &quot;Finally Clauses.&quot;</P>
<P>For more information about the <FONT FACE="Courier New">aload_2</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<P><H3><FONT FACE="Courier New">aload_3</H3></FONT> - Load <FONT FACE="Courier New">reference</FONT> from local variable 3</P>
<P><H3>Opcode:</H3> 45 (0x2d)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">aload_3</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>...</P></EM></H4>
<P>After:<I>..., value</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The local variable word at index three must contain a <FONT FACE="Courier New">reference</FONT>. To execute the <FONT FACE="Courier New">aload_3</FONT> instruction, the Java Virtual Machine pushes onto the operand stack the <FONT FACE="Courier New">reference</FONT> <I>value</I> contained in the local variable word three.</P>
<P>Note that even though the <FONT FACE="Courier New">astore_3</FONT> instruction may be used to pop a <FONT FACE="Courier New">returnAddress</FONT> value off the operand stack and into a local variable, the <FONT FACE="Courier New">aload_3</FONT> instruction cannot be used to push a <FONT FACE="Courier New">returnAddress</FONT> value back onto the operand stack. For more information about the use of <FONT FACE="Courier New">returnAddress</FONT>, see Chapter 18, &quot;Finally Clauses.&quot;</P>
<P>For more information about the <FONT FACE="Courier New">aload_3</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<P><H3><FONT FACE="Courier New">anewarray</H3></FONT> - Allocate new array of reference type components</P>
<P><H3>Opcode:</H3> 189 (0xbd)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">anewarray</FONT>, <I>indexbyte1</I>, <I>indexbyte2</P></EM></H4>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., count</P></EM></H4>
<P>After:<I>arrayref</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The top word of the operand stack, <I>count</I>, must be an <FONT FACE="Courier New">int</FONT>. To execute the <FONT FACE="Courier New">anewarray</FONT> instruction, the Java Virtual Machine first forms an unsigned 16-bit index into the constant pool by calculating <I>(indexbyte1 <FONT FACE="Courier New"> 8) | indexbyte2</I>. The virtual machine then looks up the constant pool entry specified by the calculated index. The constant pool entry at that index must be a <FONT FACE="Courier New">CONSTANT_Class_info</FONT> entry. If it hasnít already, the virtual machine resolves the entry. The entry may be a class, interface, or array type. </P>
<P>If the resolution is successful, the Java Virtual Machine pops <I>count</I> and creates on the heap an array of size <I>count</I> of the reference type specified by the resolved <FONT FACE="Courier New">CONSTANT_Class_info</FONT> entry. The virtual machine initializes each array element to its default initial value (<FONT FACE="Courier New">null</FONT>) and pushes <I>arrayref</I>, a reference to the new array, onto the operand stack.</P>
<P>As a result of executing this instruction, the Java Virtual Machine may throw any of the linking errors listed in Chapter 8, &quot;The Linking Model,&quot; as possible during resolution of a <FONT FACE="Courier New">CONSTANT_Class_info</FONT> entry. If resolution succeeds, but <I>count</I> is less than zero, the virtual machine throws <FONT FACE="Courier New">NegativeArraySizeException</FONT>.</P>
<P>For more information about the <FONT FACE="Courier New">anewarray</FONT> instruction, see Chapter 15, &quot;Objects and Arrays.&quot;</P>
<P><H3><FONT FACE="Courier New">areturn</H3></FONT> - Return <FONT FACE="Courier New">reference</FONT>from method</P>
<P><H3>Opcode:</H3> 176 (0xb0)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">areturn</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., objectref</P></EM></H4>
<P>After:<I>[empty]</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The return type of the returning method must be <FONT FACE="Courier New">reference</FONT>. The top word of the operand stack, <I> objectref</I> , must be a <FONT FACE="Courier New">reference</FONT> that is assignment compatible with the type represented by the returning methodís descriptor. To execute the <FONT FACE="Courier New">areturn</FONT> instruction, the Java Virtual Machine pops <I>objectref</I> from the operand stack of the current frame and pushes it onto the operand stack of the invoking methodís frame. The virtual machine discards any other words that may still be on the returning methodís frame. If the returning method is synchronized, the monitor that was acquired when the method was invoked is released. The invoking methodís frame is made current, and the virtual machine continues execution in the invoking method.</P>
<P>For more information about monitors, see Chapter 20, &quot;Thread Synchronization.&quot; For more information about the <FONT FACE="Courier New">areturn</FONT> instruction, see Chapter 19, &quot;Method Invocation and Return.&quot;</P>
<P><H3><FONT FACE="Courier New">arraylength</H3></FONT> - Get length of array</P>
<P><H3>Opcode:</H3> 190 (0xbe)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">arraylength</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., arrayref</P></EM></H4>
<P>After:<I>..., length</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The top word of the operand stack, <I>arrayref</I>, must be a <FONT FACE="Courier New">reference</FONT> that points to an array. To execute the <FONT FACE="Courier New">arraylength</FONT> instruction, the Java Virtual Machine pops <I>arrayref</I> and pushes the length of the array pointed to by <I>arrayref</I>.</P>
<P>If <I>arrayref</I> is <FONT FACE="Courier New">null</FONT>, the Java Virtual Machine throws <FONT FACE="Courier New">NullPointerException</FONT>.</P>
<P>For more information about the <FONT FACE="Courier New">arraylength</FONT> instruction, see Chapter 15, &quot;Objects and Arrays.&quot;</P>
<P><H3><FONT FACE="Courier New">astore</H3></FONT> - Store <FONT FACE="Courier New">reference</FONT> or <FONT FACE="Courier New">returnAddress</FONT> into local variable</P>
<P><H3>Opcode:</H3> 58 (0x3a)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">astore</FONT>, <I>index</P></EM></H4>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value</P></EM></H4>
<P>After:<I>...</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The <I>index</I> operand must specify a valid 8-bit unsigned index into the local variables of the current frame. The <I>value</I> on the top of the operand stack must be a <FONT FACE="Courier New">reference</FONT> or a <FONT FACE="Courier New">returnAddress</FONT>. To execute the <FONT FACE="Courier New">astore</FONT> instruction, the Java Virtual Machine pops the <FONT FACE="Courier New">reference</FONT> or <FONT FACE="Courier New">returnAddress</FONT> <I>value</I> from the top of the operand stack and stores it into the local variable word specified by <I>index</I>.</P>
<P>Note that the <FONT FACE="Courier New">wide</FONT> instruction can precede the <FONT FACE="Courier New">astore</FONT> instruction, to enable a <I>value</I> to be stored into a local variable specified by a 16-bit unsigned offset.</P>
<P>For more information about the <FONT FACE="Courier New">astore</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<P><H3><FONT FACE="Courier New">astore_0</H3></FONT> - Store <FONT FACE="Courier New">reference</FONT> or <FONT FACE="Courier New">returnAddress</FONT> into local variable 0</P>
<P><H3>Opcode:</H3> 75 (0x4b)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">astore_0</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value</P></EM></H4>
<P>After:<I>...</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The index zero must be a valid index into the local variables of the current stack frame, and the <I>value</I> word on the top of the operand stack must be a <FONT FACE="Courier New">reference</FONT> or a <FONT FACE="Courier New">returnAddress</FONT>. To execute the <FONT FACE="Courier New">astore_0</FONT> instruction, the Java Virtual Machine pops the <FONT FACE="Courier New">reference</FONT> or <FONT FACE="Courier New">returnAddress</FONT> <I>value</I> from the top of the operand stack and stores it into the local variable word at index zero.</P>
<P>For more information about the <FONT FACE="Courier New">astore_0</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<P><H3><FONT FACE="Courier New">astore_1</H3></FONT> - Store <FONT FACE="Courier New">reference</FONT> or <FONT FACE="Courier New">returnAddress</FONT> into local variable 1</P>
<P><H3>Opcode:</H3> 76 (0x4c)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">astore_1</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value</P></EM></H4>
<P>After:<I>...</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The index one must be a valid index into the local variables of the current stack frame, and the <I>value</I> word on the top of the operand stack must be a <FONT FACE="Courier New">reference</FONT> or a <FONT FACE="Courier New">returnAddress</FONT>. To execute the <FONT FACE="Courier New">astore_1</FONT> instruction, the Java Virtual Machine pops the <FONT FACE="Courier New">reference</FONT> or <FONT FACE="Courier New">returnAddress</FONT> <I>value</I> from the top of the operand stack and stores it into the local variable word at index one.</P>
<P>For more information about the <FONT FACE="Courier New">astore_1</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<P><H3><FONT FACE="Courier New">astore_2</H3></FONT> - Store <FONT FACE="Courier New">reference</FONT> or <FONT FACE="Courier New">returnAddress</FONT> into local variable 2</P>
<P><H3>Opcode:</H3> 77 (0x4d)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">astore_2</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value</P></EM></H4>
<P>After:<I>...</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The index two must be a valid index into the local variables of the current stack frame, and the <I>value</I> word on the top of the operand stack must be a <FONT FACE="Courier New">reference</FONT> or a <FONT FACE="Courier New">returnAddress</FONT>. To execute the <FONT FACE="Courier New">astore_2</FONT> instruction, the Java Virtual Machine pops the <FONT FACE="Courier New">reference</FONT> or <FONT FACE="Courier New">returnAddress</FONT> <I>value</I> from the top of the operand stack and stores it into the local variable word at index two.</P>
<P>For more information about the <FONT FACE="Courier New">astore_2</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<P><H3><FONT FACE="Courier New">astore_3</H3></FONT> - Store <FONT FACE="Courier New">reference</FONT> or <FONT FACE="Courier New">returnAddress</FONT> into local variable 3</P>
<P><H3>Opcode:</H3> 78 (0x4e)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">astore_3</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value</P></EM></H4>
<P>After:<I>...</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The index three must be a valid index into the local variables of the current stack frame, and the <I>value</I> word on the top of the operand stack must be a <FONT FACE="Courier New">reference</FONT> or a <FONT FACE="Courier New">returnAddress</FONT>. To execute the <FONT FACE="Courier New">astore_3</FONT> instruction, the Java Virtual Machine pops the <FONT FACE="Courier New">reference</FONT> or <FONT FACE="Courier New">returnAddress</FONT> <I>value</I> from the top of the operand stack and stores it into the local variable word at index three.</P>
<P>For more information about the <FONT FACE="Courier New">astore_3</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<P><H3><FONT FACE="Courier New">athrow</H3></FONT> - Throw exception or error</P>
<P><H3>Opcode:</H3> 191 (0xbf)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">athrow</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., objectref</P></EM></H4>
<P>After<I>objectref</P></EM></H4>
<P>Note that &quot;Before&quot; shows the operand stack of the frame belonging to the method containing the <FONT FACE="Courier New">athrow</FONT> instruction being executed. &quot;After&quot; shows the operand stack of the frame belonging to the method in which the catch clause is found, <I>if</I> a catch clause is found. If no catch clause is found, the thread exits and there are no more operand stacks for that thread.</P>
<P><H3>Description:</H3></P>
<P>The top word of the operand stack, <I>objectref</I>, must be a <FONT FACE="Courier New">reference</FONT> that points either to an instance of class <FONT FACE="Courier New">java.lang.Throwable</FONT> or to an instance of some subclass of <FONT FACE="Courier New">java.lang.Throwable</FONT>. To execute the <FONT FACE="Courier New">athrow</FONT> instruction, the Java Virtual Machine pops <I>objectref</I> from the operand stack. The virtual machine &quot;throws&quot; the exception by searching through the current methodís exception table for the most recent catch clause that catches either the class of the throwable object pointed to by <I>objectref</I>, or a subclass of the throwable objectís class. If the current methodís exception table contains a matching entry, the virtual machine extracts the address of the handler to jump to from the matching exception table entry. The virtual machine pops any words remaining on the operand stack, pushes the <I>objectref</I>, sets the program counter to the handler address, and continues execution there. If the current methodís exception table doesnít have a matching catch clause, the virtual machine pops the current methodís entire frame and rethrows the exception in the previous method. This process repeats until either a matching catch clause is found or the stack frames for all the methods along the current threadís call stack have been popped. If no catch clause is found by this process, the current thread exits.</P>
<P>If the <I>objectref</I> word is <FONT FACE="Courier New">null</FONT>, the virtual machine throws <FONT FACE="Courier New">NullPointerException</FONT>.</P>
<P>For more information about the <FONT FACE="Courier New">athrow</FONT> instruction, see Chapter 17, &quot;Exceptions.&quot;</P>
<P><H3><FONT FACE="Courier New">baload</H3></FONT> - Load <FONT FACE="Courier New">byte</FONT> or <FONT FACE="Courier New">boolean</FONT> from array</P>
<P><H3>Opcode:</H3> 51 (0x33)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">baload</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., arrayref, index</P></EM></H4>
<P>After:<I>..., value</P></EM></H4>
<P><H3>Description:</H3></P>
<P>To execute the <FONT FACE="Courier New">baload</FONT> instruction, the Java Virtual Machine first pops two words from the operand stack. The <I>arrayref</I> word must be a <FONT FACE="Courier New">reference</FONT> that refers to an array of <FONT FACE="Courier New">byte</FONT>s or <FONT FACE="Courier New">boolean</FONT>s. The <I>index</I> word must be an <FONT FACE="Courier New">int</FONT>. The virtual machine retrieves from the <I>arrayref</I> array the <FONT FACE="Courier New">byte</FONT> or <FONT FACE="Courier New">boolean</FONT> <I>value</I> specified by <I>index</I>, sign-extends it to an <FONT FACE="Courier New">int</FONT>, and pushes it onto the operand stack.</P>
<P>If <I>arrayref</I> is <FONT FACE="Courier New">null</FONT>, the Java Virtual Machine throws <FONT FACE="Courier New">NullPointerException</FONT>. Otherwise, if <I>index</I> is not a legal index into the <I>arrayref</I> array, the virtual machine throws <FONT FACE="Courier New">ArrayIndexOutOfBoundsException</FONT>.</P>
<P>For more information about the <FONT FACE="Courier New">baload</FONT> instruction, see Chapter 15, &quot;Objects and Arrays.&quot;</P>
<P><H3><FONT FACE="Courier New">bastore</H3></FONT> - Store into <FONT FACE="Courier New">byte</FONT> or <FONT FACE="Courier New">boolean</FONT> array</P>
<P><H3>Opcode:</H3> 84 (0x54)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">bastore</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., arrayref, index, value</P></EM></H4>
<P>After:<I>...</P></EM></H4>
<P><H3>Description:</H3></P>
<P>To execute the <FONT FACE="Courier New">bastore</FONT> instruction, the Java Virtual Machine first pops three words from the operand stack. The <I>arrayref</I> word must be a <FONT FACE="Courier New">reference</FONT> that refers to an array of <FONT FACE="Courier New">byte</FONT>s or <FONT FACE="Courier New">boolean</FONT>s. The <I>index</I> and <I>value</I> words must be <FONT FACE="Courier New">int</FONT>s. The virtual machine truncates the <FONT FACE="Courier New">int</FONT> <I>value</I> to a <FONT FACE="Courier New">byte</FONT> and stores it into the <I>arrayref</I> array location specified by <I>index</I>.</P>
<P>If <I>arrayref</I> is <FONT FACE="Courier New">null</FONT>, the Java Virtual Machine throws <FONT FACE="Courier New">NullPointerException</FONT>. Otherwise, if <I>index</I> is not a legal index into the <I>arrayref</I> array, the virtual machine throws <FONT FACE="Courier New">ArrayIndexOutOfBoundsException</FONT>.</P>
<P>For more information about the <FONT FACE="Courier New">bastore</FONT> instruction, see Chapter 15, &quot;Objects and Arrays.&quot;</P>
<P><H3><FONT FACE="Courier New">bipush</H3></FONT> - Push 8-bit signed integer</P>
<P><H3>Opcode:</H3> 16 (0x10)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">bipush</FONT>, <I>byte</P></EM></H4>
<P><H3>Stack:</H3></P>
<P>Before:<I>...</P></EM></H4>
<P>After:<I>..., value</P></EM></H4>
<P><H3>Description:</H3></P>
<P>To execute the <FONT FACE="Courier New">bipush</FONT> instruction, the Java Virtual Machine first sign-extends operand <I>byte</I>, an 8-bit signed integer, to an <FONT FACE="Courier New">int</FONT>. The virtual machine then pushes the resulting <FONT FACE="Courier New">int</FONT> <I>value</I> onto the operand stack.</P>
<P>For more information about the <FONT FACE="Courier New">bipush</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<P><H3><FONT FACE="Courier New">caload</H3></FONT> - Load <FONT FACE="Courier New">char</FONT> from array</P>
<P><H3>Opcode:</H3> 52 (0x34)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">caload</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., arrayref, index</P></EM></H4>
<P>After:<I>..., value</P></EM></H4>
<P><H3>Description:</H3></P>
<P>To execute the <FONT FACE="Courier New">caload</FONT> instruction, the Java Virtual Machine first pops two words from the operand stack. The <I>arrayref</I> word must be a <FONT FACE="Courier New">reference</FONT> that refers to an array of <FONT FACE="Courier New">char</FONT>s. The <I>index</I> word must be an <FONT FACE="Courier New">int</FONT>. The virtual machine retrieves from the <I>arrayref</I> array the <FONT FACE="Courier New">char</FONT> <I>value</I> specified by <I>index</I>, zero-extends it to an <FONT FACE="Courier New">int</FONT>, and pushes it onto the operand stack.</P>
<P>If <I>arrayref</I> is <FONT FACE="Courier New">null</FONT>, the Java Virtual Machine throws <FONT FACE="Courier New">NullPointerException</FONT>. Otherwise, if <I>index</I> is not a legal index into the <I>arrayref</I> array, the virtual machine throws <FONT FACE="Courier New">ArrayIndexOutOfBoundsException</FONT>.</P>
<P>For more information about the <FONT FACE="Courier New">caload</FONT> instruction, see Chapter 15, &quot;Objects and Arrays.&quot;</P>
<P><H3><FONT FACE="Courier New">castore</H3></FONT> - Store into <FONT FACE="Courier New">char</FONT> array</P>
<P><H3>Opcode:</H3> 85 (0x55)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">castore</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., arrayref, index, value</P></EM></H4>
<P>After:<I>...</P></EM></H4>
<P><H3>Description:</H3></P>
<P>To execute the <FONT FACE="Courier New">castore</FONT> instruction, the Java Virtual Machine first pops three words from the operand stack. The <I>arrayref</I> word must be a <FONT FACE="Courier New">reference</FONT> that refers to an array of <FONT FACE="Courier New">char</FONT>s. The <I>index</I> and <I>value</I> words must be <FONT FACE="Courier New">int</FONT>s. The virtual machine truncates the <FONT FACE="Courier New">int</FONT> <I>value</I> to a <FONT FACE="Courier New">char</FONT> and stores it into the <I>arrayref</I> array location specified by <I>index</I>.</P>
<P>If <I>arrayref</I> is <FONT FACE="Courier New">null</FONT>, the Java Virtual Machine throws <FONT FACE="Courier New">NullPointerException</FONT>. Otherwise, if <I>index</I> is not a legal index into the <I>arrayref</I> array, the virtual machine throws <FONT FACE="Courier New">ArrayIndexOutOfBoundsException</FONT>.</P>
<P>For more information about the <FONT FACE="Courier New">castore</FONT> instruction, see Chapter 15, &quot;Objects and Arrays.&quot;</P>
<P><H3><FONT FACE="Courier New">checkcast</H3></FONT> - Make sure object is of given type</P>
<P><H3>Opcode:</H3> 192 (0xc0)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">checkcast</FONT>, <I>indexbyte1</I>, <I>indexbyte2</P></I></H4>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., objectref</P></EM></H4>
<P>After:<I>..., objectref</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The top word of the stack, <I>objectref</I>, must be a <FONT FACE="Courier New">reference</FONT>. To execute the <FONT FACE="Courier New">checkcast</FONT> instruction, the Java Virtual Machine first forms an unsigned 16-bit index into the constant pool by calculating <I>(indexbyte1 <FONT FACE="Courier New"> 8) | indexbyte2</I>. </I>The virtual machine then looks up the constant pool entry specified by the calculated index. The constant pool entry at that index must be a <FONT FACE="Courier New">CONSTANT_Class_info</FONT> entry. If it hasnít already, the virtual machine resolves the entry. The entry may be a class, interface, or array type. If <I>objectref</I> is <FONT FACE="Courier New">null</FONT> or if <I>objectref</I> can be cast to the resolved type, the stack remains unchanged. Otherwise, the virtual machine throws <FONT FACE="Courier New">ClassCastException</FONT>.</P>
</I><P>To determine whether the object pointed to by <I>objectref</I> can be cast to the resolved type, the virtual machine first determines whether the object is a class instance or array. (It canít be an interface instance, because interfaces canít be instantiated.) If it is a class instance, and the resolved type is a class, not an interface, the object can be cast to the resolved class if the objectís class is the resolved class or a subclass of the resolved class. Else, if it is a class instance, and the resolved type is an interface, not an class, the object can be cast to the resolved interface if the objectís class implements the resolved interface. Otherwise, the object is an array. If the resolved type is a class, it must be <FONT FACE="Courier New">java.lang.Object</FONT>. Else, if the resolved type is an array of primitive types, the object must be an array of the same primitive type. Otherwise, the resolved type must be an array with a component type of some reference type, and the object must be an array with a component type that can be cast to the component type of the resolved array type. (Note that the dimension of an array doesnít enter into the <FONT FACE="Courier New">checkcast</FONT> check, only the component type of the array.)</P>
<P>As a result of executing this instruction, the virtual machine may throw any of the linking errors listed in Chapter 8, &quot;The Linking Model,&quot; as possible during resolution of a <FONT FACE="Courier New">CONSTANT_Class_info</FONT> entry. If resolution succeeds, but the resolved type cannot be cast to the resolved type, the virtual machine throws an <FONT FACE="Courier New">ClassCastException</FONT>.</P>
<P>For more information about the <FONT FACE="Courier New">checkcast</FONT> instruction, see Chapter 15, &quot;Objects and Arrays.&quot;</P>
<P><H3><FONT FACE="Courier New">d2f</H3></FONT> - Convert <FONT FACE="Courier New">double</FONT> to <FONT FACE="Courier New">float</FONT></P>
<P><H3>Opcode:</H3> 144 (0x90)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">d2f</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value.word1, value.word2</P></EM></H4>
<P>After:<I>..., result</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The top two words of the operand stack must be a <FONT FACE="Courier New">double</FONT>. To execute the <FONT FACE="Courier New">d2f</FONT> instruction, the Java Virtual Machine pops the <FONT FACE="Courier New">double</FONT> <I>value</I> from the operand stack, converts the <FONT FACE="Courier New">double</FONT> to a <FONT FACE="Courier New">float</FONT>, and pushes the <FONT FACE="Courier New">float</FONT> <I>result</I>. </P>
<P>To convert the <FONT FACE="Courier New">double</FONT> <I>value</I> to <FONT FACE="Courier New">float</FONT>, the Java Virtual Machine first checks to see if the <I>value</I> equals NaN (Not a Number). If so, the <FONT FACE="Courier New">float</FONT> <I>result</I> is also NaN. Else, if the magnitude of the <FONT FACE="Courier New">double</FONT> <I>value</I> is too small to be represented by a <FONT FACE="Courier New">float</FONT>, the <FONT FACE="Courier New">float</FONT> <I>result</I> is a zero of the same sign. Else, if the magnitude of the <FONT FACE="Courier New">double</FONT> <I>value</I> is too large to be represented by a <FONT FACE="Courier New">float</FONT>, the <FONT FACE="Courier New">float</FONT> <I>result</I> is an infinity of the same sign. Otherwise, the virtual machine converts the <FONT FACE="Courier New">double</FONT> <I>value</I> to <FONT FACE="Courier New">float</FONT> zero using IEEE 754 round-to-nearest mode.</P>
<P>Note that this instruction performs a narrowing primitive conversion. Because not all <FONT FACE="Courier New">double</FONT> values are representable by a <FONT FACE="Courier New">float</FONT>, the conversion may result in a loss of magnitude and precision.</P>
<P>For more information about the <FONT FACE="Courier New">d2f</FONT> instruction, see Chapter 11, &quot;Type Conversion.&quot;</P>
<P><H3><FONT FACE="Courier New">d2i</H3></FONT> - Convert <FONT FACE="Courier New">double</FONT> to <FONT FACE="Courier New">int</FONT></P>
<P><H3>Opcode:</H3> 142 (0x8e)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">d2i</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value.word1, value.word2</P></EM></H4>
<P>After:<I>..., result</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The top two words of the operand stack must be a <FONT FACE="Courier New">double</FONT>. To execute the <FONT FACE="Courier New">d2i</FONT> instruction, the Java Virtual Machine pops the <FONT FACE="Courier New">double</FONT> <I>value</I> from the operand stack, converts the <FONT FACE="Courier New">double</FONT> to an <FONT FACE="Courier New">int</FONT>, and pushes the <FONT FACE="Courier New">int</FONT> <I>result</I>.</P>
<P>To convert the <FONT FACE="Courier New">double</FONT> <I>value</I> to <FONT FACE="Courier New">int</FONT>, the Java Virtual Machine first checks to see if the <I>value</I> equals NaN (Not a Number). If so, the <FONT FACE="Courier New">int</FONT> <I>result</I> is zero. Else, if the <FONT FACE="Courier New">double</FONT> <I>value</I> is not a positive or negative infinity, the virtual machine rounds the <I>value</I> towards zero using IEEE 754 round-towards-zero mode. If the resulting integral value can be exactly represented by an <FONT FACE="Courier New">int</FONT>, the <FONT FACE="Courier New">int</FONT> <I>result</I> is that integral value. Otherwise, the magnitude of the <FONT FACE="Courier New">double</FONT> <I>value</I> is too great be represented in an  <FONT FACE="Courier New">int</FONT>. If <I>value</I> is positive, the <FONT FACE="Courier New">int</FONT> <I>result</I> is the largest positive integer representable in an <FONT FACE="Courier New">int</FONT>. If <I>value</I> is negative, the <FONT FACE="Courier New">int</FONT> <I>result</I> is the smallest negative integer representable in an <FONT FACE="Courier New">int</FONT>.</P>
<P>Note that this instruction performs a narrowing primitive conversion. Because not all <FONT FACE="Courier New">double</FONT> values are representable by an <FONT FACE="Courier New">int</FONT>, the conversion may result in a loss of magnitude and precision.</P>
<P>For more information about the <FONT FACE="Courier New">d2i</FONT> instruction, see Chapter 11, &quot;Type Conversion.&quot;</P>
<P><H3><FONT FACE="Courier New">d2l</H3></FONT> - Convert <FONT FACE="Courier New">double</FONT> to <FONT FACE="Courier New">long</FONT></P>
<P><H3>Opcode:</H3> 143 (0x8f)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">d2l</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value.word1, value.word2</P></EM></H4>
<P>After:<I>..., result.word1, result.word2</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The top two words of the operand stack must be a <FONT FACE="Courier New">double</FONT>. To execute the <FONT FACE="Courier New">d2l</FONT> instruction, the Java Virtual Machine pops the <FONT FACE="Courier New">double</FONT> <I>value</I> from the operand stack, converts the <FONT FACE="Courier New">double</FONT> to a <FONT FACE="Courier New">long</FONT>, and pushes the <FONT FACE="Courier New">long</FONT> <I>result</I>.</P>
<P>To convert the <FONT FACE="Courier New">double</FONT> <I>value</I> to <FONT FACE="Courier New">long</FONT>, the Java Virtual Machine first checks to see if the <I>value</I> equals NaN (Not a Number). If so, the <FONT FACE="Courier New">long</FONT> <I>result</I> is zero. Else, if the <FONT FACE="Courier New">double</FONT> <I>value</I> is not a positive or negative infinity, the virtual machine rounds the <I>value</I> towards zero using IEEE 754 round-towards-zero mode. If the resulting integral value can be exactly represented by a <FONT FACE="Courier New">long</FONT>, the <FONT FACE="Courier New">long</FONT> <I>result</I> is that integral value. Otherwise, the magnitude of the <FONT FACE="Courier New">double</FONT> <I>value</I> is too great be represented in a  <FONT FACE="Courier New">long</FONT>. If <I>value</I> is positive, the <FONT FACE="Courier New">long</FONT> <I>result</I> is the largest positive integer representable in a <FONT FACE="Courier New">long</FONT>. If <I>value</I> is negative, the <FONT FACE="Courier New">long</FONT> <I>result</I> is the smallest negative integer representable in an <FONT FACE="Courier New">long</FONT>.</P>
<P>Note that this instruction performs a narrowing primitive conversion. Because not all <FONT FACE="Courier New">double</FONT> values are representable by a <FONT FACE="Courier New">long</FONT>, the conversion may result in a loss of magnitude and precision.</P>
<P>For more information about the <FONT FACE="Courier New">d2l</FONT> instruction, see Chapter 11, &quot;Type Conversion.&quot;</P>
<P><H3><FONT FACE="Courier New">dadd</H3></FONT> - Add <FONT FACE="Courier New">double</FONT>s</P>
<P><H3>Opcode:</H3> 99 (0x63)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">dadd</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value1.word1, value1.word2, value2.word1, value2.word2</P></EM></H4>
<P>After:<I>..., result.word1, result.word2</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The top four words of the operand stack must be two <FONT FACE="Courier New">double</FONT>s, <I>value1</I> and <I>value2</I>. To execute the <FONT FACE="Courier New">dadd</FONT> instruction, the Java Virtual Machine pops <I>value1</I> and <I>value2</I>, adds them, and pushes the <FONT FACE="Courier New">double</FONT> <I>result</I>. The <I>result</I> produced by the <FONT FACE="Courier New">dadd</FONT> instruction is governed by the rules of IEEE 754 floating point arithmetic.</P>
<P>For more information about the <FONT FACE="Courier New">dadd</FONT> instruction, see Chapter 14, &quot;Floating Point Arithmetic.&quot;</P>
<P><H3><FONT FACE="Courier New">daload</H3></FONT> - Load <FONT FACE="Courier New">double</FONT> from array</P>
<P><H3>Opcode:</H3> 49 (0x31)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">daload</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., arrayref, index</P></EM></H4>
<P>After:<I>..., value.word1, value.word2</P></EM></H4>
<P><H3>Description:</H3></P>
<P>To execute the <FONT FACE="Courier New">daload</FONT> instruction, the Java Virtual Machine first pops two words from the operand stack. The <I>arrayref</I> word must be a <FONT FACE="Courier New">reference</FONT> that refers to an array of <FONT FACE="Courier New">double</FONT>s. The <I>index</I> word must be an <FONT FACE="Courier New">int</FONT>. The virtual machine retrieves from the <I>arrayref</I> array the <FONT FACE="Courier New">double</FONT> <I>value</I> specified by <I>index</I> and pushes it onto the operand stack.</P>
<P>If <I>arrayref</I> is <FONT FACE="Courier New">null</FONT>, the Java Virtual Machine throws <FONT FACE="Courier New">NullPointerException</FONT>. Otherwise, if <I>index</I> is not a legal index into the <I>arrayref</I> array, the virtual machine throws <FONT FACE="Courier New">ArrayIndexOutOfBoundsException</FONT>.</P>
<P>For more information about the <FONT FACE="Courier New">daload</FONT> instruction, see Chapter 15, &quot;Objects and Arrays.&quot;</P>
<P><H3><FONT FACE="Courier New">dastore</H3></FONT> - Store into <FONT FACE="Courier New">double</FONT> array</P>
<P><H3>Opcode:</H3> 82 (0x52)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">dastore</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., arrayref, index, value.word1, value.word2</P></EM></H4>
<P>After:<I>...</P></EM></H4>
<P><H3>Description:</H3></P>
<P>To execute the <FONT FACE="Courier New">daload</FONT> instruction, the Java Virtual Machine first pops four words from the operand stack. The <I>arrayref</I> word must be a <FONT FACE="Courier New">reference</FONT> that refers to an array of <FONT FACE="Courier New">double</FONT>s. The <I>index</I> word must be an <FONT FACE="Courier New">int</FONT>, and the <I>value</I> words must be a <FONT FACE="Courier New">double</FONT>. The virtual machine stores <FONT FACE="Courier New">double</FONT> <I>value</I> into the <I>arrayref</I> array location specified by <I>index</I>.</P>
<P>If <I>arrayref</I> is <FONT FACE="Courier New">null</FONT>, the Java Virtual Machine throws <FONT FACE="Courier New">NullPointerException</FONT>. Otherwise, if <I>index</I> is not a legal index into the <I>arrayref</I> array, the virtual machine throws <FONT FACE="Courier New">ArrayIndexOutOfBoundsException</FONT>.</P>
<P>For more information about the <FONT FACE="Courier New">dastore</FONT> instruction, see Chapter 15, &quot;Objects and Arrays.&quot;</P>
<P><H3><FONT FACE="Courier New">dcmpg</H3></FONT> - Compare <FONT FACE="Courier New">double</FONT>s (1 on NaN)</P>
<P><H3>Opcode:</H3> 152 (0x98)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">dcmpg</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value1.word1, value1.word2, value2.word1, value2.word2</P></EM></H4>
<P>After:<I>..., result</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The top four words of the operand stack must be two <FONT FACE="Courier New">double</FONT>s, <I>value1</I> and <I>value2</I>. To execute the <FONT FACE="Courier New">dcmpg</FONT> instruction, the Java Virtual Machine pops <I>value1</I> and <I>value2</I> off the operand stack and compares one against the other. If <I>value1</I> equals <I>value2</I>, the virtual machine pushes onto the operand stack <FONT FACE="Courier New">int</FONT> <I>result</I> zero. Else, if <I>value1</I> is greater than <I>value2</I>, the virtual machine pushes onto the operand stack <FONT FACE="Courier New">int</FONT> <I>result</I> one. Otherwise, if <I>value1</I> is less than <I>value2</I>, the virtual machine pushes onto the operand stack <FONT FACE="Courier New">int</FONT> <I>result</I> negative one. If either <I>value1</I> or <I>value2</I> equals NaN (Not a Number), the virtual machine pushes onto the operand stack <FONT FACE="Courier New">int</FONT> <I>result</I> one.</P>
<P>The <I>result</I> produced by the <FONT FACE="Courier New">fcmpg</FONT> instruction is governed by the rules of IEEE 754 floating point arithmetic. Note that the <FONT FACE="Courier New">dcmpg</FONT> instruction differs from the the <FONT FACE="Courier New">dcmpl</FONT> instruction only in its treatment of NaN. For more information about the <FONT FACE="Courier New">dcmpg</FONT> instruction, see Chapter 16, &quot;Control Flow.&quot;</P>
<P><H3><FONT FACE="Courier New">dcmpl</H3></FONT> - Compare <FONT FACE="Courier New">double</FONT>s (-1 on NaN)</P>
<P><H3>Opcode:</H3> 151 (0x97)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">dcmpl</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value1.word1, value1.word2, value2.word1, value2.word2</P></EM></H4>
<P>After:<I>..., result</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The top four words of the operand stack must be two <FONT FACE="Courier New">double</FONT>s, <I>value1</I> and <I>value2</I>. To execute the <FONT FACE="Courier New">dcmpg</FONT> instruction, the Java Virtual Machine pops <I>value1</I> and <I>value2</I> off the operand stack and compares one against the other. If <I>value1</I> equals <I>value2</I>, the virtual machine pushes onto the operand stack <FONT FACE="Courier New">int</FONT> <I>result</I> zero. Else, if <I>value1</I> is greater than <I>value2</I>, the virtual machine pushes onto the operand stack <FONT FACE="Courier New">int</FONT> <I>result</I> one. Otherwise, if <I>value1</I> is less than <I>value2</I>, the virtual machine pushes onto the operand stack <FONT FACE="Courier New">int</FONT> <I>result</I> negative one. If either <I>value1</I> or <I>value2</I> equals NaN (Not a Number), the virtual machine pushes onto the operand stack <FONT FACE="Courier New">int</FONT> <I>result</I> negative one.</P>
<P>The <I>result</I> produced by the <FONT FACE="Courier New">fcmpl</FONT> instruction is governed by the rules of IEEE 754 floating point arithmetic. Note that the <FONT FACE="Courier New">dcmpl</FONT> instruction differs from the the <FONT FACE="Courier New">dcmpg</FONT> instruction only in its treatment of NaN. For more information about the <FONT FACE="Courier New">dcmpl</FONT> instruction, see Chapter 16, &quot;Control Flow.&quot;</P>
<P><H3><FONT FACE="Courier New">dconst_0</H3></FONT> - Push <FONT FACE="Courier New">double</FONT> constant 0.0</P>
<P><H3>Opcode:</H3> 14 (0xe)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">dconst_0</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>...</P></EM></H4>
<P>After:<I>..., &lt;0.0</FONT>-word1, &lt;0.0</FONT>-word2</P></EM></H4>
<P><H3>Description:</H3></P>
<P>To execute the <FONT FACE="Courier New">dconst_0</FONT> instruction, the Java Virtual Machine pushes the <FONT FACE="Courier New">double</FONT> constant 0.0 onto the operand stack.</P>
<P>For more information about the <FONT FACE="Courier New">dconst_0</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<P><H3><FONT FACE="Courier New">dconst_1</H3></FONT> - Push <FONT FACE="Courier New">double</FONT> constant 1.0</P>
<P><H3>Opcode:</H3> 15 (0xf)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">dconst_1</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>...</P></EM></H4>
<P>After:<I>..., &lt;1.0</FONT>-word1, &lt;1.0</FONT>-word2</P></EM></H4>
<P><H3>Description:</H3></P>
<P>To execute the <FONT FACE="Courier New">dconst_1</FONT> instruction, the Java Virtual Machine pushes the <FONT FACE="Courier New">double</FONT> constant 1.0 onto the operand stack.</P>
<P>For more information about the <FONT FACE="Courier New">dconst_1</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<P><H3><FONT FACE="Courier New">ddiv</H3></FONT> - Divide <FONT FACE="Courier New">double</FONT>s</P>
<P><H3>Opcode:</H3> 111 (0x6f)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">ddiv</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value1.word1, value1.word2, value2.word1, value2.word2</P></EM></H4>
<P>After:<I>..., result.word1, result.word2</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The top four words of the operand stack must be two <FONT FACE="Courier New">double</FONT>s, <I>value1</I> and <I>value2</I>. To execute the <FONT FACE="Courier New">ddiv</FONT> instruction, the Java Virtual Machine pops <I>value1</I> and <I>value2</I>, divides <I>value1</I> by <I>value2</I> (<I> value1 / value2</I>), and pushes the <FONT FACE="Courier New">double</FONT> <I>result</I>. The <I>result</I> produced by the <FONT FACE="Courier New">ddiv</FONT> instruction is governed by the rules of IEEE 754 floating point arithmetic.</P>
<P>For more information about the <FONT FACE="Courier New">ddiv</FONT> instruction, see Chapter 14, &quot;Floating Point Arithmetic.&quot;</P>
<P><H3><FONT FACE="Courier New">dload</H3></FONT> - Load <FONT FACE="Courier New">double</FONT> from local variable</P>
<P><H3>Opcode:</H3> 24 (0x18)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">dload</FONT>, <I>index</P></EM></H4>
<P><H3>Stack:</H3></P>
<P>Before:<I>...</P></EM></H4>
<P>After:<I>..., value.word1, value.word2</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The <I>index</I> operand, which serves as an 8-bit unsigned index into the local variables of the current frame, must specify the first of two consecutive local variable words that contain a <FONT FACE="Courier New">double</FONT>. To execute the <FONT FACE="Courier New">dload</FONT> instruction, the Java Virtual Machine pushes onto the operand stack the <FONT FACE="Courier New">double</FONT> contained in the two consecutive local variable words specified by <I>index</I> and <I>index + 1</I>.</P>
<P>Note that the <FONT FACE="Courier New">wide</FONT> instruction can precede the <FONT FACE="Courier New">lload</FONT> instruction, to allow a local variable to be accessed with a 16-bit unsigned offset.</P>
<P>For more information about the <FONT FACE="Courier New">dload</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<P><H3><FONT FACE="Courier New">dload_0</H3></FONT> - Load <FONT FACE="Courier New">double</FONT> from local variable 0</P>
<P><H3>Opcode:</H3> 38 (0x26)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">dload_0</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>...</P></EM></H4>
<P>After:<I>..., value.word1, value.word2</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The two consecutive local variable words at indexes zero and one must contain a <FONT FACE="Courier New">double</FONT>. To execute the <FONT FACE="Courier New">dload_0</FONT> instruction, the Java Virtual Machine pushes onto the operand stack the <FONT FACE="Courier New">double</FONT> <I>value</I> contained in local variable words zero and one.</P>
<P>For more information about the <FONT FACE="Courier New">dload_0</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<P><H3><FONT FACE="Courier New">dload_1</H3></FONT> - Load <FONT FACE="Courier New">double</FONT> from local variable 1</P>
<P><H3>Opcode:</H3> 39 (0x27)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">dload_1</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>...</P></EM></H4>
<P>After:<I>..., value.word1, value.word2</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The two consecutive local variable words at indexes one and two must contain a <FONT FACE="Courier New">double</FONT>. To execute the <FONT FACE="Courier New">dload_1</FONT> instruction, the Java Virtual Machine pushes onto the operand stack the <FONT FACE="Courier New">double</FONT> <I>value</I> contained in local variable words one and two.</P>
<P>For more information about the <FONT FACE="Courier New">dload_1</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<P><H3><FONT FACE="Courier New">dload_2</H3></FONT> - Load <FONT FACE="Courier New">double</FONT> from local variable 2</P>
<P><H3>Opcode:</H3> 40 (0x28)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">dload_2</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>...</P></EM></H4>
<P>After:<I>..., value.word1, value.word2</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The two consecutive local variable words at indexes two and three must contain a <FONT FACE="Courier New">double</FONT>. To execute the <FONT FACE="Courier New">dload_2</FONT> instruction, the Java Virtual Machine pushes onto the operand stack the <FONT FACE="Courier New">double</FONT> <I>value</I> contained in local variable words two and three.</P>
<P>For more information about the <FONT FACE="Courier New">dload_2</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<P><H3><FONT FACE="Courier New">dload_3</H3></FONT> - Load <FONT FACE="Courier New">double</FONT> from local variable 3</P>
<P><H3>Opcode:</H3> 41 (0x29)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">dload_3</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>...</P></EM></H4>
<P>After:<I>..., value.word1, value.word2</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The two consecutive local variable words at indexes three and four must contain a <FONT FACE="Courier New">double</FONT>. To execute the <FONT FACE="Courier New">dload_3</FONT> instruction, the Java Virtual Machine pushes onto the operand stack the <FONT FACE="Courier New">double</FONT> <I>value</I> contained in local variable words three and four.</P>
<P>For more information about the <FONT FACE="Courier New">dload_3</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<P><H3><FONT FACE="Courier New">dmul</H3></FONT> - Multiply <FONT FACE="Courier New">double</FONT>s</P>
<P><H3>Opcode:</H3> 107 (0x6b)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">dmul</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value1.word1, value1.word2, value2.word1, value2.word2</P></EM></H4>
<P>After:<I>..., result.word1, result.word2</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The top four words of the operand stack must be two <FONT FACE="Courier New">double</FONT>s, <I>value1</I> and <I>value2</I>. To execute the <FONT FACE="Courier New">dmul</FONT> instruction, the Java Virtual Machine pops <I>value1</I> and <I>value2</I>, multiplies them, and pushes the <FONT FACE="Courier New">double</FONT> <I>result</I>. The <I>result</I> produced by the <FONT FACE="Courier New">dmul</FONT> instruction is governed by the rules of IEEE 754 floating point arithmetic.</P>
<P>For more information about the <FONT FACE="Courier New">dmul</FONT> instruction, see Chapter 14, &quot;Floating Point Arithmetic.&quot;</P>
<P><H3><FONT FACE="Courier New">dneg</H3></FONT> - Negate <FONT FACE="Courier New">double</FONT></P>
<P><H3>Opcode:</H3> 119 (0x77)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">dneg</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value.word1, value.word2</P></EM></H4>
<P>After:<I>..., result.word1, result.word2</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The top two words of the operand stack must be a <FONT FACE="Courier New">double</FONT>. To execute the <FONT FACE="Courier New">dneg</FONT> instruction, the Java Virtual Machine pops <I>value</I>, negates it, and pushes the <FONT FACE="Courier New">double</FONT> <I>result</I>. The <I>result</I> produced by the <FONT FACE="Courier New">dneg</FONT> instruction is governed by the rules of IEEE 754 floating point arithmetic.</P>
<P>Note that the <I>result</I> produced by a <FONT FACE="Courier New">dneg</FONT> instruction is not always the same as the number that would be produced by subtracting <I>value</I> from zero with the <FONT FACE="Courier New">dsub</FONT> instruction. The range of IEEE 754 floating point numbers includes two zeros, a positive zero and a negative zero. When <I>value</I> is +0.0, the <I>result</I> of the <FONT FACE="Courier New">dneg</FONT> instruction is -0.0. By contrast, when subtracting +0.0 from +0.0, the <FONT FACE="Courier New">dsub</FONT> instruction yields +0.0.</P>
<P>For more information about the <FONT FACE="Courier New">dneg</FONT> instruction, see Chapter 14, &quot;Floating Point Arithmetic.&quot;</P>
<P><H3><FONT FACE="Courier New">drem</H3></FONT> - Calculate remainder of division of <FONT FACE="Courier New">double</FONT>s</P>
<P><H3>Opcode:</H3> 115 (0x73)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">drem</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value1.word1, value1.word2, value2.word1, value2.word2</P></EM></H4>
<P>After:<I>..., result.word1, result.word2</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The top four words of the operand stack must be two <FONT FACE="Courier New">double</FONT>s, <I>value1</I> and <I>value2</I>. To execute the <FONT FACE="Courier New">drem</FONT> instruction, the Java Virtual Machine pops <I>value1</I> and <I>value2</I>, calculates the remainder, and pushes the <FONT FACE="Courier New">double</FONT> <I>result</I>. The remainder equals <I> value1 - (value1 / value2) * value2</I>, where <I>value1 / value2</I> is a truncating division, rather than the rounding division required by IEEE 754.</P>
<P>The behavior of <FONT FACE="Courier New">drem</FONT> is comparable to that of the C library function <FONT FACE="Courier New">fmod()</FONT>.The remainder of two <FONT FACE="Courier New">double</FONT>s can be calculated according to IEEE 754 floating point standard via the <FONT FACE="Courier New">IEEERemainder()</FONT> method of class <FONT FACE="Courier New">java.lang.Math</FONT>.</P>
<P>For more information about the <FONT FACE="Courier New">drem</FONT> instruction, see Chapter 14, &quot;Floating Point Arithmetic.&quot;</P>
<P><H3><FONT FACE="Courier New">dreturn</H3></FONT> - Return <FONT FACE="Courier New">double</FONT> from method</P>
<P><H3>Opcode:</H3> 175 (0xaf)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">dreturn</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value.word1, value.word2</P></EM></H4>
<P>After:<I>[empty]</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The return type of the returning method must be <FONT FACE="Courier New">double</FONT>. The top two words of the operand stack must be a <FONT FACE="Courier New">double</FONT>. To execute the <FONT FACE="Courier New">dreturn</FONT> instruction, the Java Virtual Machine pops <FONT FACE="Courier New">double</FONT> <I>value</I> from the operand stack of the current frame and pushes it onto the operand stack of the invoking methodís frame. The virtual machine discards any other words that may still be on the returning methodís frame. If the returning method is synchronized, the monitor that was acquired when the method was invoked is released. The invoking methodís frame is made current, and the virtual machine continues execution in the invoking method.</P>
<P>For more information about monitors, see Chapter 20, &quot;Thread Synchronization.&quot; For more information about the <FONT FACE="Courier New">dreturn</FONT> instruction, see Chapter 19, &quot;Method Invocation and Return.&quot;</P>
<P><H3><FONT FACE="Courier New">dstore</H3></FONT> - Store <FONT FACE="Courier New">double</FONT> into local variable</P>
<P><H3>Opcode:</H3> 57 (0x39)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">dstore</FONT>, <I>index</P></EM></H4>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value.word1, value.word2</P></EM></H4>
<P>After:<I>...</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The <I>index</I> operand must specify a valid 8-bit unsigned index into the local variables of the current frame. The top two words of the operand stack must be a <FONT FACE="Courier New">double</FONT>. To execute the <FONT FACE="Courier New">dstore</FONT> instruction, the Java Virtual Machine pops the <FONT FACE="Courier New">double</FONT> <I>value</I> from the top of the operand stack and stores it into the two consecutive local variable words at indexes <I>index</I> and <I>index + 1</I>.</P>
<P>Note that the <FONT FACE="Courier New">wide</FONT> instruction can precede the <FONT FACE="Courier New">dstore</FONT> instruction, to enable a <I>value</I> to be stored into a local variable specified by a 16-bit unsigned offset.</P>
<P>For more information about the <FONT FACE="Courier New">dstore</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<P><H3><FONT FACE="Courier New">dstore_0</H3></FONT> - Store <FONT FACE="Courier New">double</FONT> into local variable 0</P>
<P><H3>Opcode:</H3> 71 (0x47)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">dstore_0</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value.word1, value.word2</P></EM></H4>
<P>After:<I>...</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The indexes zero and one must be valid indexes into the local variables of the current stack frame. The top two words on the operand stack must be a <FONT FACE="Courier New">double</FONT>. To execute the <FONT FACE="Courier New">dstore_0</FONT> instruction, the Java Virtual Machine pops the <FONT FACE="Courier New">double</FONT> <I>value</I> from the top of the operand stack and stores it into the two consecutive local variable words at indexes zero and one.</P>
<P>For more information about the <FONT FACE="Courier New">dstore_0</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<P><H3><FONT FACE="Courier New">dstore_1</H3></FONT> - Store <FONT FACE="Courier New">double</FONT> into local variable 1</P>
<P><H3>Opcode:</H3> 72 (0x48)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">dstore_1</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value.word1, value.word2</P></EM></H4>
<P>After:<I>...</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The indexes one and two must be valid indexes into the local variables of the current stack frame. The top two words on the operand stack must be a <FONT FACE="Courier New">double</FONT>. To execute the <FONT FACE="Courier New">dstore_1</FONT> instruction, the Java Virtual Machine pops the <FONT FACE="Courier New">double</FONT> <I>value</I> from the top of the operand stack and stores it into the two consecutive local variable words at indexes one and two.</P>
<P>For more information about the <FONT FACE="Courier New">dstore_1</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<P><H3><FONT FACE="Courier New">dstore_2</H3></FONT> - Store <FONT FACE="Courier New">double</FONT> into local variable 2</P>
<P><H3>Opcode:</H3> 73 (0x49)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">dstore_2</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value.word1, value.word2</P></EM></H4>
<P>After:<I>...</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The indexes two and three must be valid indexes into the local variables of the current stack frame. The top two words on the operand stack must be a <FONT FACE="Courier New">double</FONT>. To execute the <FONT FACE="Courier New">dstore_2</FONT> instruction, the Java Virtual Machine pops the <FONT FACE="Courier New">double</FONT> <I>value</I> from the top of the operand stack and stores it into the two consecutive local variable words at indexes two and three.</P>
<P>For more information about the <FONT FACE="Courier New">dstore_2</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<P><H3><FONT FACE="Courier New">dstore_3</H3></FONT> - Store <FONT FACE="Courier New">double</FONT> into local variable 3</P>
<P><H3>Opcode:</H3> 74 (0x4a)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">dstore_3</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value.word1, value.word2</P></EM></H4>
<P>After:<I>...</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The indexes three and four must be valid indexes into the local variables of the current stack frame. The top two words on the operand stack must be a <FONT FACE="Courier New">double</FONT>. To execute the <FONT FACE="Courier New">dstore_3</FONT> instruction, the Java Virtual Machine pops the <FONT FACE="Courier New">double</FONT> <I>value</I> from the top of the operand stack and stores it into the two consecutive local variable words at indexes three and four.</P>
<P>For more information about the <FONT FACE="Courier New">dstore_3</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<P><H3><FONT FACE="Courier New">dsub</H3></FONT> - Subtract <FONT FACE="Courier New">double</FONT>s</P>
<P><H3>Opcode:</H3> 103 (0x67)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">dsub</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value1.word1, value1.word2, value2.word1, value2.word2</P></EM></H4>
<P>After:<I>..., result.word1, result.word2</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The top four words of the operand stack must be two <FONT FACE="Courier New">double</FONT>s, <I>value1</I> and <I>value2</I>. To execute the <FONT FACE="Courier New">dsub</FONT> instruction, the Java Virtual Machine pops <I>value1</I> and <I>value2</I>, subtracts <I>value2</I> from <I>value1</I> (<I> value1 - value2</I>), and pushes the <FONT FACE="Courier New">double</FONT> <I>result</I>. The <I>result</I> produced by the <FONT FACE="Courier New">dsub</FONT> instruction is governed by the rules of IEEE 754 floating point arithmetic.</P>
<P>For more information about the <FONT FACE="Courier New">dsub</FONT> instruction, see Chapter 14, &quot;Floating Point Arithmetic.&quot;</P>
<P><H3><FONT FACE="Courier New">dup</H3></FONT> - Duplicate top stack word</P>
<P><H3>Opcode:</H3> 89 (0x59)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">dup</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., word</P></EM></H4>
<P>After:<I>..., word, word</P></EM></H4>
<P><H3>Description:</H3></P>
<P>To execute the <FONT FACE="Courier New">dup</FONT> instruction, the Java Virtual Machine duplicates the top word of the operand stack and pushes the duplicate. This instruction can be used to duplicate any single-word value from the top of the operand stack. It must not be used to duplicate half of a dual word value (<FONT FACE="Courier New">long</FONT> or <FONT FACE="Courier New">double</FONT>) that occupies the top of the operand stack.</P>
<P>For more information about the <FONT FACE="Courier New">dup</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<P><H3><FONT FACE="Courier New">dup_x1</H3></FONT> - Duplicate top stack word and put two down</P>
<P><H3>Opcode:</H3> 90 (0x5a)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">dup_x1</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., word2, word1</P></EM></H4>
<P>After:<I>..., word1, word2, word1</P></EM></H4>
<P><H3>Description:</H3></P>
<P>To execute the <FONT FACE="Courier New">dup_x1</FONT> instruction, the Java Virtual Machine duplicates the top word of the operand stack and inserts the duplicate two words down. Both <I>word1</I> and <I>word2</I> must be single-word values.</P>
<P>For more information about the <FONT FACE="Courier New">dup_x1</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<P><H3><FONT FACE="Courier New">dup_x2</H3></FONT> - Duplicate top stack word and put three down</P>
<P><H3>Opcode:</H3> 91 (0x5b)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">dup_x2</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., word3, word2, word1</P></EM></H4>
<P>After:<I>..., word1, word3, word2, word1</P></EM></H4>
<P><H3>Description:</H3></P>
<P>To execute the <FONT FACE="Courier New">dup_x2</FONT> instruction, the Java Virtual Machine duplicates the top word of the operand stack and inserts the duplicate three words down. <I>word1</I> must be a single-word value. Both <I>word2</I> and <I>word3</I> must be single-word values, or together constitute one dual-word value (a <FONT FACE="Courier New">long</FONT> or <FONT FACE="Courier New">double</FONT>).</P>
<P>For more information about the <FONT FACE="Courier New">dup_x2</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<P><H3><FONT FACE="Courier New">dup2</H3></FONT> - Duplicate top two stack words</P>
<P><H3>Opcode:</H3> 92 (0x5c)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">dup2</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., word2, word1</P></EM></H4>
<P>After:<I>..., word2, word1, word2, word1</P></EM></H4>
<P><H3>Description:</H3></P>
<P>To execute the <FONT FACE="Courier New">dup2</FONT> instruction, the Java Virtual Machine duplicates the top two words of the operand stack and pushes the duplicate. This instruction may be used to duplicate any dual-word value or any two single-word values that occupy the top of the operand stack. It must not be used if one single-word value and half of a dual-word value (<FONT FACE="Courier New">long</FONT> or <FONT FACE="Courier New">double</FONT>) occupies the top of the operand stack.</P>
<P>For more information about the <FONT FACE="Courier New">dup2</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<P><H3><FONT FACE="Courier New">dup2_x1</H3></FONT> - Duplicate top two stack words and put three down</P>
<P><H3>Opcode:</H3> 93 (0x5d)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">dup2_x1</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., word3, word2, word1</P></EM></H4>
<P>After:<I>..., word2, word1, word3, word2, word1</P></EM></H4>
<P><H3>Description:</H3></P>
<P>To execute the <FONT FACE="Courier New">dup2_x1</FONT> instruction, the Java Virtual Machine duplicates the top two words of the operand stack and inserts the duplicate three words down. <I>word3</I> must be a single-word value. Both <I>word1</I> and <I>word2</I> must be single-word values, or together constitute one dual-word value (a <FONT FACE="Courier New">long</FONT> or <FONT FACE="Courier New">double</FONT>).</P>
<P>For more information about the <FONT FACE="Courier New">dup2_x1</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<P><H3><FONT FACE="Courier New">dup2_x2</H3></FONT> - Duplicate top two stack words and put four down</P>
<P><H3>Opcode:</H3> 94 (0x5e)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">dup2_x2</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., word4, word3, word2, word1</P></EM></H4>
<P>After:<I>..., word2, word1, word4, word3, word2, word1</P></EM></H4>
<P><H3>Description:</H3></P>
<P>To execute the <FONT FACE="Courier New">dup2_x2</FONT> instruction, the Java Virtual Machine duplicates the top two words of the operand stack and inserts the duplicate four words down. <I>word3</I> must be a single-word value. Both <I>word1</I> and <I>word2</I> must be single-word values, or together constitute one dual-word value (a <FONT FACE="Courier New">long</FONT> or <FONT FACE="Courier New">double</FONT>). Likewise, both <I>word3</I> and <I>word4</I> must be single-word values, or together constitute one dual-word value.</P>
<P>For more information about the <FONT FACE="Courier New">dup2_x2</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<P><H3><FONT FACE="Courier New">f2d</H3></FONT> - Convert <FONT FACE="Courier New">float</FONT> to <FONT FACE="Courier New">double</FONT></P>
<P><H3>Opcode:</H3> 141 (0x8d)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">f2d</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value</P></EM></H4>
<P>After:<I>..., result.word1, result.word2</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The top word of the operand stack, <I>value</I>, must be a <FONT FACE="Courier New">float</FONT>. To execute the <FONT FACE="Courier New">f2d</FONT> instruction, the Java Virtual Machine pops <FONT FACE="Courier New">float</FONT> <I>value</I> from the operand stack, converts the <FONT FACE="Courier New">float</FONT> to a <FONT FACE="Courier New">double</FONT>, and pushes the <FONT FACE="Courier New">double</FONT> <I>result</I>.</P>
<P>Note that this instruction performs a widening primitive conversion. Because all <FONT FACE="Courier New">float</FONT> values are representable by a <FONT FACE="Courier New">double</FONT>, the conversion is exact.</P>
<P>For more information about the <FONT FACE="Courier New">f2d</FONT> instruction, see Chapter 11, &quot;Type Conversion.&quot;</P>
<P><H3><FONT FACE="Courier New">f2i</H3></FONT> - Convert <FONT FACE="Courier New">float</FONT> to <FONT FACE="Courier New">int</FONT></P>
<P><H3>Opcode:</H3> 139 (0x8b)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">f2i</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value</P></EM></H4>
<P>After:<I>..., result</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The top word of the operand stack, <I>value</I>, must be a <FONT FACE="Courier New">float</FONT>. To execute the <FONT FACE="Courier New">f2i</FONT> instruction, the Java Virtual Machine pops the <FONT FACE="Courier New">float</FONT> <I>value</I> from the operand stack, converts the <FONT FACE="Courier New">float</FONT> to an <FONT FACE="Courier New">int</FONT>, and pushes the <FONT FACE="Courier New">int</FONT> <I>result</I>.</P>
<P>To convert the <FONT FACE="Courier New">float</FONT> <I>value</I> to <FONT FACE="Courier New">int</FONT>, the Java Virtual Machine first checks to see if the <I>value</I> equals NaN (Not a Number). If so, the <FONT FACE="Courier New">int</FONT> <I>result</I> is zero. Else, if the <FONT FACE="Courier New">float</FONT> <I>value</I> is not a positive or negative infinity, the virtual machine rounds the <I>value</I> towards zero using IEEE 754 round-towards-zero mode. If the resulting integral value can be exactly represented by an <FONT FACE="Courier New">int</FONT>, the <FONT FACE="Courier New">int</FONT> <I>result</I> is that integral value. Otherwise, the magnitude of the <FONT FACE="Courier New">float</FONT> <I>value</I> is too great be represented in an  <FONT FACE="Courier New">int</FONT>. If <I>value</I> is positive, the <FONT FACE="Courier New">int</FONT> <I>result</I> is the largest positive integer representable in an <FONT FACE="Courier New">int</FONT>. If <I>value</I> is negative, the <FONT FACE="Courier New">int</FONT> <I>result</I> is the smallest negative integer representable in an <FONT FACE="Courier New">int</FONT>.</P>
<P>Note that this instruction performs a narrowing primitive conversion. Because not all <FONT FACE="Courier New">float</FONT> values are representable by an <FONT FACE="Courier New">int</FONT>, the conversion may result in a loss of magnitude and precision.</P>
<P>For more information about the <FONT FACE="Courier New">f2i</FONT> instruction, see Chapter 11, &quot;Type Conversion.&quot;</P>
<P><H3><FONT FACE="Courier New">f2l</H3></FONT> - Convert <FONT FACE="Courier New">float</FONT> to <FONT FACE="Courier New">long</FONT></P>
<P><H3>Opcode:</H3> 140 (0x8c)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">f2l</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value</P></EM></H4>
<P>After:<I>..., result.word1, result.word2</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The top word of the operand stack, <I>value</I>, must be a <FONT FACE="Courier New">float</FONT>. To execute the <FONT FACE="Courier New">f2l</FONT> instruction, the Java Virtual Machine pops the <FONT FACE="Courier New">float</FONT> <I>value</I> from the operand stack, converts the <FONT FACE="Courier New">float</FONT> to a <FONT FACE="Courier New">long</FONT>, and pushes the <FONT FACE="Courier New">long</FONT> <I>result</I>.</P>
<P>To convert the <FONT FACE="Courier New">float</FONT> <I>value</I> to <FONT FACE="Courier New">long</FONT>, the Java Virtual Machine first checks to see if the <I>value</I> equals NaN (Not a Number). If so, the <FONT FACE="Courier New">long</FONT> <I>result</I> is zero. Else, if the <FONT FACE="Courier New">float</FONT> <I>value</I> is not a positive or negative infinity, the virtual machine rounds the <I>value</I> towards zero using IEEE 754 round-towards-zero mode. If the resulting integral value can be exactly represented by a <FONT FACE="Courier New">long</FONT>, the <FONT FACE="Courier New">long</FONT> <I>result</I> is that integral value. Otherwise, the magnitude of the <FONT FACE="Courier New">float</FONT> <I>value</I> is too great be represented in a  <FONT FACE="Courier New">long</FONT>. If <I>value</I> is positive, the <FONT FACE="Courier New">long</FONT> <I>result</I> is the largest positive integer representable in a <FONT FACE="Courier New">long</FONT>. If <I>value</I> is negative, the <FONT FACE="Courier New">int</FONT> <I>result</I> is the smallest negative integer representable in a <FONT FACE="Courier New">long</FONT>.</P>
<P>Note that this instruction performs a narrowing primitive conversion. Because not all <FONT FACE="Courier New">float</FONT> values are representable by a <FONT FACE="Courier New">long</FONT>, the conversion may result in a loss of magnitude and precision.</P>
<P>For more information about the <FONT FACE="Courier New">f2l</FONT> instruction, see Chapter 11, &quot;Type Conversion.&quot;</P>
<P><H3><FONT FACE="Courier New">fadd</H3></FONT> - Add <FONT FACE="Courier New">float</FONT>s</P>
<P><H3>Opcode:</H3> 98 (0x62)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">fadd</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value1, value2</P></EM></H4>
<P>After:<I>..., result</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The top two words of the operand stack, <I>value1</I> and <I>value2</I>, must be <FONT FACE="Courier New">float</FONT>s. To execute the <FONT FACE="Courier New">fadd</FONT> instruction, the Java Virtual Machine pops <I>value1</I> and <I>value2</I>, adds them, and pushes the <FONT FACE="Courier New">float</FONT> <I>result</I>. The <I>result</I> produced by the <FONT FACE="Courier New">fadd</FONT> instruction is governed by the rules of IEEE 754 floating point arithmetic.</P>
<P>For more information about the <FONT FACE="Courier New">fadd</FONT> instruction, see Chapter 14, &quot;Floating Point Arithmetic.&quot;</P>
<P><H3><FONT FACE="Courier New">faload</H3></FONT> - Load <FONT FACE="Courier New">float</FONT> from array</P>
<P><H3>Opcode:</H3> 48 (0x30)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">faload</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., arrayref, index</P></EM></H4>
<P>After:<I>..., value</P></EM></H4>
<P><H3>Description:</H3></P>
<P>To execute the <FONT FACE="Courier New">faload</FONT> instruction, the Java Virtual Machine first pops two words from the operand stack. The <I>arrayref</I> word must be a <FONT FACE="Courier New">reference</FONT> that refers to an array of <FONT FACE="Courier New">float</FONT>s. The <I>index</I> word must be an <FONT FACE="Courier New">int</FONT>. The virtual machine retrieves from the <I>arrayref</I> array the <FONT FACE="Courier New">float</FONT> <I>value</I> specified by <I>index</I> and pushes it onto the operand stack.</P>
<P>If <I>arrayref</I> is <FONT FACE="Courier New">null</FONT>, the Java Virtual Machine throws <FONT FACE="Courier New">NullPointerException</FONT>. Otherwise, if <I>index</I> is not a legal index into the <I>arrayref</I> array, the virtual machine throws <FONT FACE="Courier New">ArrayIndexOutOfBoundsException</FONT>.</P>
<P>For more information about the <FONT FACE="Courier New">faload</FONT> instruction, see Chapter 15, &quot;Objects and Arrays.&quot;</P>
<P><H3><FONT FACE="Courier New">fastore</H3></FONT> - Store into <FONT FACE="Courier New">float</FONT> array</P>
<P><H3>Opcode:</H3> 81 (0x51)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">fastore</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., arrayref, index, value</P></EM></H4>
<P>After:<I>...</P></EM></H4>
<P><H3>Description:</H3></P>
<P>To execute the <FONT FACE="Courier New">faload</FONT> instruction, the Java Virtual Machine first pops three words from the operand stack. The <I>arrayref</I> word must be a <FONT FACE="Courier New">reference</FONT> that refers to an array of <FONT FACE="Courier New">float</FONT>s. The <I>index</I> word must be an <FONT FACE="Courier New">int</FONT>, and the <I>value</I> word must be a <FONT FACE="Courier New">float</FONT>. The virtual machine stores <FONT FACE="Courier New">float</FONT> <I>value</I> into the <I>arrayref</I> array location specified by <I>index</I>.</P>
<P>If <I>arrayref</I> is <FONT FACE="Courier New">null</FONT>, the Java Virtual Machine throws <FONT FACE="Courier New">NullPointerException</FONT>. Otherwise, if <I>index</I> is not a legal index into the <I>arrayref</I> array, the virtual machine throws <FONT FACE="Courier New">ArrayIndexOutOfBoundsException</FONT>.</P>
<P>For more information about the <FONT FACE="Courier New">fastore</FONT> instruction, see Chapter 15, &quot;Objects and Arrays.&quot;</P>
<P><H3><FONT FACE="Courier New">fcmpg</H3></FONT> - Compare <FONT FACE="Courier New">float</FONT>s (1 on NaN)</P>
<P><H3>Opcode:</H3> 150 (0x96)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">fcmpg</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value1, value2</P></EM></H4>
<P>After:<I>..., result</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The top two words of the operand stack, <I>value1</I> and <I>value2</I>, must be two <FONT FACE="Courier New">float</FONT>s. To execute the <FONT FACE="Courier New">fcmpg</FONT> instruction, the Java Virtual Machine pops <I>value1</I> and <I>value2</I> off the operand stack and compares one against the other. If <I>value1</I> equals <I>value2</I>, the virtual machine pushes onto the operand stack <FONT FACE="Courier New">int</FONT> <I>result</I> zero. Else, if <I>value1</I> is greater than <I>value2</I>, the virtual machine pushes onto the operand stack <FONT FACE="Courier New">int</FONT> <I>result</I> one. Otherwise, if <I>value1</I> is less than <I>value2</I>, the virtual machine pushes onto the operand stack <FONT FACE="Courier New">int</FONT> <I>result</I> negative one. If either <I>value1</I> or <I>value2</I> equals NaN (Not a Number), the virtual machine pushes onto the operand stack <FONT FACE="Courier New">int</FONT> <I>result</I> one.</P>
<P>The <I>result</I> produced by the <FONT FACE="Courier New">fcmpg</FONT> instruction is governed by the rules of IEEE 754 floating point arithmetic. Note that the <FONT FACE="Courier New">fcmpg</FONT> instruction differs from the the <FONT FACE="Courier New">fcmpl</FONT> instruction only in its treatment of NaN. For more information about the <FONT FACE="Courier New">fcmpg</FONT> instruction, see Chapter 16, &quot;Control Flow.&quot;</P>
<P><H3><FONT FACE="Courier New">fcmpl</H3></FONT> - Compare <FONT FACE="Courier New">float</FONT>s (-1 on NaN)</P>
<P><H3>Opcode:</H3> 149 (0x95)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">fcmpl</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value1, value2</P></EM></H4>
<P>After:<I>..., result</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The top two words of the operand stack, <I>value1</I> and <I>value2</I>, must be two <FONT FACE="Courier New">float</FONT>s. To execute the <FONT FACE="Courier New">fcmpl</FONT> instruction, the Java Virtual Machine pops <I>value1</I> and <I>value2</I> off the operand stack and compares one against the other. If <I>value1</I> equals <I>value2</I>, the virtual machine pushes onto the operand stack <FONT FACE="Courier New">int</FONT> <I>result</I> zero. Else, if <I>value1</I> is greater than <I>value2</I>, the virtual machine pushes onto the operand stack <FONT FACE="Courier New">int</FONT> <I>result</I> one. Otherwise, if <I>value1</I> is less than <I>value2</I>, the virtual machine pushes onto the operand stack <FONT FACE="Courier New">int</FONT> <I>result</I> negative one. If either <I>value1</I> or <I>value2</I> equals NaN (Not a Number), the virtual machine pushes onto the operand stack <FONT FACE="Courier New">int</FONT> <I>result</I> negative one.</P>
<P>The <I>result</I> produced by the <FONT FACE="Courier New">fcmpl</FONT> instruction is governed by the rules of IEEE 754 floating point arithmetic. Note that the <FONT FACE="Courier New">fcmpl</FONT> instruction differs from the the <FONT FACE="Courier New">fcmpg</FONT> instruction only in its treatment of NaN. For more information about the <FONT FACE="Courier New">fcmpl</FONT> instruction, see Chapter 16, &quot;Control Flow.&quot;</P>
<P><H3><FONT FACE="Courier New">fconst_0</H3></FONT> - Push <FONT FACE="Courier New">float</FONT> constant 0.0</P>
<P><H3>Opcode:</H3> 11 (0xb)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">fconst_0</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>...</P></EM></H4>
<P>After:<I>..., &lt;0.0</FONT></P></EM></H4>
<P><H3>Description:</H3></P>
<P>To execute the <FONT FACE="Courier New">fconst_0</FONT> instruction, the Java Virtual Machine pushes the <FONT FACE="Courier New">float</FONT> constant 0.0 onto the operand stack.</P>
<P>For more information about the <FONT FACE="Courier New">fconst_0</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<P><H3><FONT FACE="Courier New">fconst_1</H3></FONT> - Push <FONT FACE="Courier New">float</FONT> constant 1.0</P>
<P><H3>Opcode:</H3> 12 (0xc)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">fconst_1</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>...</P></EM></H4>
<P>After:<I>..., &lt;1.0</FONT></P></EM></H4>
<P><H3>Description:</H3></P>
<P>To execute the <FONT FACE="Courier New">fconst_1</FONT> instruction, the Java Virtual Machine pushes the <FONT FACE="Courier New">float</FONT> constant 1.0 onto the operand stack.</P>
<P>For more information about the <FONT FACE="Courier New">fconst_1</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<P><H3><FONT FACE="Courier New">fconst_2</H3></FONT> - Push <FONT FACE="Courier New">float</FONT> constant 2.0</P>
<P><H3>Opcode:</H3> 13 (0xd)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">fconst_2</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>...</P></EM></H4>
<P>After:<I>..., &lt;2.0</FONT></P></EM></H4>
<P><H3>Description:</H3></P>
<P>To execute the <FONT FACE="Courier New">fconst_2</FONT> instruction, the Java Virtual Machine pushes the <FONT FACE="Courier New">float</FONT> constant 2.0 onto the operand stack.</P>
<P>For more information about the <FONT FACE="Courier New">fconst_2</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<P><H3><FONT FACE="Courier New">fdiv</H3></FONT> - Divide <FONT FACE="Courier New">float</FONT>s</P>
<P><H3>Opcode:</H3> 110 (0x6e)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">fdiv</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value1, value2</P></EM></H4>
<P>After:<I>..., result</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The top two words of the operand stack, <I>value1</I> and <I>value2</I>, must be <FONT FACE="Courier New">float</FONT>s. To execute the <FONT FACE="Courier New">fdiv</FONT> instruction, the Java Virtual Machine pops <I>value1</I> and <I>value2</I>, divides <I>value1</I> by <I>value2</I> (<I> value1 / value2</I>), and pushes the <FONT FACE="Courier New">float</FONT> <I>result</I>. The <I>result</I> produced by the <FONT FACE="Courier New">fdiv</FONT> instruction is governed by the rules of IEEE 754 floating point arithmetic.</P>
<P>For more information about the <FONT FACE="Courier New">fdiv</FONT> instruction, see Chapter 14, &quot;Floating Point Arithmetic.&quot;</P>
<P><H3><FONT FACE="Courier New">fload</H3></FONT> - Load <FONT FACE="Courier New">float</FONT> from local variable</P>
<P><H3>Opcode:</H3> 23 (0x17)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">fload</FONT>, <I>index</P></EM></H4>
<P><H3>Stack:</H3></P>
<P>Before:<I>...</P></EM></H4>
<P>After:<I>..., value</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The <I>index</I> operand, which serves as an 8-bit unsigned index into the local variables of the current frame, must specify a local variable word that contains an <FONT FACE="Courier New">float</FONT>. To execute the <FONT FACE="Courier New">fload</FONT> instruction, the Java Virtual Machine pushes onto the operand stack the <FONT FACE="Courier New">float</FONT> contained in the local variable word specified by <I>index</I>.</P>
<P>Note that the <FONT FACE="Courier New">wide</FONT> instruction can precede the <FONT FACE="Courier New">fload</FONT> instruction, to allow a local variable to be accessed with a 16-bit unsigned offset.</P>
<P>For more information about the <FONT FACE="Courier New">fload</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<P><H3><FONT FACE="Courier New">fload_0</H3></FONT> - Load <FONT FACE="Courier New">float</FONT> from local variable 0</P>
<P><H3>Opcode:</H3> 34 (0x22)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">fload_0</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>...</P></EM></H4>
<P>After:<I>..., value</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The local variable word at index zero must contain a <FONT FACE="Courier New">float</FONT>. To execute the <FONT FACE="Courier New">fload_0</FONT> instruction, the Java Virtual Machine pushes onto the operand stack the <FONT FACE="Courier New">float</FONT> <I>value</I> contained in local variable word zero.</P>
<P>For more information about the <FONT FACE="Courier New">fload_0</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<P><H3><FONT FACE="Courier New">fload_1</H3></FONT> - Load <FONT FACE="Courier New">float</FONT> from local variable 1</P>
<P><H3>Opcode:</H3> 35 (0x23)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">fload_1</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>...</P></EM></H4>
<P>After:<I>..., value</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The local variable word at index one must contain a <FONT FACE="Courier New">float</FONT>. To execute the <FONT FACE="Courier New">fload_1</FONT> instruction, the Java Virtual Machine pushes onto the operand stack the <FONT FACE="Courier New">float</FONT> <I>value</I> contained in local variable word one.</P>
<P>For more information about the <FONT FACE="Courier New">fload_1</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<P><H3><FONT FACE="Courier New">fload_2</H3></FONT> - Load <FONT FACE="Courier New">float</FONT> from local variable 2</P>
<P><H3>Opcode:</H3> 36 (0x24)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">fload_2</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>...</P></EM></H4>
<P>After:<I>..., value</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The local variable word at index two must contain a <FONT FACE="Courier New">float</FONT>. To execute the <FONT FACE="Courier New">fload_2</FONT> instruction, the Java Virtual Machine pushes onto the operand stack the <FONT FACE="Courier New">float</FONT> <I>value</I> contained in local variable word two.</P>
<P>For more information about the <FONT FACE="Courier New">fload_2</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<P><H3><FONT FACE="Courier New">fload_3</H3></FONT> - Load <FONT FACE="Courier New">float</FONT> from local variable 3</P>
<P><H3>Opcode:</H3> 37 (0x25)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">fload_3</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>...</P></EM></H4>
<P>After:<I>..., value</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The local variable word at index three must contain a <FONT FACE="Courier New">float</FONT>. To execute the <FONT FACE="Courier New">fload_3</FONT> instruction, the Java Virtual Machine pushes onto the operand stack the <FONT FACE="Courier New">float</FONT> <I>value</I> contained in local variable word three.</P>
<P>For more information about the <FONT FACE="Courier New">fload_3</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<P><H3><FONT FACE="Courier New">fmul</H3></FONT> - Multiply <FONT FACE="Courier New">float</FONT>s</P>
<P><H3>Opcode:</H3> 106 (0x6a)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">fmul</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value1, value2</P></EM></H4>
<P>After:<I>..., result</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The top two words of the operand stack, <I>value1</I> and <I>value2</I>, must be <FONT FACE="Courier New">float</FONT>s. To execute the <FONT FACE="Courier New">fmul</FONT> instruction, the Java Virtual Machine pops <I>value1</I> and <I>value2</I>, multiplies them, and pushes the <FONT FACE="Courier New">float</FONT> <I>result</I>. The <I>result</I> produced by the <FONT FACE="Courier New">fmul</FONT> instruction is governed by the rules of IEEE 754 floating point arithmetic.</P>
<P>For more information about the <FONT FACE="Courier New">fmul</FONT> instruction, see Chapter 14, &quot;Floating Point Arithmetic.&quot;</P>
<P><H3><FONT FACE="Courier New">fneg</H3></FONT> - Negate <FONT FACE="Courier New">float</FONT></P>
<P><H3>Opcode:</H3> 118 (0x76)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">fneg</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value</P></EM></H4>
<P>After:<I>..., result</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The top word of the operand stack, <I>value</I>, must be a <FONT FACE="Courier New">float</FONT>. To execute the <FONT FACE="Courier New">fneg</FONT> instruction, the Java Virtual Machine pops <I>value</I>, negates it, and pushes the <FONT FACE="Courier New">float</FONT> <I>result</I>. The <I>result</I> produced by the <FONT FACE="Courier New">fneg</FONT> instruction is governed by the rules of IEEE 754 floating point arithmetic.</P>
<P>Note that the <I>result</I> produced by an <FONT FACE="Courier New">fneg</FONT> instruction is not always the same as the number that would be produced by subtracting <I>value</I> from zero with the <FONT FACE="Courier New">fsub</FONT> instruction. The range of IEEE 754 floating point numbers includes two zeros, a positive zero and a negative zero. When <I>value</I> is +0.0, the <I>result</I> of the <FONT FACE="Courier New">fneg</FONT> instruction is -0.0. By contrast, when subtracting +0.0 from +0.0, the <FONT FACE="Courier New">fsub</FONT> instruction yields +0.0.</P>
<P>For more information about the <FONT FACE="Courier New">fneg</FONT> instruction, see Chapter 14, &quot;Floating Point Arithmetic.&quot;</P>
<P><H3><FONT FACE="Courier New">frem</H3></FONT> - Calculate remainder of division of <FONT FACE="Courier New">float</FONT>s</P>
<P><H3>Opcode:</H3> 114 (0x72)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">frem</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value1, value2</P></EM></H4>
<P>After:<I>..., result</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The top two words of the operand stack, <I>value1</I> and <I>value2</I>, must be <FONT FACE="Courier New">float</FONT>s. To execute the <FONT FACE="Courier New">frem</FONT> instruction, the Java Virtual Machine pops <I>value1</I> and <I>value2</I>, calculates the remainder, and pushes the <FONT FACE="Courier New">float</FONT> <I>result</I>. The remainder equals <I> value1 - (value1 / value2) * value2</I>, where <I>value1 / value2</I> is a truncating division, rather than the rounding division required by IEEE 754.</P>
<P>The behavior of <FONT FACE="Courier New">frem</FONT> is comparable to that of the C library function <FONT FACE="Courier New">fmod()</FONT>.The remainder of two <FONT FACE="Courier New">float</FONT>s can be calculated according to IEEE 754 floating point standard via the <FONT FACE="Courier New">IEEERemainder()</FONT> method of class <FONT FACE="Courier New">java.lang.Math</FONT>.</P>
<P>For more information about the <FONT FACE="Courier New">frem</FONT> instruction, see Chapter 14, &quot;Floating Point Arithmetic.&quot;</P>
<P><H3><FONT FACE="Courier New">freturn</H3></FONT> - Return <FONT FACE="Courier New">float</FONT> from method</P>
<P><H3>Opcode:</H3> 174 (0xae)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">freturn</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value</P></EM></H4>
<P>After:<I>[empty]</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The return type of the returning method must be <FONT FACE="Courier New">float</FONT>. The top word of the operand stack, <I>value</I>, must be a <FONT FACE="Courier New">float</FONT>. To execute the <FONT FACE="Courier New">freturn</FONT> instruction, the Java Virtual Machine pops <FONT FACE="Courier New">float</FONT> <I>value</I> from the operand stack of the current frame and pushes it onto the operand stack of the invoking methodís frame. The virtual machine discards any other words that may still be on the returning methodís frame. If the returning method is synchronized, the monitor that was acquired when the method was invoked is released. The invoking methodís frame is made current, and the virtual machine continues execution in the invoking method.</P>
<P>For more information about monitors, see Chapter 20, &quot;Thread Synchronization.&quot; For more information about the <FONT FACE="Courier New">freturn</FONT> instruction, see Chapter 19, &quot;Method Invocation and Return.&quot;</P>
<P><H3><FONT FACE="Courier New">fstore</H3></FONT> - Store <FONT FACE="Courier New">float</FONT> into local variable</P>
<P><H3>Opcode:</H3> 56 (0x38)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">fstore</FONT>, <I>index</P></EM></H4>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value</P></EM></H4>
<P>After:<I>...</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The <I>index</I> operand must specify a valid 8-bit unsigned index into the local variables of the current frame. The <I>value</I> on the top of the operand stack must be a <FONT FACE="Courier New">float</FONT>. To execute the <FONT FACE="Courier New">fstore</FONT> instruction, the Java Virtual Machine pops the <FONT FACE="Courier New">float</FONT> <I>value</I> from the top of the operand stack and stores it into the local variable word specified by <I>index</I>.</P>
<P>Note that the <FONT FACE="Courier New">wide</FONT> instruction can precede the <FONT FACE="Courier New">fstore</FONT> instruction, to enable a <I>value</I> to be stored into a local variable specified by a 16-bit unsigned offset.</P>
<P>For more information about the <FONT FACE="Courier New">fstore</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<P><H3><FONT FACE="Courier New">fstore_0</H3></FONT> - Store <FONT FACE="Courier New">float</FONT> into local variable 0</P>
<P><H3>Opcode:</H3> 67 (0x43)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">fstore_0</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value</P></EM></H4>
<P>After:<I>...</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The index zero must be a valid index into the local variables of the current stack frame, and the <I>value</I> word on the top of the operand stack must be a <FONT FACE="Courier New">float</FONT>. To execute the <FONT FACE="Courier New">fstore_0</FONT> instruction, the Java Virtual Machine pops the <FONT FACE="Courier New">float</FONT> <I>value</I> from the top of the operand stack and stores it into the local variable word at index zero.</P>
<P>For more information about the <FONT FACE="Courier New">fstore_0</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<P><H3><FONT FACE="Courier New">fstore_1</H3></FONT> - Store <FONT FACE="Courier New">float</FONT> into local variable 1</P>
<P><H3>Opcode:</H3> 68 (0x44)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">fstore_1</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value</P></EM></H4>
<P>After:<I>...</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The index one must be a valid index into the local variables of the current stack frame, and the <I>value</I> word on the top of the operand stack must be a <FONT FACE="Courier New">float</FONT>. To execute the <FONT FACE="Courier New">fstore_1</FONT> instruction, the Java Virtual Machine pops the <FONT FACE="Courier New">float</FONT> <I>value</I> from the top of the operand stack and stores it into the local variable word at index one.</P>
<P>For more information about the <FONT FACE="Courier New">fstore_1</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<P><H3><FONT FACE="Courier New">fstore_2</H3></FONT> - Store <FONT FACE="Courier New">float</FONT> into local variable 2</P>
<P><H3>Opcode:</H3> 69 (0x45)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">fstore_2</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value</P></EM></H4>
<P>After:<I>...</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The index two must be a valid index into the local variables of the current stack frame, and the <I>value</I> word on the top of the operand stack must be a <FONT FACE="Courier New">float</FONT>. To execute the <FONT FACE="Courier New">fstore_2</FONT> instruction, the Java Virtual Machine pops the <FONT FACE="Courier New">float</FONT> <I>value</I> from the top of the operand stack and stores it into the local variable word at index two.</P>
<P>For more information about the <FONT FACE="Courier New">fstore_2</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<P><H3><FONT FACE="Courier New">fstore_3</H3></FONT> - Store <FONT FACE="Courier New">float</FONT> into local variable 3</P>
<P><H3>Opcode:</H3> 70 (0x46)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">fstore_3</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value</P></EM></H4>
<P>After:<I>...</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The index three must be a valid index into the local variables of the current stack frame, and the <I>value</I> word on the top of the operand stack must be a <FONT FACE="Courier New">float</FONT>. To execute the <FONT FACE="Courier New">fstore_3</FONT> instruction, the Java Virtual Machine pops the <FONT FACE="Courier New">float</FONT> <I>value</I> from the top of the operand stack and stores it into the local variable word at index three.</P>
<P>For more information about the <FONT FACE="Courier New">fstore_3</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<P><H3><FONT FACE="Courier New">fsub</H3></FONT> - Subtract <FONT FACE="Courier New">float</FONT>s</P>
<P><H3>Opcode:</H3> 102 (0x66)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">fsub</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value1, value2</P></EM></H4>
<P>After:<I>..., result</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The top two words of the operand stack, <I>value1</I> and <I>value2</I>, must be <FONT FACE="Courier New">float</FONT>s. To execute the <FONT FACE="Courier New">fsub</FONT> instruction, the Java Virtual Machine pops <I>value1</I> and <I>value2</I>, subtracts <I>value2</I> from <I>value1</I> (<I> value1 - value2</I>), and pushes the <FONT FACE="Courier New">float</FONT> <I>result</I>. The <I>result</I> produced by the <FONT FACE="Courier New">fsub</FONT> instruction is governed by the rules of IEEE 754 floating point arithmetic.</P>
<P>For more information about the <FONT FACE="Courier New">fsub</FONT> instruction, see Chapter 14, &quot;Floating Point Arithmetic.&quot;</P>
<P><H3><FONT FACE="Courier New">getfield</H3></FONT> - Fetch field from object</P>
<P><H3>Opcode:</H3> 180 (0xb4)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">getfield</FONT>, <I>indexbyte1</I>, <I>indexbyte2</P></EM></H4>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., objectref</P></EM></H4>
<P>After:<I>..., value</P></EM></H4>
<P>or</P>
<P>Before:<I>..., objectref</P></EM></H4>
<P>After:<I>..., value.word1, value.word2</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The top word of the stack, <I>objectref</I>, must be a <FONT FACE="Courier New">reference</FONT>. To execute the <FONT FACE="Courier New">getfield</FONT> instruction, the Java Virtual Machine first forms an unsigned 16-bit index into the constant pool by calculating <I>(indexbyte1 <FONT FACE="Courier New"> 8) | indexbyte2</I>. </I>The virtual machine then looks up the constant pool entry specified by the calculated index. The constant pool entry at that index must be a <FONT FACE="Courier New">CONSTANT_Fieldref_info</FONT> entry. If it hasnít already, the virtual machine resolves the entry, which yields the fieldís width and the fieldís offset from the beginning of the object image. If the resolution is successful, the virtual machine pops the <I>objectref</I> and fetches the field from the object pointed to by <I>objectref</I>. If the type of the field is <FONT FACE="Courier New">byte</FONT>, <FONT FACE="Courier New">short</FONT>, or <FONT FACE="Courier New">char</FONT>, the virtual machine sign-extends the fieldís value to an <FONT FACE="Courier New">int</FONT> and pushes the single-word <FONT FACE="Courier New">int</FONT> <I>value</I> onto the operand stack. Else, if the type is <FONT FACE="Courier New">int</FONT>, <FONT FACE="Courier New">boolean</FONT>, <FONT FACE="Courier New">float</FONT>, or <FONT FACE="Courier New">reference</FONT>, the virtual machine pushes the single-word <I>value</I> onto the operand stack. Otherwise, the type is <FONT FACE="Courier New">long</FONT> or <FONT FACE="Courier New">double</FONT>, and the virtual machine pushes the dual-word <I>value</I> onto the operand stack.</P>
<P>As a result of executing this instruction, the virtual machine may throw any of the linking errors listed in Chapter 8, &quot;The Linking Model,&quot; as possible during resolution of a <FONT FACE="Courier New">CONSTANT_Fieldref_info</FONT> entry. As part of the process of resolving the <FONT FACE="Courier New">CONSTANT_Fieldref_info</FONT> entry, the virtual machine checks whether the fieldís access permission enables the current class to access the field. If the field is protected, the virtual machine makes certain the field is a member of the either the current class or a superclass of the current class, and that the class of the object pointed to by <I>objectref</I> is either the current class or a subclass of the current class. If not (or if there is any other access permission problem), the virtual machine throws <FONT FACE="Courier New">IllegalAccessError</FONT>. Else, if the field exists and is accessible from the current class, but the field is static, the virtual machine throws <FONT FACE="Courier New">IncompatibleClassChangeError</FONT>. Otherwise, if <I>objectref</I> is <FONT FACE="Courier New">null</FONT>, the virtual machine throws <FONT FACE="Courier New">NullPointerException</FONT>.</P>
<P>For more information about the <FONT FACE="Courier New">getfield</FONT> instruction, see Chapter 15, &quot;Objects and Arrays.&quot;</P>
<P><H3><FONT FACE="Courier New">getstatic</H3></FONT> - Fetch static field from class</P>
<P><H3>Opcode:</H3> 178 (0xb2)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">getstatic</FONT>, <I>indexbyte1</I>, <I>indexbyte2</P></EM></H4>
<P><H3>Stack:</H3></P>
<P>Before:<I>...</P></EM></H4>
<P>After:<I>..., value</P></EM></H4>
<P>or</P>
<P>Before:<I>...</P></EM></H4>
<P>After:<I>..., value.word1, value.word2</P></EM></H4>
<P><H3>Description:</H3></P>
<P>To execute the <FONT FACE="Courier New">getstatic</FONT> instruction, the Java Virtual Machine first forms an unsigned 16-bit index into the constant pool by calculating <I>(indexbyte1 <FONT FACE="Courier New"> 8) | indexbyte2</I>. </I>The virtual machine then looks up the constant pool entry specified by the calculated index. The constant pool entry at that index must be a <FONT FACE="Courier New">CONSTANT_Fieldref_info</FONT> entry. If it hasnít already, the virtual machine resolves the entry. If the resolution is successful, the virtual machine fetches the value of the static field. If the type of the field is <FONT FACE="Courier New">byte</FONT>, <FONT FACE="Courier New">short</FONT>, or <FONT FACE="Courier New">char</FONT>, the virtual machine sign-extends the fieldís value to <FONT FACE="Courier New">int</FONT> and pushes the single-word <FONT FACE="Courier New">int</FONT> <I>value</I> onto the operand stack. Else, if the type is <FONT FACE="Courier New">int</FONT>, <FONT FACE="Courier New">boolean</FONT>, <FONT FACE="Courier New">float</FONT>, or <FONT FACE="Courier New">reference</FONT> the virtual machine pushes the single-word <I>value</I> onto the operand stack. Otherwise, the type is <FONT FACE="Courier New">long</FONT> or <FONT FACE="Courier New">double</FONT>, and the virtual machine pushes the dual-word <I>value</I> onto the operand stack.</P>
<P>As a result of executing this instruction, the virtual machine may throw any of the linking errors listed in Chapter 8, &quot;The Linking Model,&quot; as possible during resolution of a <FONT FACE="Courier New">CONSTANT_Fieldref_info</FONT> entry. As part of the process of resolving the <FONT FACE="Courier New">CONSTANT_Fieldref_info</FONT> entry, the virtual machine checks whether the fieldís access permission enables the current class to access the field. If the field is protected, the virtual machine makes certain the field is a member of the either the current class or a superclass of the current class. If not (or if there is any other access permission problem), the virtual machine throws <FONT FACE="Courier New">IllegalAccessError</FONT>. Else, if the field exists and is accessible from the current class, but the field is not static, the virtual machine throws <FONT FACE="Courier New">IncompatibleClassChangeError</FONT>. </P>
<P>For more information about the <FONT FACE="Courier New">getstatic</FONT> instruction, see Chapter 15, &quot;Objects and Arrays.&quot;</P>
<P><H3><FONT FACE="Courier New">goto</H3></FONT> - Branch always</P>
<P><H3>Opcode:</H3> 167 (0xa7)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">goto</FONT>, <I>branchbyte1</I>, <I>branchbyte2</P></EM></H4>
<P><H3>Stack:</H3></P>
<P>No change</P>
<P><H3>Description:</H3></P>
<P>To execute the <FONT FACE="Courier New">goto</FONT> instruction, the Java Virtual Machine forms a signed 16-bit offset by calculating <I>(branchbyte1 <FONT FACE="Courier New"> 8) | branchbyte2</I>. </I>The virtual machine then calculates a target (program counter) address by adding the calculated offset to the address of the <FONT FACE="Courier New">goto</FONT> opcode. The target address must be the address of an opcode within the same method as the <FONT FACE="Courier New">goto</FONT> opcode. </I>The virtual machine jumps to the target address and continues execution there.</P>
<P>For more information about the <FONT FACE="Courier New">goto</FONT> instruction, see Chapter 16, &quot;Control Flow.&quot;</P>
<P><H3><FONT FACE="Courier New">goto_w</H3></FONT> - Branch always (wide index)</P>
<P><H3>Opcode:</H3> 200 (0xc8)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">goto_w = 200</FONT>, <I>branchbyte1</I>, <I>branchbyte2</I>, <I>branchbyte3</I>, <I>branchbyte4</P></EM></H4>
<P><H3>Stack:</H3></P>
<P>No change</P>
<P><H3>Description:</H3></P>
<P>To execute the <FONT FACE="Courier New">goto_w</FONT> instruction, the Java Virtual Machine forms a signed 32-bit offset by calculating <I>(branchbyte1 <FONT FACE="Courier New"> 24) | (branchbyte2 <FONT FACE="Courier New"> 16) | (branchbyte3 </FONT><FONT FACE="Courier New"> 8) | branchbyte4</FONT></I>. </I>The virtual machine then calculates a target (program counter) address by adding the calculated offset to the address of the <FONT FACE="Courier New">goto_w</FONT> opcode. The target address must be the address of an opcode within the same method as the <FONT FACE="Courier New">goto_w</FONT> opcode. </I>The virtual machine jumps to the target address and continues execution there.</P>
<P>Note that despite the 32-bit offset of the <FONT FACE="Courier New">goto_w</FONT> instruction, Java methods are currently (in both the 1.0 and 1.1 releases) limited to 65,535 bytes by three items in the Java class file format: the sizes of the indexes in the <FONT FACE="Courier New">LineNumberTable</FONT> attribute, the <FONT FACE="Courier New">LocalVariableTable</FONT> attribute, and the <FONT FACE="Courier New">Code</FONT> attributeís <FONT FACE="Courier New">exception_table</FONT> item. According to the Java Virtual Machine specification, the 65,536 byte limit to Java methods may be raised in a future release. For more information about the <FONT FACE="Courier New">goto_w</FONT> instruction, see Chapter 16, &quot;Control Flow.&quot;</P>
<P><H3><FONT FACE="Courier New">i2b</H3></FONT> - Convert <FONT FACE="Courier New">int</FONT> to <FONT FACE="Courier New">byte</FONT></P>
<P><H3>Opcode:</H3> 145 (0x91)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">i2b</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value</P></EM></H4>
<P>After:<I>..., result</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The top word of the operand stack, <I>value</I>, must be an <FONT FACE="Courier New">int</FONT>. To execute the <FONT FACE="Courier New">i2b</FONT> instruction, the Java Virtual Machine pops <FONT FACE="Courier New">int</FONT> <I>value</I> from the operand stack, truncates the <FONT FACE="Courier New">int</FONT> to a <FONT FACE="Courier New">byte</FONT>, sign-extends the result back to an <FONT FACE="Courier New">int</FONT>, and pushes the <FONT FACE="Courier New">int</FONT> <I>result</I>.</P>
<P>Note that this instruction performs a narrowing primitive conversion. As a result of this conversion, magnitude information may be lost and the sign bit may change.</P>
<P>For more information about the <FONT FACE="Courier New">i2b</FONT> instruction, see Chapter 11, &quot;Type Conversion.&quot;</P>
<P><H3><FONT FACE="Courier New">i2c</H3></FONT> - Convert <FONT FACE="Courier New">int</FONT> to <FONT FACE="Courier New">char</FONT></P>
<P><H3>Opcode:</H3> 146 (0x92)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">i2c</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value</P></EM></H4>
<P>After:<I>..., result</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The top word of the operand stack, <I>value</I>, must be an <FONT FACE="Courier New">int</FONT>. To execute the <FONT FACE="Courier New">i2c</FONT> instruction, the Java Virtual Machine pops <FONT FACE="Courier New">int</FONT> <I>value</I> from the operand stack, truncates the <FONT FACE="Courier New">int</FONT> to a <FONT FACE="Courier New">char</FONT>, zero-extends the result back to an <FONT FACE="Courier New">int</FONT>, and pushes the <FONT FACE="Courier New">int</FONT> <I>result</I>.</P>
<P>Note that this instruction performs a narrowing primitive conversion. As a result of this conversion, magnitude information may be lost and, as the <I>result</I> is always positive, the sign bit may change.</P>
<P>For more information about the <FONT FACE="Courier New">i2c</FONT> instruction, see Chapter 11, &quot;Type Conversion.&quot;</P>
<P><H3><FONT FACE="Courier New">i2d</H3></FONT> - Convert <FONT FACE="Courier New">int</FONT> to <FONT FACE="Courier New">double</FONT></P>
<P><H3>Opcode:</H3> 135 (0x87)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">i2d</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value</P></EM></H4>
<P>After:<I>..., result.word1, result.word2</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The top word of the operand stack, <I>value</I>, must be an <FONT FACE="Courier New">int</FONT>. To execute the <FONT FACE="Courier New">i2d</FONT> instruction, the Java Virtual Machine pops <FONT FACE="Courier New">int</FONT> <I>value</I> from the operand stack, sign-extends the <FONT FACE="Courier New">int</FONT> to a <FONT FACE="Courier New">double</FONT>, and pushes the <FONT FACE="Courier New">double</FONT> <I>result</I>.</P>
<P>Note that this instruction performs a widening primitive conversion. Because all <FONT FACE="Courier New">int</FONT> values are representable by a <FONT FACE="Courier New">double</FONT>, the conversion is exact.</P>
<P>For more information about the <FONT FACE="Courier New">i2d</FONT> instruction, see Chapter 11, &quot;Type Conversion.&quot;</P>
<P><H3><FONT FACE="Courier New">i2f</H3></FONT> - Convert <FONT FACE="Courier New">int</FONT> to <FONT FACE="Courier New">float</FONT></P>
<P><H3>Opcode:</H3> 134 (0x86)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">i2f</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value</P></EM></H4>
<P>After:<I>..., result</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The top word of the operand stack, <I>value</I>, must be an <FONT FACE="Courier New">int</FONT>. To execute the <FONT FACE="Courier New">i2f</FONT> instruction, the Java Virtual Machine pops <FONT FACE="Courier New">int</FONT> <I>value</I> from the operand stack, converts the <FONT FACE="Courier New">int</FONT> to a <FONT FACE="Courier New">float</FONT> using the IEEE round-to-nearest mode, and pushes the <FONT FACE="Courier New">float</FONT> <I>result</I>.</P>
<P>Note that this instruction performs a widening primitive conversion. Because not all <FONT FACE="Courier New">int</FONT> values are exactly representable by a <FONT FACE="Courier New">float</FONT>, the conversion may result in a loss of precision.</P>
<P>For more information about the <FONT FACE="Courier New">i2f</FONT> instruction, see Chapter 11, &quot;Type Conversion.&quot;</P>
<P><H3><FONT FACE="Courier New">i2l</H3></FONT> - Convert <FONT FACE="Courier New">int</FONT> to <FONT FACE="Courier New">long</FONT></P>
<P><H3>Opcode:</H3> 133 (0x85)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">i2l</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value</P></EM></H4>
<P>After:<I>..., result.word1, result.word2</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The top word of the operand stack, <I>value</I>, must be an <FONT FACE="Courier New">int</FONT>. To execute the <FONT FACE="Courier New">i2l</FONT> instruction, the Java Virtual Machine pops <FONT FACE="Courier New">int</FONT> <I>value</I> from the operand stack, sign-extends the <FONT FACE="Courier New">int</FONT> to a <FONT FACE="Courier New">long</FONT>, and pushes the <FONT FACE="Courier New">long</FONT> <I>result</I>.</P>
<P>Note that this instruction performs a widening primitive conversion. Because all <FONT FACE="Courier New">int</FONT> values are representable by a <FONT FACE="Courier New">long</FONT>, the conversion is exact.</P>
<P>For more information about the <FONT FACE="Courier New">i2l</FONT> instruction, see Chapter 11, &quot;Type Conversion.&quot;</P>
<P><H3><FONT FACE="Courier New">i2s</H3></FONT> - Convert <FONT FACE="Courier New">int</FONT> to <FONT FACE="Courier New">short</FONT></P>
<P><H3>Opcode:</H3> 147 (0x93)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">i2s</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value</P></EM></H4>
<P>After:<I>..., result</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The top word of the operand stack, <I>value</I>, must be an <FONT FACE="Courier New">int</FONT>. To execute the <FONT FACE="Courier New">i2s</FONT> instruction, the Java Virtual Machine pops <FONT FACE="Courier New">int</FONT> <I>value</I> from the operand stack, truncates the <FONT FACE="Courier New">int</FONT> to a <FONT FACE="Courier New">short</FONT>, sign-extends the result back to an <FONT FACE="Courier New">int</FONT>, and pushes the <FONT FACE="Courier New">int</FONT> <I>result</I>.</P>
<P>Note that this instruction performs a narrowing primitive conversion. As a result of this conversion, magnitude information may be lost and the sign bit may change.</P>
<P>For more information about the <FONT FACE="Courier New">i2s</FONT> instruction, see Chapter 11, &quot;Type Conversion.&quot;</P>
<P><H3><FONT FACE="Courier New">iadd</H3></FONT> - Add <FONT FACE="Courier New">int</FONT>s</P>
<P><H3>Opcode:</H3> 96 (0x60)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">iadd</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value1, value2</P></EM></H4>
<P>After:<I>..., result</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The top two words of the operand stack, <I>value1</I> and <I>value2</I>, must be <FONT FACE="Courier New">int</FONT>s. To execute the <FONT FACE="Courier New">iadd</FONT> instruction, the Java Virtual Machine pops <I>value1</I> and <I>value2</I>, adds them, and pushes the <FONT FACE="Courier New">int</FONT> <I>result</I>. If overflow occurs, <I>result</I> is the 32 lowest order bits of the true mathematical result represented in a sufficiently wide twoís-complement format, and the sign of <I>result</I> is different from that of the true mathematical result.</P>
<P>For more information about the <FONT FACE="Courier New">iadd</FONT> instruction, see Chapter 12, &quot;Integer Arithmetic.&quot;</P>
<P><H3><FONT FACE="Courier New">iaload</H3></FONT> - Load <FONT FACE="Courier New">int</FONT> from array</P>
<P><H3>Opcode:</H3> 46 (0x2e)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">iaload</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., arrayref, index</P></EM></H4>
<P>After:<I>..., value</P></EM></H4>
<P><H3>Description:</H3></P>
<P>To execute the <FONT FACE="Courier New">iaload</FONT> instruction, the Java Virtual Machine first pops two words from the operand stack. The <I>arrayref</I> word must be a <FONT FACE="Courier New">reference</FONT> that refers to an array of <FONT FACE="Courier New">int</FONT>s. The <I>index</I> word must be an <FONT FACE="Courier New">int</FONT>. </I>The virtual machine retrieves from the <I>arrayref</I> array the <FONT FACE="Courier New">int</FONT> <I>value</I> specified by <I>index</I> and pushes it onto the operand stack.</P>
<P>If <I>arrayref</I> is <FONT FACE="Courier New">null</FONT>, the Java Virtual Machine throws <FONT FACE="Courier New">NullPointerException</FONT>. Otherwise, if <I>index</I> is not a legal index into the <I>arrayref</I> array, </I>The virtual machine throws <FONT FACE="Courier New">ArrayIndexOutOfBoundsException</FONT>.</P>
<P>For more information about the <FONT FACE="Courier New">iaload</FONT> instruction, see Chapter 15, &quot;Objects and Arrays.&quot;</P>
<P><H3><FONT FACE="Courier New">iand</H3></FONT> - Perform boolean AND on <FONT FACE="Courier New">int</FONT>s</P>
<P><H3>Opcode:</H3> 126 (0x7e)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">iand</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value1, value2</P></EM></H4>
<P>After:<I>..., result</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The top two words of the operand stack, <I>value1</I> and <I>value2</I>, must be <FONT FACE="Courier New">int</FONT>s. To execute the <FONT FACE="Courier New">iand</FONT> instruction, the Java Virtual Machine pops <I>value1</I> and <I>value2</I>, bitwise ANDs them, and pushes the <FONT FACE="Courier New">int</FONT> <I>result</I>.</P>
<P>For more information about the <FONT FACE="Courier New">iand</FONT> instruction, see Chapter 13, &quot;Logic.&quot;</P>
<P><H3><FONT FACE="Courier New">iastore</H3></FONT> - Store into <FONT FACE="Courier New">int</FONT> array</P>
<P><H3>Opcode:</H3> 79 (0x4f)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">iastore</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., arrayref, index, value</P></EM></H4>
<P>After:<I>...</P></EM></H4>
<P><H3>Description:</H3></P>
<P>To execute the <FONT FACE="Courier New">iastore</FONT> instruction, the Java Virtual Machine first pops three words from the operand stack. The <I>arrayref</I> word must be a <FONT FACE="Courier New">reference</FONT> that refers to an array of <FONT FACE="Courier New">int</FONT>s. The <I>index</I> and <I>value</I> words must be <FONT FACE="Courier New">int</FONT>s. </I>The virtual machine stores <FONT FACE="Courier New">int</FONT> <I>value</I> into the <I>arrayref</I> array location specified by <I>index</I>.</P>
<P>If <I>arrayref</I> is <FONT FACE="Courier New">null</FONT>, the Java Virtual Machine throws <FONT FACE="Courier New">NullPointerException</FONT>. Otherwise, if <I>index</I> is not a legal index into the <I>arrayref</I> array, </I>The virtual machine throws <FONT FACE="Courier New">ArrayIndexOutOfBoundsException</FONT>.</P>
<P>For more information about the <FONT FACE="Courier New">iastore</FONT> instruction, see Chapter 15, &quot;Objects and Arrays.&quot;</P>
<P><H3><FONT FACE="Courier New">iconst_0</H3></FONT> - Push <FONT FACE="Courier New">int</FONT> constant 0</P>
<P><H3>Opcode:</H3> 3 (0x3)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">iconst_0</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>...</P></EM></H4>
<P>After:<I>..., 0</P></EM></H4>
<P><H3>Description:</H3></P>
<P>To execute the <FONT FACE="Courier New">iconst_0</FONT> instruction, the Java Virtual Machine pushes the <FONT FACE="Courier New">int</FONT> constant 0 onto the operand stack.</P>
<P>For more information about the <FONT FACE="Courier New">iconst_0</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<P><H3><FONT FACE="Courier New">iconst_1</H3></FONT> - Push <FONT FACE="Courier New">int</FONT> constant 1</P>
<P><H3>Opcode:</H3> 4 (0x4)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">iconst_1</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>...</P></EM></H4>
<P>After:<I>..., 1</P></EM></H4>
<P><H3>Description:</H3></P>
<P>To execute the <FONT FACE="Courier New">iconst_1</FONT> instruction, the Java Virtual Machine pushes the <FONT FACE="Courier New">int</FONT> constant 1 onto the operand stack.</P>
<P>For more information about the <FONT FACE="Courier New">iconst_1</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<P><H3><FONT FACE="Courier New">iconst_2</H3></FONT> - Push <FONT FACE="Courier New">int</FONT> constant 2</P>
<P><H3>Opcode:</H3> 5 (0x5)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">iconst_2</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>...</P></EM></H4>
<P>After:<I>..., 2</P></EM></H4>
<P><H3>Description:</H3></P>
<P>To execute the <FONT FACE="Courier New">iconst_2</FONT> instruction, the Java Virtual Machine pushes the <FONT FACE="Courier New">int</FONT> constant 2 onto the operand stack.</P>
<P>For more information about the <FONT FACE="Courier New">iconst_2</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<P><H3><FONT FACE="Courier New">iconst_3</H3></FONT> - Push <FONT FACE="Courier New">int</FONT> constant 3</P>
<P><H3>Opcode:</H3> 6 (0x6)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">iconst_3</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>...</P></EM></H4>
<P>After:<I>..., 3</P></EM></H4>
<P><H3>Description:</H3></P>
<P>To execute the <FONT FACE="Courier New">iconst_3</FONT> instruction, the Java Virtual Machine pushes the <FONT FACE="Courier New">int</FONT> constant 3 onto the operand stack.</P>
<P>For more information about the <FONT FACE="Courier New">iconst_3</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<P><H3><FONT FACE="Courier New">iconst_4</H3></FONT> - Push <FONT FACE="Courier New">int</FONT> constant 4</P>
<P><H3>Opcode:</H3> 7 (0x7)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">iconst_4</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>...</P></EM></H4>
<P>After:<I>..., 4</P></EM></H4>
<P><H3>Description:</H3></P>
<P>To execute the <FONT FACE="Courier New">iconst_4</FONT> instruction, the Java Virtual Machine pushes the <FONT FACE="Courier New">int</FONT> constant 4 onto the operand stack.</P>
<P>For more information about the <FONT FACE="Courier New">iconst_4</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<P><H3><FONT FACE="Courier New">iconst_5</H3></FONT> - Push <FONT FACE="Courier New">int</FONT> constant 5</P>
<P><H3>Opcode:</H3> 8 (0x8)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">iconst_5</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>...</P></EM></H4>
<P>After:<I>..., 5</P></EM></H4>
<P><H3>Description:</H3></P>
<P>To execute the <FONT FACE="Courier New">iconst_5</FONT> instruction, the Java Virtual Machine pushes the <FONT FACE="Courier New">int</FONT> constant 5 onto the operand stack.</P>
<P>For more information about the <FONT FACE="Courier New">iconst_5</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<P><H3><FONT FACE="Courier New">iconst_m1</H3></FONT> - Push <FONT FACE="Courier New">int</FONT> constant -1</P>
<P><H3>Opcode:</H3> 2 (0x2)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">iconst_m1</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>...</P></EM></H4>
<P>After:<I>..., -1</P></EM></H4>
<P><H3>Description:</H3></P>
<P>To execute the <FONT FACE="Courier New">iconst_m1</FONT> instruction, the Java Virtual Machine pushes the <FONT FACE="Courier New">int</FONT> constant -1 onto the operand stack.</P>
<P>For more information about the <FONT FACE="Courier New">iconst_m1</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<P><H3><FONT FACE="Courier New">idiv</H3></FONT> - Divide <FONT FACE="Courier New">int</FONT>s</P>
<P><H3>Opcode:</H3> 108 (0x6c)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">idiv</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value1, value2</P></EM></H4>
<P>After:<I>..., result</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The top two words of the operand stack, <I>value1</I> and <I>value2</I>, must be <FONT FACE="Courier New">int</FONT>s. To execute the <FONT FACE="Courier New">idiv</FONT> instruction, the Java Virtual Machine pops <I>value1</I> and <I>value2</I>, integer divides <I>value1</I> by <I>value2</I> (<I> value1 / value2</I>), and pushes the <FONT FACE="Courier New">int</FONT> <I>result</I>.</P>
<P>Integer division rounds the magnitude of the true mathematical quotient towards zero to the nearest integer. If the magnitude of the denominator is greater than that of the numerator, the <FONT FACE="Courier New">int</FONT> <I>result</I> is zero. Else, with one special exception, the sign of <I>result</I> is positive if the signs of the numerator and denominator are the same, negative if they are different. The exception to this rule is when the numerator is the smallest negative integer that can be represented by an <FONT FACE="Courier New">int</FONT> and the denominator is -1. For this division, the true mathematical result is one greater than the largest positive integer that can be represented by an <FONT FACE="Courier New">int</FONT>. As a consequence, the division overflows and the result is equal to the numerator.</P>
<P>If <I>value2</I> (the denominator) is zero, the Java Virtual Machine throws <FONT FACE="Courier New">ArithmeticException</FONT>.</P>
<P>For more information about the <FONT FACE="Courier New">idiv</FONT> instruction, see Chapter 12, &quot;Integer Arithmetic.&quot;</P>
<P><H3><FONT FACE="Courier New">ifeq</H3></FONT> - Branch if equal to 0</P>
<P><H3>Opcode:</H3> 153 (0x99)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">ifeq</FONT>, <I>branchbyte1</I>, <I>branchbyte2</P></EM></H4>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value</P></EM></H4>
<P>After:<I>...</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The top word of the operand stack, <I>value</I>, must be an <FONT FACE="Courier New">int</FONT>. To execute the <FONT FACE="Courier New">ifeq</FONT> instruction, the Java Virtual Machine pops <I>value</I> off the operand stack and compares it against zero. If <I>value</I> equals zero, </I>The virtual machine forms a signed 16-bit offset by calculating <I>(branchbyte1 <FONT FACE="Courier New"> 8) | branchbyte2</I>. </I>The virtual machine then calculates a target (program counter) address by adding the calculated offset to the address of the <FONT FACE="Courier New">ifeq</FONT> opcode. The target address must be the address of an opcode within the same method as the <FONT FACE="Courier New">ifeq</FONT> opcode. </I>The virtual machine jumps to the target address and continues execution there. Otherwise, if <I>value</I> does not equal zero, </I>The virtual machine does not take the jump. It simply continues execution at the instruction immediately following the <FONT FACE="Courier New">ifeq</FONT> instruction.</P>
<P>For more information about the <FONT FACE="Courier New">ifeq</FONT> instruction, see Chapter 16, &quot;Control Flow.&quot;</P>
<P><H3><FONT FACE="Courier New">ifge</H3></FONT> - Branch if greater than or equal to 0</P>
<P><H3>Opcode:</H3> 156 (0x9c)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">ifge</FONT>, <I>branchbyte1</I>, <I>branchbyte2</P></EM></H4>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value</P></EM></H4>
<P>After:<I>...</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The top word of the operand stack, <I>value</I>, must be an <FONT FACE="Courier New">int</FONT>. To execute the <FONT FACE="Courier New">ifge</FONT> instruction, the Java Virtual Machine pops <I>value</I> off the operand stack and compares it against zero. If <I>value</I> is greater than or equal to zero, </I>The virtual machine forms a signed 16-bit offset by calculating <I>(branchbyte1 <FONT FACE="Courier New"> 8) | branchbyte2</I>. </I>The virtual machine then calculates a target (program counter) address by adding the calculated offset to the address of the <FONT FACE="Courier New">ifge</FONT> opcode. The target address must be the address of an opcode within the same method as the <FONT FACE="Courier New">ifge</FONT> opcode. </I>The virtual machine jumps to the target address and continues execution there. Otherwise, if <I>value</I> is not greater than or equal to zero, </I>The virtual machine does not take the jump. It simply continues execution at the instruction immediately following the <FONT FACE="Courier New">ifge</FONT> instruction.</P>
<P>For more information about the <FONT FACE="Courier New">ifge</FONT> instruction, see Chapter 16, &quot;Control Flow.&quot;</P>
<P><H3><FONT FACE="Courier New">ifgt</H3></FONT> - Branch if greater than 0</P>
<P><H3>Opcode:</H3> 157 (0x9d)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">ifgt</FONT>, <I>branchbyte1</I>, <I>branchbyte2</P></EM></H4>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value</P></EM></H4>
<P>After:<I>...</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The top word of the operand stack, <I>value</I>, must be an <FONT FACE="Courier New">int</FONT>. To execute the <FONT FACE="Courier New">ifgt</FONT> instruction, the Java Virtual Machine pops <I>value</I> off the operand stack and compares it against zero. If <I>value</I> is greater than zero, </I>The virtual machine forms a signed 16-bit offset by calculating <I>(branchbyte1 <FONT FACE="Courier New"> 8) | branchbyte2</I>. </I>The virtual machine then calculates a target (program counter) address by adding the calculated offset to the address of the <FONT FACE="Courier New">ifgt</FONT> opcode. The target address must be the address of an opcode within the same method as the <FONT FACE="Courier New">ifgt</FONT> opcode. </I>The virtual machine jumps to the target address and continues execution there. Otherwise, if <I>value</I> is not greater than zero, </I>The virtual machine does not take the jump. It simply continues execution at the instruction immediately following the <FONT FACE="Courier New">ifgt</FONT> instruction.</P>
<P>For more information about the <FONT FACE="Courier New">ifgt</FONT> instruction, see Chapter 16, &quot;Control Flow.&quot;</P>
<P><H3><FONT FACE="Courier New">ifle</H3></FONT> - Branch if less than or equal to 0</P>
<P><H3>Opcode:</H3> 158 (0x9e)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">ifle</FONT>, <I>branchbyte1</I>, <I>branchbyte2</P></EM></H4>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value</P></EM></H4>
<P>After:<I>...</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The top word of the operand stack, <I>value</I>, must be an <FONT FACE="Courier New">int</FONT>. To execute the <FONT FACE="Courier New">ifle</FONT> instruction, the Java Virtual Machine pops <I>value</I> off the operand stack and compares it against zero. If <I>value</I> is less than or equal to zero, </I>The virtual machine forms a signed 16-bit offset by calculating <I>(branchbyte1 <FONT FACE="Courier New"> 8) | branchbyte2</I>. </I>The virtual machine then calculates a target (program counter) address by adding the calculated offset to the address of the <FONT FACE="Courier New">ifle</FONT> opcode. The target address must be the address of an opcode within the same method as the <FONT FACE="Courier New">ifle</FONT> opcode. </I>The virtual machine jumps to the target address and continues execution there. Otherwise, if <I>value</I> is not less than or equal to zero, </I>The virtual machine does not take the jump. It simply continues execution at the instruction immediately following the <FONT FACE="Courier New">ifle</FONT> instruction.</P>
<P>For more information about the <FONT FACE="Courier New">ifle</FONT> instruction, see Chapter 16, &quot;Control Flow.&quot;</P>
<P><H3><FONT FACE="Courier New">iflt</H3></FONT> - Branch if less than 0</P>
<P><H3>Opcode:</H3> 155 (0x9b)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">iflt</FONT>, <I>branchbyte1</I>, <I>branchbyte2</P></EM></H4>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value</P></EM></H4>
<P>After:<I>...</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The top word of the operand stack, <I>value</I>, must be an <FONT FACE="Courier New">int</FONT>. To execute the <FONT FACE="Courier New">iflt</FONT> instruction, the Java Virtual Machine pops <I>value</I> off the operand stack and compares it against zero. If <I>value</I> is less than zero, </I>The virtual machine forms a signed 16-bit offset by calculating <I>(branchbyte1 <FONT FACE="Courier New"> 8) | branchbyte2</I>. </I>The virtual machine then calculates a target (program counter) address by adding the calculated offset to the address of the <FONT FACE="Courier New">iflt</FONT> opcode. The target address must be the address of an opcode within the same method as the <FONT FACE="Courier New">iflt</FONT> opcode. </I>The virtual machine jumps to the target address and continues execution there. Otherwise, if <I>value</I> is not less than zero, </I>The virtual machine does not take the jump. It simply continues execution at the instruction immediately following the <FONT FACE="Courier New">iflt</FONT> instruction.</P>
<P>For more information about the <FONT FACE="Courier New">iflt</FONT> instruction, see Chapter 16, &quot;Control Flow.&quot;</P>
<P><H3><FONT FACE="Courier New">ifne</H3></FONT> - Branch if not equal to 0</P>
<P><H3>Opcode:</H3> 154 (0x9a)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">ifne</FONT>, <I>branchbyte1</I>, <I>branchbyte2</P></EM></H4>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value</P></EM></H4>
<P>After:<I>...</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The top word of the operand stack, <I>value</I>, must be an <FONT FACE="Courier New">int</FONT>. To execute the <FONT FACE="Courier New">ifne</FONT> instruction, the Java Virtual Machine pops <I>value</I> off the operand stack and compares it against zero. If <I>value</I> does not equal zero, </I>The virtual machine forms a signed 16-bit offset by calculating <I>(branchbyte1 <FONT FACE="Courier New"> 8) | branchbyte2</I>. </I>The virtual machine then calculates a target (program counter) address by adding the calculated offset to the address of the <FONT FACE="Courier New">ifne</FONT> opcode. The target address must be the address of an opcode within the same method as the <FONT FACE="Courier New">ifne</FONT> opcode. </I>The virtual machine jumps to the target address and continues execution there. Otherwise, if <I>value</I> does equal zero, </I>The virtual machine does not take the jump. It simply continues execution at the instruction immediately following the <FONT FACE="Courier New">ifne</FONT> instruction.</P>
<P>For more information about the <FONT FACE="Courier New">ifne</FONT> instruction, see Chapter 16, &quot;Control Flow.&quot;</P>
<P><H3><FONT FACE="Courier New">ifnonnull</H3></FONT> - Branch if not null</P>
<P><H3>Opcode:</H3> 199 (0xc7)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">ifnonnull</FONT>, <I>branchbyte1</I>, <I>branchbyte2</P></EM></H4>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value</P></EM></H4>
<P>After:<I>...</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The top word of the operand stack, <I>value</I>, must be a <FONT FACE="Courier New">reference</FONT>. To execute the <FONT FACE="Courier New">ifnonnull</FONT> instruction, the Java Virtual Machine pops <I>value</I> off the operand stack and compares it against <FONT FACE="Courier New">null</FONT>. If <I>value</I> is not <FONT FACE="Courier New">null</FONT>, </I>The virtual machine forms a signed 16-bit offset by calculating <I>(branchbyte1 <FONT FACE="Courier New"> 8) | branchbyte2</I>. </I>The virtual machine then calculates a target (program counter) address by adding the calculated offset to the address of the <FONT FACE="Courier New">ifnonnull</FONT> opcode. The target address must be the address of an opcode within the same method as the <FONT FACE="Courier New">ifnonnull</FONT> opcode. </I>The virtual machine jumps to the target address and continues execution there. Otherwise, if <I>value</I> is <FONT FACE="Courier New">null</FONT>, </I>The virtual machine does not take the jump. It simply continues execution at the instruction immediately following the <FONT FACE="Courier New">ifnonnull</FONT> instruction.</P>
<P>For more information about the <FONT FACE="Courier New">ifnonnull</FONT> instruction, see Chapter 16, &quot;Control Flow.&quot;</P>
<P><H3><FONT FACE="Courier New">ifnull</H3></FONT> - Branch if null</P>
<P><H3>Opcode:</H3> 198 (0xc6)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">ifnull</FONT>, <I>branchbyte1</I>, <I>branchbyte2</P></EM></H4>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value</P></EM></H4>
<P>After:<I>...</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The top word of the operand stack, <I>value</I>, must be a <FONT FACE="Courier New">reference</FONT>. To execute the <FONT FACE="Courier New">ifnull</FONT> instruction, the Java Virtual Machine pops <I>value</I> off the operand stack and compares it against <FONT FACE="Courier New">null</FONT>. If <I>value</I> is <FONT FACE="Courier New">null</FONT>, </I>The virtual machine forms a signed 16-bit offset by calculating <I>(branchbyte1 <FONT FACE="Courier New"> 8) | branchbyte2</I>. </I>The virtual machine then calculates a target (program counter) address by adding the calculated offset to the address of the <FONT FACE="Courier New">ifnull</FONT> opcode. The target address must be the address of an opcode within the same method as the <FONT FACE="Courier New">ifnull</FONT> opcode. </I>The virtual machine jumps to the target address and continues execution there. Otherwise, if <I>value</I> is not <FONT FACE="Courier New">null</FONT>, </I>The virtual machine does not take the jump. It simply continues execution at the instruction immediately following the <FONT FACE="Courier New">ifnull</FONT> instruction.</P>
<P>For more information about the <FONT FACE="Courier New">ifnull</FONT> instruction, see Chapter 16, &quot;Control Flow.&quot;</P>
<P><H3><FONT FACE="Courier New">if_acmpeq</H3></FONT> - Branch if object references are equal</P>
<P><H3>Opcode:</H3> 165 (0xa5)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">if_acmpeq</FONT>, <I>branchbyte1</I>, <I>branchbyte2</P></EM></H4>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value1, value2</P></EM></H4>
<P>After:<I>...</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The top two words of the operand stack, <I>value1</I> and <I>value2</I>, must be <FONT FACE="Courier New">reference</FONT>s. To execute the <FONT FACE="Courier New">if_acmpeq</FONT> instruction, the Java Virtual Machine pops <I>value1</I> and <I>value2</I> off the operand stack and compares one against the other. If <I>value1</I> equals <I>value2</I> (in other words, if they both point to exactly the same object or are both <FONT FACE="Courier New">null</FONT>), </I>The virtual machine forms a signed 16-bit offset by calculating <I>(branchbyte1 <FONT FACE="Courier New"> 8) | branchbyte2</I>. </I>The virtual machine then calculates a target (program counter) address by adding the calculated offset to the address of the <FONT FACE="Courier New">if_acmpeq</FONT> opcode. The target address must be the address of an opcode within the same method as the <FONT FACE="Courier New">if_acmpeq</FONT> opcode. </I>The virtual machine jumps to the target address and continues execution there. Otherwise, if <I>value</I> does not equal <I>value2</I>, </I>The virtual machine does not take the jump. It simply continues execution at the instruction immediately following the <FONT FACE="Courier New">if_acmpeq</FONT> instruction.</P>
<P>For more information about the <FONT FACE="Courier New">if_acmpeq</FONT> instruction, see Chapter 16, &quot;Control Flow.&quot;</P>
<P><H3><FONT FACE="Courier New">if_acmpne</H3></FONT> - Branch if object references not equal</P>
<P><H3>Opcode:</H3> 166 (0xa6)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">if_acmpne</FONT>, <I>branchbyte1</I>, <I>branchbyte2</P></EM></H4>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value1, value2</P></EM></H4>
<P>After:<I>...</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The top two words of the operand stack, <I>value1</I> and <I>value2</I>, must be <FONT FACE="Courier New">reference</FONT>s. To execute the <FONT FACE="Courier New">if_acmpne</FONT> instruction, the Java Virtual Machine pops <I>value1</I> and <I>value2</I> off the operand stack and compares one against the other. If <I>value1</I> does not equal <I>value2</I> (in other words, if they donít both point to exactly the same object and they arenít both <FONT FACE="Courier New">null</FONT>), </I>The virtual machine forms a signed 16-bit offset by calculating <I>(branchbyte1 <FONT FACE="Courier New"> 8) | branchbyte2</I>. </I>The virtual machine then calculates a target (program counter) address by adding the calculated offset to the address of the <FONT FACE="Courier New">if_acmpne</FONT> opcode. The target address must be the address of an opcode within the same method as the <FONT FACE="Courier New">if_acmpne</FONT> opcode. </I>The virtual machine jumps to the target address and continues execution there. Otherwise, if <I>value</I> equals <I>value2</I>, </I>The virtual machine does not take the jump. It simply continues execution at the instruction immediately following the <FONT FACE="Courier New">if_acmpne</FONT> instruction.</P>
<P>For more information about the <FONT FACE="Courier New">if_acmpne</FONT> instruction, see Chapter 16, &quot;Control Flow.&quot;</P>
<P><H3><FONT FACE="Courier New">if_icmpeq</H3></FONT> - Branch if <FONT FACE="Courier New">int</FONT>s equal</P>
<P><H3>Opcode:</H3> 159 (0x9f)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">if_icmpeq</FONT>, <I>branchbyte1</I>, <I>branchbyte2</P></EM></H4>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value1, value2</P></EM></H4>
<P>After:<I>...</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The top two words of the operand stack, <I>value1</I> and <I>value2</I>, must be <FONT FACE="Courier New">int</FONT>s. To execute the <FONT FACE="Courier New">if_icmpeq</FONT> instruction, the Java Virtual Machine pops <I>value1</I> and <I>value2</I> off the operand stack and compares one against the other. If <I>value1</I> equals <I>value2</I>, </I>The virtual machine forms a signed 16-bit offset by calculating <I>(branchbyte1 <FONT FACE="Courier New"> 8) | branchbyte2</I>. </I>The virtual machine then calculates a target (program counter) address by adding the calculated offset to the address of the <FONT FACE="Courier New">if_icmpeq</FONT> opcode. The target address must be the address of an opcode within the same method as the <FONT FACE="Courier New">if_icmpeq</FONT> opcode. </I>The virtual machine jumps to the target address and continues execution there. Otherwise, if <I>value</I> does not equal <I>value2</I>, </I>The virtual machine does not take the jump. It simply continues execution at the instruction immediately following the <FONT FACE="Courier New">if_icmpeq</FONT> instruction.</P>
<P>For more information about the <FONT FACE="Courier New">if_icmpeq</FONT> instruction, see Chapter 16, &quot;Control Flow.&quot;</P>
<P><H3><FONT FACE="Courier New">if_icmpge</H3></FONT> - Branch if <FONT FACE="Courier New">int</FONT> greater than or equal to other <FONT FACE="Courier New">int</FONT></P>
<P><H3>Opcode:</H3> 162 (0xa2)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">if_icmpge</FONT>, <I>branchbyte1</I>, <I>branchbyte2</P></EM></H4>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value1, value2</P></EM></H4>
<P>After:<I>...</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The top two words of the operand stack, <I>value1</I> and <I>value2</I>, must be <FONT FACE="Courier New">int</FONT>s. To execute the <FONT FACE="Courier New">if_icmpge</FONT> instruction, the Java Virtual Machine pops <I>value1</I> and <I>value2</I> off the operand stack and compares one against the other. If <I>value1</I> is greater than or equal to <I>value2</I>, </I>The virtual machine forms a signed 16-bit offset by calculating <I>(branchbyte1 <FONT FACE="Courier New"> 8) | branchbyte2</I>. </I>The virtual machine then calculates a target (program counter) address by adding the calculated offset to the address of the <FONT FACE="Courier New">if_icmpge</FONT> opcode. The target address must be the address of an opcode within the same method as the <FONT FACE="Courier New">if_icmpge</FONT> opcode. </I>The virtual machine jumps to the target address and continues execution there. Otherwise, if <I>value</I> is not greater than or equal to <I>value2</I>, </I>The virtual machine does not take the jump. It simply continues execution at the instruction immediately following the <FONT FACE="Courier New">if_icmpge</FONT> instruction.</P>
<P>For more information about the <FONT FACE="Courier New">if_icmpge</FONT> instruction, see Chapter 16, &quot;Control Flow.&quot;</P>
<P><H3><FONT FACE="Courier New">if_icmpgt</H3></FONT> - Branch if <FONT FACE="Courier New">int</FONT> greater than other <FONT FACE="Courier New">int</FONT></P>
<P><H3>Opcode:</H3> 163 (0xa3)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">if_icmpgt</FONT>, <I>branchbyte1</I>, <I>branchbyte2</P></EM></H4>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value1, value2</P></EM></H4>
<P>After:<I>...</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The top two words of the operand stack, <I>value1</I> and <I>value2</I>, must be <FONT FACE="Courier New">int</FONT>s. To execute the <FONT FACE="Courier New">if_icmpgt</FONT> instruction, the Java Virtual Machine pops <I>value1</I> and <I>value2</I> off the operand stack and compares one against the other. If <I>value1</I> is greater than <I>value2</I>, </I>The virtual machine forms a signed 16-bit offset by calculating <I>(branchbyte1 <FONT FACE="Courier New"> 8) | branchbyte2</I>. </I>The virtual machine then calculates a target (program counter) address by adding the calculated offset to the address of the <FONT FACE="Courier New">if_icmpgt</FONT> opcode. The target address must be the address of an opcode within the same method as the <FONT FACE="Courier New">if_icmpgt</FONT> opcode. </I>The virtual machine jumps to the target address and continues execution there. Otherwise, if <I>value</I> is not greater than <I>value2</I>, </I>The virtual machine does not take the jump. It simply continues execution at the instruction immediately following the <FONT FACE="Courier New">if_icmpgt</FONT> instruction.</P>
<P>For more information about the <FONT FACE="Courier New">if_icmpgt</FONT> instruction, see Chapter 16, &quot;Control Flow.&quot;</P>
<P><H3><FONT FACE="Courier New">if_icmple</H3></FONT> - Branch if <FONT FACE="Courier New">int</FONT> less than or equal to other <FONT FACE="Courier New">int</FONT></P>
<P><H3>Opcode:</H3> 164 (0xa4)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">if_icmple</FONT>, <I>branchbyte1</I>, <I>branchbyte2</P></EM></H4>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value1, value2</P></EM></H4>
<P>After:<I>...</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The top two words of the operand stack, <I>value1</I> and <I>value2</I>, must be <FONT FACE="Courier New">int</FONT>s. To execute the <FONT FACE="Courier New">if_icmple</FONT> instruction, the Java Virtual Machine pops <I>value1</I> and <I>value2</I> off the operand stack and compares one against the other. If <I>value1</I> is less than or equal to <I>value2</I>, </I>The virtual machine forms a signed 16-bit offset by calculating <I>(branchbyte1 <FONT FACE="Courier New"> 8) | branchbyte2</I>. </I>The virtual machine then calculates a target (program counter) address by adding the calculated offset to the address of the <FONT FACE="Courier New">if_icmple</FONT> opcode. The target address must be the address of an opcode within the same method as the <FONT FACE="Courier New">if_icmple</FONT> opcode. </I>The virtual machine jumps to the target address and continues execution there. Otherwise, if <I>value</I> is not less than or equal to <I>value2</I>, </I>The virtual machine does not take the jump. It simply continues execution at the instruction immediately following the <FONT FACE="Courier New">if_icmple</FONT> instruction.</P>
<P>For more information about the <FONT FACE="Courier New">if_icmple</FONT> instruction, see Chapter 16, &quot;Control Flow.&quot;</P>
<P><H3><FONT FACE="Courier New">if_icmplt</H3></FONT> - Branch if <FONT FACE="Courier New">int</FONT> less than other <FONT FACE="Courier New">int</FONT></P>
<P><H3>Opcode:</H3> 161 (0xa1)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">if_icmplt</FONT>, <I>branchbyte1</I>, <I>branchbyte2</P></EM></H4>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value1, value2</P></EM></H4>
<P>After:<I>...</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The top two words of the operand stack, <I>value1</I> and <I>value2</I>, must be <FONT FACE="Courier New">int</FONT>s. To execute the <FONT FACE="Courier New">if_icmplt</FONT> instruction, the Java Virtual Machine pops <I>value1</I> and <I>value2</I> off the operand stack and compares one against the other. If <I>value1</I> is less than <I>value2</I>, </I>The virtual machine forms a signed 16-bit offset by calculating <I>(branchbyte1 <FONT FACE="Courier New"> 8) | branchbyte2</I>. </I>The virtual machine then calculates a target (program counter) address by adding the calculated offset to the address of the <FONT FACE="Courier New">if_icmplt</FONT> opcode. The target address must be the address of an opcode within the same method as the <FONT FACE="Courier New">if_icmplt</FONT> opcode. </I>The virtual machine jumps to the target address and continues execution there. Otherwise, if <I>value</I> is not less than <I>value2</I>, </I>The virtual machine does not take the jump. It simply continues execution at the instruction immediately following the <FONT FACE="Courier New">if_icmplt</FONT> instruction.</P>
<P>For more information about the <FONT FACE="Courier New">if_icmplt</FONT> instruction, see Chapter 16, &quot;Control Flow.&quot;</P>
<P><H3><FONT FACE="Courier New">if_icmpne</H3></FONT> - Branch if <FONT FACE="Courier New">int</FONT>s not equal</P>
<P><H3>Opcode:</H3> 160 (0xa0)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">if_icmpne</FONT>, <I>branchbyte1</I>, <I>branchbyte2</P></EM></H4>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value1, value2</P></EM></H4>
<P>After:<I>...</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The top two words of the operand stack, <I>value1</I> and <I>value2</I>, must be <FONT FACE="Courier New">int</FONT>s. To execute the <FONT FACE="Courier New">if_icmpne</FONT> instruction, the Java Virtual Machine pops <I>value1</I> and <I>value2</I> off the operand stack and compares one against the other. If <I>value1</I> does not equal <I>value2</I>, </I>The virtual machine forms a signed 16-bit offset by calculating <I>(branchbyte1 <FONT FACE="Courier New"> 8) | branchbyte2</I>. </I>The virtual machine then calculates a target (program counter) address by adding the calculated offset to the address of the <FONT FACE="Courier New">if_icmpne</FONT> opcode. The target address must be the address of an opcode within the same method as the <FONT FACE="Courier New">if_icmpne</FONT> opcode. </I>The virtual machine jumps to the target address and continues execution there. Otherwise, if <I>value1</I> equals <I>value2</I>, </I>The virtual machine does not take the jump. It simply continues execution at the instruction immediately following the <FONT FACE="Courier New">if_icmpne</FONT> instruction.</P>
<P>For more information about the <FONT FACE="Courier New">if_icmpne</FONT> instruction, see Chapter 16, &quot;Control Flow.&quot;</P>
<P><H3><FONT FACE="Courier New">iinc</H3></FONT> - Increment <FONT FACE="Courier New">int</FONT> local variable by constant</P>
<P><H3>Opcode:</H3> 132 (0x84)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">iinc</FONT>, <I>index</I>, <I>const</P></EM></H4>
<P><H3>Stack:</H3></P>
<P>No change</P>
<P><H3>Description:</H3></P>
<P>The <I>index</I> operand must specify a valid 8-bit unsigned index into the local variables of the current frame. To execute the <FONT FACE="Courier New">iinc</FONT> instruction, the Java Virtual Machine adds the 8-bit signed increment <I>const</I>  to the local variable word specified by <I>index</I>.</P>
<P>Note that the <FONT FACE="Courier New">wide</FONT> instruction can precede the <FONT FACE="Courier New">iinc</FONT> instruction, to enable a local variable specified by a 16-bit unsigned offset to be incremented by a signed 16-bit constant.</P>
<P>For more information about the <FONT FACE="Courier New">iinc</FONT> instruction, see Chapter 12, &quot;Integer Arithmetic.&quot;</P>
<P><H3><FONT FACE="Courier New">iload</H3></FONT> - Load <FONT FACE="Courier New">int</FONT> from local variable</P>
<P><H3>Opcode:</H3> 21 (0x15)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">iload</FONT>, <I>index</P></EM></H4>
<P><H3>Stack:</H3></P>
<P>Before:<I>...</P></EM></H4>
<P>After:<I>..., value</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The <I>index</I> operand, which serves as an 8-bit unsigned index into the local variables of the current frame, must specify a local variable word that contains an <FONT FACE="Courier New">int</FONT>. To execute the <FONT FACE="Courier New">iload</FONT> instruction, the Java Virtual Machine pushes onto the operand stack the <FONT FACE="Courier New">int</FONT> <I>value</I> contained in the local variable word specified by <I>index</I>.</P>
<P>Note that the <FONT FACE="Courier New">wide</FONT> instruction can precede the <FONT FACE="Courier New">iload</FONT> instruction, to allow a local variable to be accessed with a 16-bit unsigned offset.</P>
<P>For more information about the <FONT FACE="Courier New">iload</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<P><H3><FONT FACE="Courier New">iload_0</H3></FONT> - Load <FONT FACE="Courier New">int</FONT> from local variable 0</P>
<P><H3>Opcode:</H3> 26 (0x1a)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">iload_0</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..</P></EM></H4>
<P>After:<I>..., value</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The local variable word at index zero must contain an <FONT FACE="Courier New">int</FONT>. To execute the <FONT FACE="Courier New">iload_0</FONT> instruction, the Java Virtual Machine pushes onto the operand stack the <FONT FACE="Courier New">int</FONT> <I>value</I> contained in the local variable word zero.</P>
<P>For more information about the <FONT FACE="Courier New">iload_0</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<P><H3><FONT FACE="Courier New">iload_1</H3></FONT> - Load <FONT FACE="Courier New">int</FONT> from local variable 1</P>
<P><H3>Opcode:</H3> 27 (0x1b)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">iload_1</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..</P></EM></H4>
<P>After:<I>..., value</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The local variable word at index one must contain an <FONT FACE="Courier New">int</FONT>. To execute the <FONT FACE="Courier New">iload_1</FONT> instruction, the Java Virtual Machine pushes onto the operand stack the <FONT FACE="Courier New">int</FONT> contained in the local variable word one.</P>
<P>For more information about the <FONT FACE="Courier New">iload_1</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<P><H3><FONT FACE="Courier New">iload_2</H3></FONT> - Load <FONT FACE="Courier New">int</FONT> from local variable 2</P>
<P><H3>Opcode:</H3> 28 (0x1c)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">iload_2</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..</P></EM></H4>
<P>After:<I>..., value</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The local variable word at index two must contain an <FONT FACE="Courier New">int</FONT>. To execute the <FONT FACE="Courier New">iload_2</FONT> instruction, the Java Virtual Machine pushes onto the operand stack the <FONT FACE="Courier New">int</FONT> <I>value</I> contained in the local variable word two.</P>
<P>For more information about the <FONT FACE="Courier New">iload_2</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<P><H3><FONT FACE="Courier New">iload_3</H3></FONT> - Load <FONT FACE="Courier New">int</FONT> from local variable 3</P>
<P><H3>Opcode:</H3> 29 (0x1d)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">iload_3</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..</P></EM></H4>
<P>After:<I>..., value</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The local variable word at index three must contain an <FONT FACE="Courier New">int</FONT>. To execute the <FONT FACE="Courier New">iload_3</FONT> instruction, the Java Virtual Machine pushes onto the operand stack the <FONT FACE="Courier New">int</FONT> <I>value</I> contained in the local variable word three.</P>
<P>For more information about the <FONT FACE="Courier New">iload_3</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<P><H3><FONT FACE="Courier New">imul</H3></FONT> - Multiply <FONT FACE="Courier New">int</FONT>s</P>
<P><H3>Opcode:</H3> 104 (0x68)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">imul</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value1, value2</P></EM></H4>
<P>After:<I>..., result</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The top two words of the operand stack, <I>value1</I> and <I>value2</I>, must be <FONT FACE="Courier New">int</FONT>s. To execute the <FONT FACE="Courier New">imul</FONT> instruction, the Java Virtual Machine pops <I>value1</I> and <I>value2</I>, multiplies them, and pushes the <FONT FACE="Courier New">int</FONT> <I>result</I>. If overflow occurs, <I>result</I> is the 32 lowest order bits of the true mathematical result represented in a sufficiently wide twoís-complement format, and the sign of <I>result</I> may be different from that of the true mathematical result.</P>
<P>For more information about the <FONT FACE="Courier New">imul</FONT> instruction, see Chapter 12, &quot;Integer Arithmetic.&quot;</P>
<P><H3><FONT FACE="Courier New">ineg</H3></FONT> - Negate <FONT FACE="Courier New">int</FONT></P>
<P><H3>Opcode:</H3> 116 (0x74)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">ineg</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value</P></EM></H4>
<P>After:<I>..., result</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The top word of the operand stack, <I>value</I>, must be an <FONT FACE="Courier New">int</FONT>. To execute the <FONT FACE="Courier New">ineg</FONT> instruction, the Java Virtual Machine pops <I>value</I>, negates it, and pushes the <FONT FACE="Courier New">int</FONT> <I>result</I>.</P>
<P>The <I>result</I> produced by an <FONT FACE="Courier New">ineg</FONT> instruction is the same number that would be produced by subtracting <I>value</I> from zero with the <FONT FACE="Courier New">isub</FONT> instruction. As a consequence, when <I>value</I> is the smallest negative integer that can be represented by an <FONT FACE="Courier New">int</FONT>, the negation overflows. For this negation, the true mathematical result is one greater than the largest positive integer that can be represented by an <FONT FACE="Courier New">int</FONT>, and the actual <I>result</I> is equal to <I>value</I> with no change in sign.</P>
<P>For more information about the <FONT FACE="Courier New">ineg</FONT> instruction, see Chapter 12, &quot;Integer Arithmetic.&quot;</P>
<P><H3><FONT FACE="Courier New">instanceof</H3></FONT> - Determine if an object is of given type</P>
<P><H3>Opcode:</H3> 193 (0xc1)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">instanceof</FONT>, <I>indexbyte1</I>, <I>indexbyte2</P></EM></H4>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., objectref</P></EM></H4>
<P>After:<I>..., result</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The top word of the stack, <I>objectref</I>, must be a <FONT FACE="Courier New">reference</FONT>. To execute the <FONT FACE="Courier New">instanceof</FONT> instruction, the Java Virtual Machine first forms an unsigned 16-bit index into the constant pool by calculating <I>(indexbyte1 <FONT FACE="Courier New"> 8) | indexbyte2</I>. </I>The virtual machine then looks up the constant pool entry specified by the calculated index. The constant pool entry at that index must be a <FONT FACE="Courier New">CONSTANT_Class_info</FONT> entry. If it hasnít already, </I>The virtual machine resolves the entry. The entry may be a class, interface, or array type. If <I>objectref</I> is not <FONT FACE="Courier New">null</FONT> and the object pointed to by <I>objectref</I> is an &quot;instance of&quot; the resolved type, </I>The virtual machine pushes an <FONT FACE="Courier New">int</FONT> one <I>result</I> onto the operand stack. Otherwise, </I>The virtual machine machine pushes an <FONT FACE="Courier New">int</FONT> zero <I>result</I> onto the operand stack.</P>
<P>To determine whether the object pointed to by <I>objectref</I> is an &quot;instance of&quot; the resolved type, </I>The virtual machine first determines whether the object is a class instance or array. (It canít be an interface instance, because interfaces canít be instantiated.) If it is a class instance, and the resolved type is a class, not an interface, the object is &quot;an instance&quot; of the resolved class if the objectís class is the resolved class or a subclass of the resolved class. Else, if it is a class instance, and the resolved type is an interface, not an class, the object is &quot;an instance&quot; of the resolved interface if the objectís class implements the resolved interface. Otherwise, the object is an array. If the resolved type is a class, it must be <FONT FACE="Courier New">java.lang.Object</FONT>. Else, if the resolved type is an array of primitive types, the object must be an array of the same primitive type. Otherwise, the resolved type must be an array with a component type of some reference type, and the object must be an array with a component type that is an &quot;instance of&quot; the component type of the resolved array type. (Note that the dimension of an array doesnít enter into the <FONT FACE="Courier New">instanceof</FONT> check, only the component type of the array.)</P>
<P>As a result of executing this instruction, </I>The virtual machine may throw any of the linking errors listed in Chapter 8, &quot;The Linking Model,&quot; as possible during resolution of a <FONT FACE="Courier New">CONSTANT_Class_info</FONT> entry.</P>
<P>For more information about the <FONT FACE="Courier New">instanceof</FONT> instruction, see Chapter 15, &quot;Objects and Arrays.&quot;</P>
<P><H3><FONT FACE="Courier New">invokeinterface</H3></FONT> - Invoke interface method</P>
<P><H3>Opcode:</H3> 185 (0xb9)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">invokeinterface</FONT>, <I>indexbyte1</I>, <I>indexbyte2</I>, <I>nargs</I>, <I>0</P></EM></H4>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., objectref, [arg1, [arg2 ...]]</P></EM></H4>
<P>After:<I>...</P></EM></H4>
<P><H3>Description:</H3></P>
<P>To execute the <FONT FACE="Courier New">invokeinterface</FONT> instruction, the Java Virtual Machine first forms an unsigned 16-bit index into the constant pool by calculating <I>(indexbyte1 <FONT FACE="Courier New"> 8) | indexbyte2</I>. </I>The virtual machine then looks up the constant pool entry specified by the calculated index. The constant pool entry at that index must be a <FONT FACE="Courier New">CONSTANT_InterfaceMethodref_info</FONT> entry. If it hasnít already, </I>The virtual machine resolves the entry. The resolved methodís descriptor must exactly match the descriptor of one of the methods declared in the resolved interface. The method must not be an instance initialization method, &quot;<FONT FACE="Courier New">&lt;init</FONT>&quot;, or a class initialization method, &quot;<FONT FACE="Courier New">&lt;clinit</FONT>.&quot; </P>
<P>The <I>nargs</I> operand is an unsigned byte that indicates the number of words of parameters required by the method being invoked (including the hidden <FONT FACE="Courier New">this</FONT> reference). The operand stack must contain <I>nargs - 1</I> words of parameters and the <I>objectref</I> word. The parameter words must match the order and type of parameters required by the resolved method. The <I>objectref</I> word, the reference to the object upon which to invoke the instance method, must be a <FONT FACE="Courier New">reference</FONT>. If the resolution is successful, </I>The virtual machine pops <I>nargs - 1</I> parameter words and <I>objectref</I>. </P>
<P>To invoke the method, </I>The virtual machine retrieves the direct reference to the instance method to invoke from a method table. It locates the method table for the class of object pointed to by <I>objectref</I> and searches through it for a method with a name and descriptor that matches exactly the name and descriptor of the resolved method. (If the objectís class is an array type, </I>The virtual machine uses the method table for class <FONT FACE="Courier New">java.lang.Object</FONT>. An array type, of course, can only implement an interface if <FONT FACE="Courier New">Object</FONT> itself implements the interface.)</P>
<P>If the method is synchronized, the Java Virtual Machine, on behalf of the current thread, acquires the monitor associated with <I>objectref</I>.</P>
<P>If the method to invoke is not native, </I>The virtual machine creates a new stack frame for the method and pushes the new stack frame onto the current threadís Java stack. </I>The virtual machine then places the <I>objectref</I> word and <I>nargs - 1</I> parameter words that it popped from the operand stack of the calling methodís frame into the local variables of the new stack frame. It places <I>objectref</I> into local variable position zero, <I>arg1</I> into local variable position one, and so on. (<I>objectref</I> is the hidden <FONT FACE="Courier New">this</FONT> reference passed to all instance methods.) </I>The virtual machine makes the new stack frame current, sets the program counter to the address of the first instruction in the new method, and continues execution there.</P>
<P>If the method to invoke is native, </I>The virtual machine invokes the native method in an implementation-dependent manner.</P>
<P>As a result of executing this instruction, </I>The virtual machine may throw any of the linking errors listed in Chapter 8, &quot;The Linking Model,&quot; as possible during resolution of a <FONT FACE="Courier New">CONSTANT_InterfaceMethodref_info</FONT> entry. If no method exists in the objectís class with the required name and descriptor, </I>The virtual machine throws <FONT FACE="Courier New">IncompatibleClassChangeError</FONT>. Else, if the method exists but is static, </I>The virtual machine throws <FONT FACE="Courier New">IncompatibleClassChangeError</FONT>. Else, if the method exists, but is not public, the virtual machine throws <FONT FACE="Courier New">IllegalAccessError</FONT>. Else, if the method is abstract, </I>The virtual machine throws <FONT FACE="Courier New">AbstractMethodError</FONT>. Else, if the method is native and the native implementation of the method canít be loaded or linked, </I>The virtual machine throws <FONT FACE="Courier New">UnsatisfiedLinkError</FONT>. Otherwise, if <I>objectref</I> is <FONT FACE="Courier New">null</FONT>, </I>The virtual machine throws <FONT FACE="Courier New">NullPointerException</FONT>.</P>
<P>For more information about the <FONT FACE="Courier New">invokeinterface</FONT> instruction, see Chapter 19, &quot;Method Invocation and Return.&quot;</P>
<P><H3><FONT FACE="Courier New">invokespecial</H3></FONT> - Invoke instance method with special handling for private, superclass, and instance initialization methods</P>
<P><H3>Opcode:</H3> 183 (0xb7)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">invokespecial</FONT>, <I>indexbyte1</I>, <I>indexbyte2</P></EM></H4>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., objectref, [arg1, [arg2 ...]]</P></EM></H4>
<P>After:<I>...</P></EM></H4>
<P><H3>Description:</H3></P>
<P>To execute the <FONT FACE="Courier New">invokespecial</FONT> instruction, the Java Virtual Machine first forms an unsigned 16-bit index into the constant pool by calculating <I>(indexbyte1 <FONT FACE="Courier New"> 8) | indexbyte2</I>. </I>The virtual machine then looks up the constant pool entry specified by the calculated index. The constant pool entry at that index must be a <FONT FACE="Courier New">CONSTANT_Methodref_info</FONT> entry. If it hasnít already, </I>The virtual machine resolves the entry, which yields a direct reference to the methodís data, including the number of words of parameters to the method, <I>nargs</I>. The resolved methodís descriptor must exactly match the descriptor of one of the methods declared in the resolved class. The method must not be a class initialization method, &quot;<FONT FACE="Courier New">&lt;clinit</FONT>.&quot; </P>
<P>The <FONT FACE="Courier New">invokespecial</FONT> instruction is used to invoke three special kinds of instance methods: superclass methods, private methods, and instance initialization methods. <FONT FACE="Courier New">invokespecial</FONT> contrasts with <FONT FACE="Courier New">invokevirtual</FONT> in the way it invokes an instance method. Whereas <FONT FACE="Courier New">invokevirtual</FONT> always selects the method to invoke at run-time based on the class of the object (dynamic binding), <FONT FACE="Courier New">invokespecial</FONT> normally (with one exception) selects the method to invoke at compile-time based on the type of the reference (static binding).</P>
<P>The one exception to <FONT FACE="Courier New">invokespecial</FONT>ís pure static binding behavior occurs if</P>
<P>o the resolved method is not private and is not an instance initialization method,</P>
<P>o the resolved methodís class is a superclass of the current methodís class,</P>
<P>o and the <FONT FACE="Courier New">ACC_SUPER</FONT> flag is set in the current methodís class.</P>
<P>In this situation, the Java Virtual Machine dynamically selects at run-time the method to invoke by finding the method in the closest superclass that has a descriptor that exactly matches the resolved methodís descriptor, irrespective of the class of the resolved method. In the majority of cases, the class of the selected method will most likely be the class of the resolved method anyway, but it is possible that it could be some other class.</P>
<P>For example, imagine you create an inheritance hierarchy of three classes: <FONT FACE="Courier New">Animal</FONT>, <FONT FACE="Courier New">Dog</FONT>, and <FONT FACE="Courier New">CockerSpaniel</FONT>. Assume class <FONT FACE="Courier New">Dog</FONT> extends class <FONT FACE="Courier New">Animal</FONT>, class <FONT FACE="Courier New">CockerSpaniel</FONT> extends class <FONT FACE="Courier New">Dog</FONT>, and that a method defined in <FONT FACE="Courier New">CockerSpaniel</FONT> uses <FONT FACE="Courier New">invokespecial</FONT> to invoke a non-private superclass method named <FONT FACE="Courier New">walk()</FONT>. Assume also that when you compiled <FONT FACE="Courier New">CockerSpaniel</FONT>, the compiler set the <FONT FACE="Courier New">ACC_SUPER</FONT> flag. In addition, assume that when you compiled <FONT FACE="Courier New">CockerSpaniel</FONT>, class <FONT FACE="Courier New">Animal</FONT> defined a <FONT FACE="Courier New">walk()</FONT> method, but <FONT FACE="Courier New">Dog</FONT> didnít. In that case, the symbolic reference from <FONT FACE="Courier New">CockerSpaniel</FONT> to the <FONT FACE="Courier New">walk()</FONT> method would give <FONT FACE="Courier New">Animal</FONT> as its class. When the <FONT FACE="Courier New">invokespecial</FONT> instruction in <FONT FACE="Courier New">CockerSpaniel</FONT>ís method is executed, </I>The virtual machine would dynamically select and invoke <FONT FACE="Courier New">Animal</FONT>ís <FONT FACE="Courier New">walk()</FONT> method.</P>
<P>Now imagine that later, you added a <FONT FACE="Courier New">walk()</FONT> method to <FONT FACE="Courier New">Dog</FONT>, and recompiled <FONT FACE="Courier New">Dog</FONT>, but didnít recompile <FONT FACE="Courier New">CockerSpaniel</FONT>. <FONT FACE="Courier New">CockerSpaniel</FONT>ís symbolic reference to the superclass <FONT FACE="Courier New">walk()</FONT> method still claims <FONT FACE="Courier New">Animal</FONT> as its class, even though there is now an implementation of <FONT FACE="Courier New">walk()</FONT> in <FONT FACE="Courier New">Dog</FONT>ís class file. Nevertheless, when the <FONT FACE="Courier New">invokespecial</FONT> instruction in <FONT FACE="Courier New">CockerSpaniel</FONT>ís method is executed, </I>The virtual machine would dynamically select and invoke <FONT FACE="Courier New">Dog</FONT>ís implementation of the <FONT FACE="Courier New">walk()</FONT> method.</P>
<P>This special (not static binding) treatment of superclass invocations was the motivation for adding the <FONT FACE="Courier New">ACC_SUPER</FONT> flag to the class <FONT FACE="Courier New">access_flags</FONT> item of class files, and for changing the name of this opcode from its original name, <FONT FACE="Courier New">invokenonvirtual</FONT>, to its current name, <FONT FACE="Courier New">invokespecial</FONT>. If the <FONT FACE="Courier New">CockerSpaniel</FONT> class of the previous example had been compiled by an old compiler that didnít set the <FONT FACE="Courier New">ACC_SUPER</FONT> flag, </I>The virtual machine would invoke <FONT FACE="Courier New">Animal</FONT>ís implementation of <FONT FACE="Courier New">walk()</FONT> regardless of whether <FONT FACE="Courier New">Dog</FONT> declared a <FONT FACE="Courier New">walk()</FONT>. As mentioned in Chapter 6, &quot;The Java Class File,&quot; all new Java compilers should set the <FONT FACE="Courier New">ACC_SUPER</FONT> flag in every class file they generate.</P>
<P>If the resolved method is an instance initialization method, &quot;<FONT FACE="Courier New">&lt;init</FONT>,&quot; the method must be invoked only once on each uninitialized (except to default initial values) object. In addition, an instance initialization method must be invoked on each uninitialized object before the first backwards branch. In other words, the bytecodes of a method need not call an <FONT FACE="Courier New">&lt;init</FONT> method with <FONT FACE="Courier New">invokespecial</FONT> right after a <FONT FACE="Courier New">new</FONT> instruction. Other instructions could intervene between the <FONT FACE="Courier New">new</FONT> and the <FONT FACE="Courier New">invokespecial</FONT> for the <FONT FACE="Courier New">&lt;init</FONT>, but none of those instructions may branch backwards (such as a <FONT FACE="Courier New">goto</FONT> to the beginning of the method).</P>
<P>The operand stack must contain <I>nargs - 1</I> words of parameters and the <I>objectref</I> word. The parameter words must match the order and type of parameters required by the resolved method. The <I>objectref</I> word, the reference to the object upon which to invoke the instance method, must be a <FONT FACE="Courier New">reference</FONT>. If the resolution is successful, </I>The virtual machine pops <I>nargs - 1</I> parameter words and <I>objectref</I>. </P>
<P>If the method is synchronized, the Java Virtual Machine, on behalf of the current thread, acquires the monitor associated with <I>objectref</I>.</P>
<P>If the method to invoke is not native, </I>The virtual machine creates a new stack frame for the method and pushes the new stack frame onto the current threadís Java stack. </I>The virtual machine then places the <I>objectref</I> word and <I>nargs - 1</I> parameter words that it popped from the operand stack of the calling methodís frame into the local variables of the new stack frame. It places <I>objectref</I> into local variable position zero, <I>arg1</I> into local variable position one, and so on. (<I>objectref</I> is the hidden <FONT FACE="Courier New">this</FONT> reference passed to all instance methods.) </I>The virtual machine makes the new stack frame current, sets the program counter to the address of the first instruction in the new method, and continues execution there.</P>
<P>If the method to invoke is native, </I>The virtual machine invokes the native method in an implementation-dependent manner.</P>
<P>As a result of executing this instruction, </I>The virtual machine may throw any of the linking errors listed in Chapter 8, &quot;The Linking Model,&quot; as possible during resolution of a <FONT FACE="Courier New">CONSTANT_Methodref_info</FONT> entry. As part of the process of resolving the <FONT FACE="Courier New">CONSTANT_Methodref_info</FONT> entry, </I>The virtual machine checks whether the methodís access permission enables the current class to access the method. If the method is protected, </I>The virtual machine makes certain the method is a member of the either the current class or a superclass of the current class, and that the class of the object pointed to by <I>objectref</I> is either the current class or a subclass of the current class. If not (or if there is any other access permission problem), </I>The virtual machine throws <FONT FACE="Courier New">IllegalAccessError</FONT>. Else, if the method exists and is accessible from the current class, but the method is static, </I>The virtual machine throws <FONT FACE="Courier New">IncompatibleClassChangeError</FONT>. Else, if the method is abstract, </I>The virtual machine throws <FONT FACE="Courier New">AbstractMethodError</FONT>. Else, if the method is native and the native implementation of the method canít be loaded or linked, </I>The virtual machine throws <FONT FACE="Courier New">UnsatisfiedLinkError</FONT>. Otherwise, if <I>objectref</I> is <FONT FACE="Courier New">null</FONT>, </I>The virtual machine throws <FONT FACE="Courier New">NullPointerException</FONT>.</P>
<P>For more information about the <FONT FACE="Courier New">invokespecial</FONT> instruction, see Chapter 19, &quot;Method Invocation and Return.&quot;</P>
<P><H3><FONT FACE="Courier New">invokestatic</H3></FONT> - Invoke a class (static) method</P>
<P><H3>Opcode:</H3> 184 (0xb8)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">invokestatic</FONT>, <I>indexbyte1</I>, <I>indexbyte2</P></EM></H4>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., [arg1, [arg2 ...]</P></EM></H4>
<P>After:<I>...</P></EM></H4>
<P><H3>Description:</H3></P>
<P>To execute the <FONT FACE="Courier New">invokestatic</FONT> instruction, the Java Virtual Machine first forms an unsigned 16-bit index into the constant pool by calculating <I>(indexbyte1 <FONT FACE="Courier New"> 8) | indexbyte2</I>. </I>The virtual machine then looks up the constant pool entry specified by the calculated index. The constant pool entry at that index must be a <FONT FACE="Courier New">CONSTANT_Methodref_info</FONT> entry. If it hasnít already, </I>The virtual machine resolves the entry, which yields a direct reference to the methodís data, including the number of words of parameters to the method, <I>nargs</I>. The resolved methodís descriptor must exactly match the descriptor of one of the methods declared in the resolved class. The method must not be an instance initialization method, &quot;<FONT FACE="Courier New">&lt;init</FONT>&quot;, or a class initialization method, &quot;<FONT FACE="Courier New">&lt;clinit</FONT>.&quot; </P>
<P>The operand stack must contain <I>nargs</I> words of parameters. The parameter words must match the order and type of parameters required by the resolved method. If the resolution is successful, </I>The virtual machine pops the <I>nargs</I> parameter words. </P>
<P>If the method is synchronized, the Java Virtual Machine, on behalf of the current thread, acquires the monitor associated with the <FONT FACE="Courier New">Class</FONT> instance that represents the resolved methodís class.</P>
<P>If the method to invoke is not native, </I>The virtual machine creates a new stack frame for the method and pushes the new stack frame onto the current threadís Java stack. </I>The virtual machine then places the <I>nargs</I> parameter words that it popped from the operand stack of the calling methodís frame into the local variables of the new stack frame. It places <I>arg1</I> into local variable position zero, <I>arg2</I> into local variable position one, and so on. </I>The virtual machine makes the new stack frame current, sets the program counter to the address of the first instruction in the new method, and continues execution there.</P>
<P>If the method to invoke is native, </I>The virtual machine invokes the native method in an implementation-dependent manner.</P>
<P>As a result of executing this instruction, </I>The virtual machine may throw any of the linking errors listed in Chapter 8, &quot;The Linking Model,&quot; as possible during resolution of a <FONT FACE="Courier New">CONSTANT_Methodref_info</FONT> entry. As part of the process of resolving the <FONT FACE="Courier New">CONSTANT_Methodref_info</FONT> entry, </I>The virtual machine checks whether the methodís access permission enables the current class to access the method. If the method is protected, </I>The virtual machine makes certain the method is a member of the either the current class or a superclass of the current class. If not (or if there is any other access permission problem), </I>The virtual machine throws <FONT FACE="Courier New">IllegalAccessError</FONT>. Else, if the method exists and is accessible from the current class, but the method is not static, </I>The virtual machine throws <FONT FACE="Courier New">IncompatibleClassChangeError</FONT>. Else, if the method is abstract, </I>The virtual machine throws <FONT FACE="Courier New">AbstractMethodError</FONT>. Otherwise, if the method is native and the native implementation of the method canít be loaded or linked, </I>The virtual machine throws <FONT FACE="Courier New">UnsatisfiedLinkError</FONT>. </P>
<P>For more information about the <FONT FACE="Courier New">invokestatic</FONT> instruction, see Chapter 19, &quot;Method Invocation and Return.&quot;</P>
<P><H3><FONT FACE="Courier New">invokevirtual</H3></FONT> - Invoke instance method,dispatch based on an objectís class at run-time</P>
<P><H3>Opcode:</H3> 182 (0xb6)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">invokevirtual</FONT>, <I>indexbyte1</I>, <I>indexbyte2</P></EM></H4>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., objectref, [arg1, [arg2 ...]]</P></EM></H4>
<P>After:<I>...</P></EM></H4>
<P><H3>Description:</H3></P>
<P>To execute the <FONT FACE="Courier New">invokevirtual</FONT> instruction, the Java Virtual Machine first forms an unsigned 16-bit index into the constant pool by calculating <I>(indexbyte1 <FONT FACE="Courier New"> 8) | indexbyte2</I>. </I>The virtual machine then looks up the constant pool entry specified by the calculated index. The constant pool entry at that index must be a <FONT FACE="Courier New">CONSTANT_Methodref_info</FONT> entry. If it hasnít already, </I>The virtual machine resolves the entry, which yields the methodís method table index, <I>index</I>, and the number of words of parameters to the method, <I>nargs</I>. The resolved methodís descriptor must exactly match the descriptor of one of the methods declared in the resolved class. The method must not be an instance initialization method, &quot;<FONT FACE="Courier New">&lt;init</FONT>&quot;, or a class initialization method, &quot;<FONT FACE="Courier New">&lt;clinit</FONT>.&quot; </P>
<P>The operand stack must contain <I>nargs - 1</I> words of parameters and the <I>objectref</I> word. The parameter words must match the order and type of parameters required by the resolved method. The <I>objectref</I> word, the reference to the object upon which to invoke the instance method, must be a <FONT FACE="Courier New">reference</FONT>. If the resolution is successful, </I>The virtual machine pops <I>nargs - 1</I> parameter words and <I>objectref</I>. </P>
<P>To invoke the method, </I>The virtual machine retrieves the direct reference to the instance method to invoke from a method table. It locates the method table for the class of object pointed to by <I>objectref</I> and looks up the direct reference that occupies method table position <I>index</I>. (If the objectís class is an array type, </I>The virtual machine uses the method table for class <FONT FACE="Courier New">java.lang.Object</FONT>.)</P>
<P>If the method is synchronized, the Java Virtual Machine, on behalf of the current thread, acquires the monitor associated with <I>objectref</I>.</P>
<P>If the method to invoke is not native, </I>The virtual machine creates a new stack frame for the method and pushes the new stack frame onto the current threadís Java stack. </I>The virtual machine then places the <I>objectref</I> word and <I>nargs - 1</I> parameter words that it popped from the operand stack of the calling methodís frame into the local variables of the new stack frame. It places <I>objectref</I> into local variable position zero, <I>arg1</I> into local variable position one, and so on. (<I>objectref</I> is the hidden <FONT FACE="Courier New">this</FONT> reference passed to all instance methods.) </I>The virtual machine makes the new stack frame current, sets the program counter to the address of the first instruction in the new method, and continues execution there.</P>
<P>If the method to invoke is native, </I>The virtual machine invokes the native method in an implementation-dependent manner.</P>
<P>As a result of executing this instruction, </I>The virtual machine may throw any of the linking errors listed in Chapter 8, &quot;The Linking Model,&quot; as possible during resolution of a <FONT FACE="Courier New">CONSTANT_Methodref_info</FONT> entry. As part of the process of resolving the <FONT FACE="Courier New">CONSTANT_Methodref_info</FONT> entry, </I>The virtual machine checks whether the methodís access permission enables the current class to access the method. If the method is protected, </I>The virtual machine makes certain the method is a member of the either the current class or a superclass of the current class, and that the class of the object pointed to by <I>objectref</I> is either the current class or a subclass of the current class. If not (or if there is any other access permission problem), </I>The virtual machine throws <FONT FACE="Courier New">IllegalAccessError</FONT>. Else, if the method exists and is accessible from the current class, but the method is static, </I>The virtual machine throws <FONT FACE="Courier New">IncompatibleClassChangeError</FONT>. Else, if the method is abstract, </I>The virtual machine throws <FONT FACE="Courier New">AbstractMethodError</FONT>. Else, if the method is native and the native implementation of the method canít be loaded or linked, </I>The virtual machine throws <FONT FACE="Courier New">UnsatisfiedLinkError</FONT>. Otherwise, if <I>objectref</I> is <FONT FACE="Courier New">null</FONT>, </I>The virtual machine throws <FONT FACE="Courier New">NullPointerException</FONT>.</P>
<P>For more information about the <FONT FACE="Courier New">invokevirtual</FONT> instruction, see Chapter 19, &quot;Method Invocation and Return.&quot;</P>
<P><H3><FONT FACE="Courier New">ior</H3></FONT> - Perform boolean OR on <FONT FACE="Courier New">int</FONT>s</P>
<P><H3>Opcode:</H3> 128 (0x80)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">ior</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value1, value2</P></EM></H4>
<P>After:<I>..., result</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The top two words of the operand stack, <I>value1</I> and <I>value2</I>, must be <FONT FACE="Courier New">int</FONT>s. To execute the <FONT FACE="Courier New">ior</FONT> instruction, the Java Virtual Machine pops <I>value1</I> and <I>value2</I>, bitwise ORs them, and pushes the <FONT FACE="Courier New">int</FONT> <I>result</I>.</P>
<P>For more information about the <FONT FACE="Courier New">ior</FONT> instruction, see Chapter 13, &quot;Logic.&quot;</P>
<P><H3><FONT FACE="Courier New">irem</H3></FONT> - Calculate remainder of division of <FONT FACE="Courier New">int</FONT>s</P>
<P><H3>Opcode:</H3> 112 (0x70)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">irem</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value1, value2</P></EM></H4>
<P>After:<I>..., result</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The top two words of the operand stack, <I>value1</I> and <I>value2</I>, must be <FONT FACE="Courier New">int</FONT>s. To execute the <FONT FACE="Courier New">irem</FONT> instruction, the Java Virtual Machine pops <I>value1</I> and <I>value2</I>, calculates the integer remainder, and pushes the <FONT FACE="Courier New">int</FONT> <I>result</I>. The integer remainder equals <I> value1 - (value1 / value2) * value2</I>.</P>
<P>The <FONT FACE="Courier New">irem</FONT> instruction implements Javaís remainder operator: <FONT FACE="Courier New">%</FONT>. The <FONT FACE="Courier New">irem</FONT> behaves such that the Java expression shown below is always <FONT FACE="Courier New">true</FONT>, where <FONT FACE="Courier New">n</FONT> and <FONT FACE="Courier New">d</FONT> are any two <FONT FACE="Courier New">int</FONT>s:</P>
<P><FONT FACE="Courier New">begin</FONT></P>
<FONT FACE="Courier New"><P>(n/d)*d + (n%d) == n</P>
</FONT><P><FONT FACE="Courier New">end</FONT></P>
<P>This behavior means that the <I>result</I> of an <FONT FACE="Courier New">irem</FONT> instruction always takes the same sign as the numerator, which is popped off the operand stack as <I>value1</I>.</P>
<P>If <I>value2</I> (the denominator) is zero, the Java Virtual Machine throws <FONT FACE="Courier New">ArithmeticException</FONT>.</P>
<P>For more information about the <FONT FACE="Courier New">irem</FONT> instruction, see Chapter 12, &quot;Integer Arithmetic.&quot;</P>
<P><H3><FONT FACE="Courier New">ireturn</H3></FONT> - Return <FONT FACE="Courier New">int</FONT> from method</P>
<P><H3>Opcode:</H3> 172 (0xac)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">ireturn</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value</P></EM></H4>
<P>After:<I>[empty]</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The return type of the returning method must be <FONT FACE="Courier New">byte</FONT>, <FONT FACE="Courier New">short</FONT>, <FONT FACE="Courier New">int</FONT>, or <FONT FACE="Courier New">char</FONT>. The top word of the operand stack, <I>value</I>, must be an <FONT FACE="Courier New">int</FONT>. To execute the <FONT FACE="Courier New">ireturn</FONT> instruction, the Java Virtual Machine pops <FONT FACE="Courier New">int</FONT> <I>value</I> from the operand stack of the current frame and pushes it onto the operand stack of the invoking methodís frame. </I>The virtual machine discards any other words that may still be on the returning methodís frame. If the returning method is synchronized, the monitor that was acquired when the method was invoked is released. The invoking methodís frame is made current, and </I>The virtual machine continues execution in the invoking method.</P>
<P>For more information about the <FONT FACE="Courier New">ireturn</FONT> instruction, see Chapter 19, &quot;Method Invocation and Return.&quot; For more information about monitors, see Chapter 20, &quot;Thread Synchronization.&quot;</P>
<P><H3><FONT FACE="Courier New">ishl</H3></FONT> - Perform left shift on <FONT FACE="Courier New">int</FONT></P>
<P><H3>Opcode:</H3> 120 (0x78)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">ishl</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value1, value2</P></EM></H4>
<P>After:<I>..., result</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The top two words of the operand stack, <I>value1</I> and <I>value2</I>, must be <FONT FACE="Courier New">int</FONT>s. To execute the <FONT FACE="Courier New">ishl</FONT> instruction, the Java Virtual Machine pops <I>value1</I> and <I>value2</I>, shifts <I>value1</I> left by the number of bits specified in the 5 lowest order bits of <I>value2</I> (from 0 to 31 bit positions), and pushes the <FONT FACE="Courier New">int</FONT> <I>result</I>.</P>
<P>For more information about the <FONT FACE="Courier New">ishl</FONT> instruction, see Chapter 13, &quot;Logic.&quot;</P>
<P><H3><FONT FACE="Courier New">ishr</H3></FONT> - Perform arithmetic right shift on <FONT FACE="Courier New">int</FONT></P>
<P><H3>Opcode:</H3> 122 (0x7a)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">ishr</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value1, value2</P></EM></H4>
<P>After:<I>..., result</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The top two words of the operand stack, <I>value1</I> and <I>value2</I>, must be <FONT FACE="Courier New">int</FONT>s. To execute the <FONT FACE="Courier New">ishr</FONT> instruction, the Java Virtual Machine pops <I>value1</I> and <I>value2</I>, shifts <I>value1</I> right with sign extension by the number of bits specified in the 5 lowest order bits of <I>value2</I> (from 0 to 31 bit positions), and pushes the <FONT FACE="Courier New">int</FONT> <I>result</I>.</P>
<P>For more information about the <FONT FACE="Courier New">ishr</FONT> instruction, see Chapter 13, &quot;Logic.&quot;</P>
<P><H3><FONT FACE="Courier New">istore</H3></FONT> - Store <FONT FACE="Courier New">int</FONT> into local variable</P>
<P><H3>Opcode:</H3> 54 (0x36)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">istore</FONT>, <I>index</P></EM></H4>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value</P></EM></H4>
<P>After:<I>...</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The <I>index</I> operand must specify a valid 8-bit unsigned index into the local variables of the current frame. The <I>value</I> word on the top of the operand stack must be an <FONT FACE="Courier New">int</FONT>. To execute the <FONT FACE="Courier New">istore</FONT> instruction, the Java Virtual Machine pops the <FONT FACE="Courier New">int</FONT> <I>value</I> from the top of the operand stack and stores it into the local variable word specified by <I>index</I>.</P>
<P>Note that the <FONT FACE="Courier New">wide</FONT> instruction can precede the <FONT FACE="Courier New">istore</FONT> instruction, to enable a <I>value</I> to be stored into a local variable specified by a 16-bit unsigned offset.</P>
<P>For more information about the <FONT FACE="Courier New">istore</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<P><H3><FONT FACE="Courier New">istore_0</H3></FONT> - Store <FONT FACE="Courier New">int</FONT> into local variable 0</P>
<P><H3>Opcode:</H3> 59 (0x3b)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">istore_0</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value</P></EM></H4>
<P>After:<I>...</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The index zero must be a valid index into the local variables of the current stack frame, and the <I>value</I> word on the top of the operand stack must be an <FONT FACE="Courier New">int</FONT>. To execute the <FONT FACE="Courier New">istore_0</FONT> instruction, the Java Virtual Machine pops the <FONT FACE="Courier New">int</FONT> <I>value</I> from the top of the operand stack and stores it into the local variable word at index zero.</P>
<P>For more information about the <FONT FACE="Courier New">istore_0</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<P><H3><FONT FACE="Courier New">istore_1</H3></FONT> - Store <FONT FACE="Courier New">int</FONT> into local variable 1</P>
<P><H3>Opcode:</H3> 60 (0x3c)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">istore_1</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value</P></EM></H4>
<P>After:<I>...</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The index one must be a valid index into the local variables of the current stack frame, and the <I>value</I> word on the top of the operand stack must be an <FONT FACE="Courier New">int</FONT>. To execute the <FONT FACE="Courier New">istore_1</FONT> instruction, the Java Virtual Machine pops the <FONT FACE="Courier New">int</FONT> <I>value</I> from the top of the operand stack and stores it into the local variable word at index one.</P>
<P>For more information about the <FONT FACE="Courier New">istore_1</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<P><H3><FONT FACE="Courier New">istore_2</H3></FONT> - Store <FONT FACE="Courier New">int</FONT> into local variable 2</P>
<P><H3>Opcode:</H3> 61 (0x3d)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">istore_2</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value</P></EM></H4>
<P>After:<I>...</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The index two must be a valid index into the local variables of the current stack frame, and the <I>value</I> word on the top of the operand stack must be an <FONT FACE="Courier New">int</FONT>. To execute the <FONT FACE="Courier New">istore_2</FONT> instruction, the Java Virtual Machine pops the <FONT FACE="Courier New">int</FONT> <I>value</I> from the top of the operand stack and stores it into the local variable word at index two.</P>
<P>For more information about the <FONT FACE="Courier New">istore_2</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<P><H3><FONT FACE="Courier New">istore_3</H3></FONT> - Store <FONT FACE="Courier New">int</FONT> into local variable 3</P>
<P><H3>Opcode:</H3> 62 (0x3e)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">istore_3</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value</P></EM></H4>
<P>After:<I>...</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The index three must be a valid index into the local variables of the current stack frame, and the <I>value</I> word on the top of the operand stack must be an <FONT FACE="Courier New">int</FONT>. To execute the <FONT FACE="Courier New">istore_3</FONT> instruction, the Java Virtual Machine pops the <FONT FACE="Courier New">int</FONT> <I>value</I> from the top of the operand stack and stores it into the local variable word at index three.</P>
<P>For more information about the <FONT FACE="Courier New">istore_3</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<P><H3><FONT FACE="Courier New">isub</H3></FONT> - Subtract <FONT FACE="Courier New">int</FONT>s</P>
<P><H3>Opcode:</H3> 100 (0x64)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">isub</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value1, value2</P></EM></H4>
<P>After:<I>..., result</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The top two words of the operand stack, <I>value1</I> and <I>value2</I>, must be <FONT FACE="Courier New">int</FONT>s. To execute the <FONT FACE="Courier New">isub</FONT> instruction, the Java Virtual Machine pops <I>value1</I> and <I>value2</I>, subtracts <I>value2</I> from <I>value1</I> (<I> value1 - value2</I>), and pushes the <FONT FACE="Courier New">int</FONT> <I>result</I>. If overflow occurs, <I>result</I> is the 32 lowest order bits of the true mathematical result represented in a sufficiently wide twoís-complement format, and the sign bit of <I>result</I> may be different from the true mathematical result.</P>
<P>For more information about the <FONT FACE="Courier New">isub</FONT> instruction, see Chapter 12, &quot;Integer Arithmetic.&quot;</P>
<P><H3><FONT FACE="Courier New">iushr</H3></FONT> - Perform logical right shift on <FONT FACE="Courier New">int</FONT></P>
<P><H3>Opcode:</H3> 124 (0x7c)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">iushr</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value1, value2</P></EM></H4>
<P>After:<I>..., result</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The top two words of the operand stack, <I>value1</I> and <I>value2</I>, must be <FONT FACE="Courier New">int</FONT>s. To execute the <FONT FACE="Courier New">iushr</FONT> instruction, the Java Virtual Machine pops <I>value1</I> and <I>value2</I>, shifts <I>value1</I> right with zero extension by the number of bits specified in the 5 lowest order bits of <I>value2</I> (from 0 to 31 bit positions), and pushes the <FONT FACE="Courier New">int</FONT> <I>result</I>.</P>
<P>For more information about the <FONT FACE="Courier New">iushr</FONT> instruction, see Chapter 13, &quot;Logic.&quot;</P>
<P><H3><FONT FACE="Courier New">ixor</H3></FONT> - Perform boolean XOR on <FONT FACE="Courier New">int</FONT>s</P>
<P><H3>Opcode:</H3> 130 (0x82)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">ixor</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value1, value2</P></EM></H4>
<P>After:<I>..., result</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The top two words of the operand stack, <I>value1</I> and <I>value2</I>, must be <FONT FACE="Courier New">int</FONT>s. To execute the <FONT FACE="Courier New">ixor</FONT> instruction, the Java Virtual Machine pops <I>value1</I> and <I>value2</I>, bitwise exclusive ORs them, and pushes the <FONT FACE="Courier New">int</FONT> <I>result</I>.</P>
<P>For more information about the <FONT FACE="Courier New">ixor</FONT> instruction, see Chapter 13, &quot;Logic.&quot;</P>
<P><H3><FONT FACE="Courier New">jsr</H3></FONT> - Jump to subroutine</P>
<P><H3>Opcode:</H3> 168 (0xa8)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">jsr</FONT>, <I>branchbyte1</I>, <I>branchbyte2</P></EM></H4>
<P><H3>Stack:</H3></P>
<P>Before:<I>...</P></EM></H4>
<P>After:<I>..., address</P></EM></H4>
<P><H3>Description:</H3></P>
<P>To execute the <FONT FACE="Courier New">jsr</FONT> instruction, the Java Virtual Machine pushes the (program counter) address of the opcode immediately following the <FONT FACE="Courier New">jsr</FONT> instruction, the <I>address</I> word, onto the operand stack. </I>The virtual machine then forms a signed 16-bit offset by calculating <I>(branchbyte1 <FONT FACE="Courier New"> 8) | branchbyte2</I>. It calculates a target (program counter) address by adding the calculated offset to the address of the <FONT FACE="Courier New">jsr</FONT> opcode. The target address must be the address of an opcode within the same method as the <FONT FACE="Courier New">jsr</FONT> opcode. </I>The virtual machine jumps to the target address and continues execution there.</P>
<P>For more information about the <FONT FACE="Courier New">jsr</FONT> instruction, see Chapter 18, &quot;Finally Clauses.&quot;</P>
<P><H3><FONT FACE="Courier New">jsr_w</H3></FONT> - Jump to subroutine (wide index)</P>
<P><H3>Opcode:</H3> 201 (0xc9)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">jsr_w</FONT>, <I>branchbyte1</I>, <I>branchbyte2</I>, <I>branchbyte3</I>, <I>branchbyte4</P></EM></H4>
<P><H3>Stack:</H3></P>
<P>Before:<I>...</P></EM></H4>
<P>After:<I>..., address</P></EM></H4>
<P><H3>Description:</H3></P>
<P>To execute the <FONT FACE="Courier New">jsr_w</FONT> instruction, the Java Virtual Machine pushes the (program counter) address of the opcode immediately following the <FONT FACE="Courier New">jsr_w</FONT> instruction, the <I>address</I> word, onto the operand stack. </I>The virtual machine then forms a signed 32-bit offset by calculating <I>(branchbyte1 <FONT FACE="Courier New"> 24) | (branchbyte2 <FONT FACE="Courier New"> 16) | (branchbyte3 </FONT><FONT FACE="Courier New"> 8) | branchbyte4</FONT></I>. </I>The virtual machine then calculates a target (program counter) address by adding the calculated offset to the address of the <FONT FACE="Courier New">jsr_w</FONT> opcode. The target address must be the address of an opcode within the same method as the <FONT FACE="Courier New">jsr_w</FONT> opcode. </I>The virtual machine jumps to the target address and continues execution there.</P>
<P>Note that despite the 32-bit offset of the <FONT FACE="Courier New">jsr_w</FONT> instruction, Java methods are currently (in both the 1.0 and 1.1 releases) limited to 65,535 bytes by three items in the Java class file format: the sizes of the indexes in the <FONT FACE="Courier New">LineNumberTable</FONT> attribute, the <FONT FACE="Courier New">LocalVariableTable</FONT> attribute, and the <FONT FACE="Courier New">Code</FONT> attributeís <FONT FACE="Courier New">exception_table</FONT> item. According to the Java Virtual Machine specification, the 65,536 byte limit to Java methods may be raised in a future release. For more information about the <FONT FACE="Courier New">jsr_w</FONT> instruction, see Chapter 18, &quot;Finally Clauses.&quot;</P>
<P><H3><FONT FACE="Courier New">l2d</H3></FONT> - Convert <FONT FACE="Courier New">long</FONT> to <FONT FACE="Courier New">double</FONT></P>
<P><H3>Opcode:</H3> 138 (0x8a)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">l2d</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value.word1, value.word2</P></EM></H4>
<P>After:<I>..., result.word1, result.word2</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The top two words of the operand stack must be a <FONT FACE="Courier New">long</FONT>. To execute the <FONT FACE="Courier New">l2d</FONT> instruction, the Java Virtual Machine pops the <FONT FACE="Courier New">long</FONT> <I>value</I> from the operand stack, converts the <FONT FACE="Courier New">long</FONT> to a <FONT FACE="Courier New">double</FONT> using the IEEE round-to-nearest mode, and pushes the <FONT FACE="Courier New">double</FONT> <I>result</I>.</P>
<P>Note that this instruction performs a widening primitive conversion. Because not all <FONT FACE="Courier New">long</FONT> values are exactly representable by a <FONT FACE="Courier New">double</FONT>, the conversion may result in a loss of precision.</P>
<P>For more information about the <FONT FACE="Courier New">l2d</FONT> instruction, see Chapter 11, &quot;Type Conversion.&quot;</P>
<P><H3><FONT FACE="Courier New">l2f</H3></FONT> - Convert <FONT FACE="Courier New">long</FONT> to <FONT FACE="Courier New">float</FONT></P>
<P><H3>Opcode:</H3> 137 (0x89)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">l2f</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value.word1, value.word2</P></EM></H4>
<P>After:<I>..., result</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The top two words of the operand stack must be a <FONT FACE="Courier New">long</FONT>. To execute the <FONT FACE="Courier New">l2f</FONT> instruction, the Java Virtual Machine pops the <FONT FACE="Courier New">long</FONT> <I>value</I> from the operand stack, converts the <FONT FACE="Courier New">long</FONT> to a <FONT FACE="Courier New">float</FONT> using the IEEE round-to-nearest mode, and pushes the <FONT FACE="Courier New">float</FONT> <I>result</I>.</P>
<P>Note that this instruction performs a widening primitive conversion. Because not all <FONT FACE="Courier New">long</FONT> values are exactly representable by a <FONT FACE="Courier New">float</FONT>, the conversion may result in a loss of precision.</P>
<P>For more information about the <FONT FACE="Courier New">l2f</FONT> instruction, see Chapter 11, &quot;Type Conversion.&quot;</P>
<P><H3><FONT FACE="Courier New">l2i</H3></FONT> - Convert <FONT FACE="Courier New">long</FONT> to <FONT FACE="Courier New">int</FONT></P>
<P><H3>Opcode:</H3> 136 (0x88)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">l2i</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value.word1, value.word2</P></EM></H4>
<P>After:<I>..., result</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The top two words of the operand stack must be a <FONT FACE="Courier New">long</FONT>. To execute the <FONT FACE="Courier New">l2i</FONT> instruction, the Java Virtual Machine pops <FONT FACE="Courier New">long</FONT> <I>value</I> from the operand stack, truncates the <FONT FACE="Courier New">long</FONT> to a <FONT FACE="Courier New">int</FONT>, and pushes the <FONT FACE="Courier New">int</FONT> <I>result</I>.</P>
<P>Note that this instruction performs a narrowing primitive conversion. As a result of this conversion, magnitude information may be lost and the sign bit may change.</P>
<P>For more information about the <FONT FACE="Courier New">l2i</FONT> instruction, see Chapter 11, &quot;Type Conversion.&quot;</P>
<P><H3><FONT FACE="Courier New">ladd</H3></FONT> - Add <FONT FACE="Courier New">long</FONT>s</P>
<P><H3>Opcode:</H3> 97 (0x61)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">ladd</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value1.word1, value1.word2, value2.word1, value2.word2</P></EM></H4>
<P>After:<I>..., result.word1, result.word2</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The top four words of the operand stack must be two <FONT FACE="Courier New">long</FONT>s, <I>value1</I> and <I>value2</I>. To execute the <FONT FACE="Courier New">ladd</FONT> instruction, the Java Virtual Machine pops <I>value1</I> and <I>value2</I>, adds them, and pushes the <FONT FACE="Courier New">long</FONT> <I>result</I>. If overflow occurs, <I>result</I> is the 64 lowest order bits of the true mathematical result represented in a sufficiently wide twoís-complement format, and the sign of <I>result</I> is different from that of the true mathematical result.</P>
<P>For more information about the <FONT FACE="Courier New">ladd</FONT> instruction, see Chapter 12, &quot;Integer Arithmetic.&quot;</P>
<P><H3><FONT FACE="Courier New">laload</H3></FONT> - Load <FONT FACE="Courier New">long</FONT> from array</P>
<P><H3>Opcode:</H3> 47 (0x2f)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">laload</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., arrayref, index</P></EM></H4>
<P>After:<I>..., value.word1, value.word2</P></EM></H4>
<P><H3>Description:</H3></P>
<P>To execute the <FONT FACE="Courier New">laload</FONT> instruction, the Java Virtual Machine first pops two words from the operand stack. The <I>arrayref</I> word must be a <FONT FACE="Courier New">reference</FONT> that refers to an array of <FONT FACE="Courier New">long</FONT>s. The <I>index</I> word must be an <FONT FACE="Courier New">int</FONT>. </I>The virtual machine retrieves from the <I>arrayref</I> array the <FONT FACE="Courier New">long</FONT> <I>value</I> specified by <I>index</I> and pushes it onto the operand stack.</P>
<P>If <I>arrayref</I> is <FONT FACE="Courier New">null</FONT>, the Java Virtual Machine throws <FONT FACE="Courier New">NullPointerException</FONT>. Otherwise, if <I>index</I> is not a legal index into the <I>arrayref</I> array, </I>The virtual machine throws <FONT FACE="Courier New">ArrayIndexOutOfBoundsException</FONT>.</P>
<P>For more information about the <FONT FACE="Courier New">laload</FONT> instruction, see Chapter 15, &quot;Objects and Arrays.&quot;</P>
<P><H3><FONT FACE="Courier New">land</H3></FONT> - Perform boolean AND on <FONT FACE="Courier New">long</FONT>s</P>
<P><H3>Opcode:</H3> 127 (0x7f)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">land</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value1.word1, value1.word2, value2.word1, value2.word2</P></EM></H4>
<P>After:<I>..., result.word1, result.word2</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The top four words of the operand stack must be two <FONT FACE="Courier New">long</FONT>s, <I>value1</I> and <I>value2</I>. To execute the <FONT FACE="Courier New">land</FONT> instruction, the Java Virtual Machine pops <I>value1</I> and <I>value2</I>, bitwise ANDs them, and pushes the <FONT FACE="Courier New">long</FONT> <I>result</I>.</P>
<P>For more information about the <FONT FACE="Courier New">land</FONT> instruction, see Chapter 13, &quot;Logic.&quot;</P>
<P><H3><FONT FACE="Courier New">lastore</H3></FONT> - Store into <FONT FACE="Courier New">long</FONT> array</P>
<P><H3>Opcode:</H3> 80 (0x50)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">lastore</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., arrayref, index, value.word1, value.word2</P></EM></H4>
<P>After:<I>...</P></EM></H4>
<P><H3>Description:</H3></P>
<P>To execute the <FONT FACE="Courier New">laload</FONT> instruction, the Java Virtual Machine first pops four words from the operand stack. The <I>arrayref</I> word must be a <FONT FACE="Courier New">reference</FONT> that refers to an array of <FONT FACE="Courier New">long</FONT>s. The <I>index</I> word must be an <FONT FACE="Courier New">int</FONT>, and the <I>value</I> words must be a <FONT FACE="Courier New">long</FONT>. </I>The virtual machine stores <FONT FACE="Courier New">long</FONT> <I>value</I> into the <I>arrayref</I> array location specified by <I>index</I>.</P>
<P>If <I>arrayref</I> is <FONT FACE="Courier New">null</FONT>, the Java Virtual Machine throws <FONT FACE="Courier New">NullPointerException</FONT>. Otherwise, if <I>index</I> is not a legal index into the <I>arrayref</I> array, </I>The virtual machine throws <FONT FACE="Courier New">ArrayIndexOutOfBoundsException</FONT>.</P>
<P>For more information about the <FONT FACE="Courier New">lastore</FONT> instruction, see Chapter 15, &quot;Objects and Arrays.&quot;</P>
<P><H3><FONT FACE="Courier New">lcmp</H3></FONT> - Compare <FONT FACE="Courier New">long</FONT>s</P>
<P><H3>Opcode:</H3> 148 (0x94)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">lcmp</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value1.word1, value1.word2, value2.word1, value2.word2</P></EM></H4>
<P>After:<I>..., result</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The top four words of the operand stack must be two <FONT FACE="Courier New">long</FONT>s, <I>value1</I> and <I>value2</I>. To execute the <FONT FACE="Courier New">lcmp</FONT> instruction, the Java Virtual Machine pops <I>value1</I> and <I>value2</I> off the operand stack and compares one against the other. If <I>value1</I> equals <I>value2</I>, </I>The virtual machine pushes onto the operand stack <FONT FACE="Courier New">int</FONT> <I>result</I> zero. Else, if <I>value1</I> is greater than <I>value2</I>, </I>The virtual machine pushes onto the operand stack <FONT FACE="Courier New">int</FONT> <I>result</I> one. Otherwise, if <I>value1</I> is less than <I>value2</I>, </I>The virtual machine pushes onto the operand stack <FONT FACE="Courier New">int</FONT> <I>result</I> negative one.</P>
<P>For more information about the <FONT FACE="Courier New">lcmp</FONT> instruction, see Chapter 16, &quot;Control Flow.&quot;</P>
<P><H3><FONT FACE="Courier New">lconst_0</H3></FONT> - Push <FONT FACE="Courier New">long</FONT> constant 0</P>
<P><H3>Opcode:</H3> 9 (0x9)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">lconst_0</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>...</P></EM></H4>
<P>After:<I>..., &lt;0</FONT>-word1, &lt;0</FONT>-word2</P></EM></H4>
<P><H3>Description:</H3></P>
<P>To execute the <FONT FACE="Courier New">lconst_0</FONT> instruction, the Java Virtual Machine pushes the <FONT FACE="Courier New">long</FONT> constant 0 onto the operand stack.</P>
<P>For more information about the <FONT FACE="Courier New">lconst_0</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<P><H3><FONT FACE="Courier New">lconst_1</H3></FONT> - Push <FONT FACE="Courier New">long</FONT> constant 1</P>
<P><H3>Opcode:</H3> 10 (0xa)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">lconst_1</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>...</P></EM></H4>
<P>After:<I>..., &lt;1</FONT>-word1, &lt;1</FONT>-word2</P></EM></H4>
<P><H3>Description:</H3></P>
<P>To execute the <FONT FACE="Courier New">lconst_1</FONT> instruction, the Java Virtual Machine pushes the <FONT FACE="Courier New">long</FONT> constant 1 onto the operand stack.</P>
<P>For more information about the <FONT FACE="Courier New">lconst_1</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<P><H3><FONT FACE="Courier New">ldc</H3></FONT> - Push item from constant pool</P>
<P><H3>Opcode:</H3> 18 (0x12)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">ldc</FONT>, <I>index</P></EM></H4>
<P><H3>Stack:</H3></P>
<P>Before:<I>...</P></EM></H4>
<P>After:<I>..., item</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The <I>index</I> operand must be a valid unsigned 8-bit index into the current constant pool. To execute the <FONT FACE="Courier New">ldc</FONT> instruction, the Java Virtual Machine first looks up the constant pool entry specified by the <I>index</I> operand. At constant pool entry <I>index</I>, </I>The virtual machine must find either a <FONT FACE="Courier New">CONSTANT_Integer_info</FONT>, <FONT FACE="Courier New">CONSTANT_Float_info</FONT>, or <FONT FACE="Courier New">CONSTANT_String_info</FONT> entry. If it hasnít already, </I>The virtual machine resolves the entry. If the entry is a <FONT FACE="Courier New">CONSTANT_Integer_info</FONT>, </I>The virtual machine pushes the <FONT FACE="Courier New">int</FONT> value represented by the entry onto the operand stack. Else, if the entry is a <FONT FACE="Courier New">CONSTANT_Float_info</FONT>, </I>The virtual machine pushes the <FONT FACE="Courier New">float</FONT> value represented by the entry onto the operand stack. Otherwise, the entry is a  <FONT FACE="Courier New">CONSTANT_String_info</FONT> entry, and </I>The virtual machine pushes a reference to the interned <FONT FACE="Courier New">String</FONT> object that was produced by the process of resolving the entry onto the operand stack.</P>
<P>Note that the <FONT FACE="Courier New">ldc_w</FONT> instruction performs the same function, but offers a wide (16-bit) constant pool index.</P>
<P>For more information about the <FONT FACE="Courier New">ldc</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<P><H3><FONT FACE="Courier New">ldc_w</H3></FONT> - Push item from constant pool (wide index)</P>
<P><H3>Opcode:</H3> 19 (0x13)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">ldc_w</FONT>, <I>indexbyte1</I>, <I>indexbyte2</P></EM></H4>
<P><H3>Stack:</H3></P>
<P>Before:<I>...</P></EM></H4>
<P>After:<I>..., item</P></EM></H4>
<P><H3>Description:</H3></P>
<P>To execute the <FONT FACE="Courier New">ldc_w</FONT> instruction, the Java Virtual Machine first forms an unsigned 16-bit index into the constant pool by calculating <I>(indexbyte1 <FONT FACE="Courier New"> 8) | indexbyte2</I>. </I>The virtual machine then looks up the constant pool entry specified by the calculated index. The constant pool entry at that index must be either a <FONT FACE="Courier New">CONSTANT_Integer_info</FONT>, a <FONT FACE="Courier New">CONSTANT_Float_info</FONT>, or a <FONT FACE="Courier New">CONSTANT_String_info</FONT> entry. If it hasnít already, </I>The virtual machine resolves the entry. If the entry is a <FONT FACE="Courier New">CONSTANT_Integer_info</FONT>, </I>The virtual machine pushes the <FONT FACE="Courier New">int</FONT> value represented by the entry onto the operand stack. Else, if the entry is a <FONT FACE="Courier New">CONSTANT_Float_info</FONT>, </I>The virtual machine pushes the <FONT FACE="Courier New">float</FONT> value it represents onto the operand stack. Otherwise, the entry is a  <FONT FACE="Courier New">CONSTANT_String_info</FONT>, and </I>The virtual machine pushes a reference to the interned <FONT FACE="Courier New">String</FONT> object that was produced by the process of resolving the entry onto the operand stack. </P>
<P>Note that the <FONT FACE="Courier New">ldc_w</FONT> instruction performs the same function as <FONT FACE="Courier New">ldc</FONT>, but offers a wide (16-bit) constant pool index as opposed to <FONT FACE="Courier New">ldc</FONT>ís 8-bit constant pool index.</P>
<P>For more information about the <FONT FACE="Courier New">ldc_w</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<P><H3><FONT FACE="Courier New">ldc2_w</H3></FONT> - Push <FONT FACE="Courier New">long</FONT> or <FONT FACE="Courier New">double</FONT> from constant pool (wide index)</P>
<P><H3>Opcode:</H3> 20 (0x14)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">ldc2_w</FONT>, <I>indexbyte1</I>, <I>indexbyte2</P></EM></H4>
<P><H3>Stack:</H3></P>
<P>Before:<I>...</P></EM></H4>
<P>After:<I>..., item.word1, item.word2</P></EM></H4>
<P><H3>Description:</H3></P>
<P>To execute the <FONT FACE="Courier New">ldc2_w</FONT> instruction, the Java Virtual Machine first forms an unsigned 16-bit index into the constant pool by calculating <I>(indexbyte1 <FONT FACE="Courier New"> 8) | indexbyte2</I>. </I>The virtual machine then looks up the constant pool entry specified by the calculated index. The constant pool entry at that index must be either a <FONT FACE="Courier New">CONSTANT_Long_info</FONT> or <FONT FACE="Courier New">CONSTANT_Double_info</FONT> entry. </I>The virtual machine resolves the entry. If the entry is a <FONT FACE="Courier New">CONSTANT_Long_info</FONT>, </I>The virtual machine pushes the <FONT FACE="Courier New">long</FONT> value represented by the entry onto the operand stack. Otherwise, it is a <FONT FACE="Courier New">CONSTANT_Double_info</FONT> entry, and </I>The virtual machine pushes the <FONT FACE="Courier New">double</FONT> value represented by the entry onto the operand stack.</P>
<P>Note that there is no &quot;<FONT FACE="Courier New">ldc2</FONT>&quot; instruction that performs the same function as <FONT FACE="Courier New">ldc2_w</FONT> but with an 8-bit constant pool index. All two-word constants must be retrieved from the constant pool with an <FONT FACE="Courier New">ldc2_w</FONT> instruction, which has a wide (16-bit) constant pool index.</P>
<P>For more information about the <FONT FACE="Courier New">ldc2_w</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<P><H3><FONT FACE="Courier New">ldiv</H3></FONT> - Divide <FONT FACE="Courier New">long</FONT>s</P>
<P><H3>Opcode:</H3> 109 (0x6d)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">ldiv</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value1.word1, value1.word2, value2.word1, value2.word2</P></EM></H4>
<P>After:<I>..., result.word1, result.word2</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The top four words of the operand stack must be two <FONT FACE="Courier New">long</FONT>s, <I>value1</I> and <I>value2</I>. To execute the <FONT FACE="Courier New">ldiv</FONT> instruction, the Java Virtual Machine pops <I>value1</I> and <I>value2</I>, integer divides <I>value1</I> by <I>value2</I> (<I> value1 / value2</I>), and pushes the <FONT FACE="Courier New">long</FONT> <I>result</I>.</P>
<P>Integer division rounds the magnitude of the true mathematical quotient towards zero to the nearest integer. If the magnitude of the denominator is greater than that of the numerator, the <FONT FACE="Courier New">long</FONT> <I>result</I> is zero. Else, with one special exception, the sign of <I>result</I> is positive if the signs of the numerator and denominator are the same, negative if they are different. The exception to this rule is when the numerator is the smallest negative integer that can be represented by a <FONT FACE="Courier New">long</FONT> and the denominator is -1. For this division, the true mathematical result is one greater than the largest positive integer that can be represented by a <FONT FACE="Courier New">long</FONT>. As a consequence, the division overflows and the result is equal to the numerator.</P>
<P>If <I>value2</I> (the denominator) is zero, the Java Virtual Machine throws <FONT FACE="Courier New">ArithmeticException</FONT>.</P>
<P>For more information about the <FONT FACE="Courier New">ldiv</FONT> instruction, see Chapter 12, &quot;Integer Arithmetic.&quot;</P>
<P><H3><FONT FACE="Courier New">lload</H3></FONT> - Load <FONT FACE="Courier New">long</FONT> from local variable</P>
<P><H3>Opcode:</H3> 22 (0x16)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">lload</FONT>, <I>index</P></EM></H4>
<P><H3>Stack:</H3></P>
<P>Before:<I>...</P></EM></H4>
<P>After:<I>..., value.word1, value.word2</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The <I>index</I> operand, which serves as an 8-bit unsigned index into the local variables of the current frame, must specify the first of two consecutive local variable words that contain a <FONT FACE="Courier New">long</FONT>. To execute the <FONT FACE="Courier New">lload</FONT> instruction, the Java Virtual Machine pushes onto the operand stack the <FONT FACE="Courier New">long</FONT> contained in the two consecutive local variable words specified by <I>index</I> and <I>index + 1</I>.</P>
<P>Note that the <FONT FACE="Courier New">wide</FONT> instruction can precede the <FONT FACE="Courier New">lload</FONT> instruction, to allow a local variable to be accessed with a 16-bit unsigned offset.</P>
<P>For more information about the <FONT FACE="Courier New">lload</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<P><H3><FONT FACE="Courier New">lload_0</H3></FONT> - Load <FONT FACE="Courier New">long</FONT> from local variable 0</P>
<P><H3>Opcode:</H3> 30 (0x1e)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">lload_0</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>...</P></EM></H4>
<P>After:<I>..., value.word1, value.word2</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The two consecutive local variable words at indexes zero and one must contain a <FONT FACE="Courier New">long</FONT>. To execute the <FONT FACE="Courier New">lload_0</FONT> instruction, the Java Virtual Machine pushes onto the operand stack the <FONT FACE="Courier New">long</FONT> <I>value</I> contained in local variable words zero and one.</P>
<P> For more information about the <FONT FACE="Courier New">lload_0</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<P><H3><FONT FACE="Courier New">lload_1</H3></FONT> - Load <FONT FACE="Courier New">long</FONT> from local variable 1</P>
<P><H3>Opcode:</H3> 31 (0x1f)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">lload_1</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>...</P></EM></H4>
<P>After:<I>..., value.word1, value.word2</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The two consecutive local variable words at indexes one and two must contain a <FONT FACE="Courier New">long</FONT>. To execute the <FONT FACE="Courier New">lload_1</FONT> instruction, the Java Virtual Machine pushes onto the operand stack the <FONT FACE="Courier New">long</FONT> <I>value</I> contained in local variable words one and two.</P>
<P>For more information about the <FONT FACE="Courier New">lload_1</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<P><H3><FONT FACE="Courier New">lload_2</H3></FONT> - Load <FONT FACE="Courier New">long</FONT> from local variable 2</P>
<P><H3>Opcode:</H3> 32 (0x20)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">lload_2</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>...</P></EM></H4>
<P>After:<I>..., value.word1, value.word2</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The two consecutive local variable words at indexes two and three must contain a <FONT FACE="Courier New">long</FONT>. To execute the <FONT FACE="Courier New">lload_2</FONT> instruction, the Java Virtual Machine pushes onto the operand stack the <FONT FACE="Courier New">long</FONT> <I>value</I> contained in local variable words two and three.</P>
<P>For more information about the <FONT FACE="Courier New">lload_2</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<P><H3><FONT FACE="Courier New">lload_3</H3></FONT> - Load <FONT FACE="Courier New">long</FONT> from local variable 3</P>
<P><H3>Opcode:</H3> 33 (0x21)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">lload_3</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>...</P></EM></H4>
<P>After:<I>..., value.word1, value.word2</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The two consecutive local variable words at indexes three and four must contain a <FONT FACE="Courier New">long</FONT>. To execute the <FONT FACE="Courier New">lload_3</FONT> instruction, the Java Virtual Machine pushes onto the operand stack the <FONT FACE="Courier New">long</FONT> <I>value</I> contained in local variable words three and four.</P>
<P>For more information about the <FONT FACE="Courier New">lload_3</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<P><H3><FONT FACE="Courier New">lmul</H3></FONT> - Multiply <FONT FACE="Courier New">long</FONT>s</P>
<P><H3>Opcode:</H3> 105 (0x69)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">lmul</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value1.word1, value1.word2, value2.word1, value2.word2</P></EM></H4>
<P>After:<I>..., result.word1, result.word2</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The top four words of the operand stack must be two <FONT FACE="Courier New">long</FONT>s, <I>value1</I> and <I>value2</I>. To execute the <FONT FACE="Courier New">lmul</FONT> instruction, the Java Virtual Machine pops <I>value1</I> and <I>value2</I>, multiplies them, and pushes the <FONT FACE="Courier New">long</FONT> <I>result</I>. If overflow occurs, <I>result</I> is the 64 lowest order bits of the true mathematical result represented in a sufficiently wide twoís-complement format, and the sign of <I>result</I> may be different from that of the true mathematical result.</P>
<P>For more information about the <FONT FACE="Courier New">lmul</FONT> instruction, see Chapter 12, &quot;Integer Arithmetic.&quot;</P>
<P><H3><FONT FACE="Courier New">lneg</H3></FONT> - Negate <FONT FACE="Courier New">long</FONT></P>
<P><H3>Opcode:</H3> 117 (0x75)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">lneg</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value.word1, value.word2</P></EM></H4>
<P>After:<I>..., result.word1, result.word2</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The top two words of the operand stack must be a <FONT FACE="Courier New">long</FONT>, <I>value</I>. To execute the <FONT FACE="Courier New">lneg</FONT> instruction, the Java Virtual Machine pops <I>value</I>, negates it, and pushes the <FONT FACE="Courier New">long</FONT> <I>result</I>.</P>
<P>The <I>result</I> produced by an <FONT FACE="Courier New">lneg</FONT> instruction is the same number that would be produced by subtracting <I>value</I> from zero with the <FONT FACE="Courier New">lsub</FONT> instruction. As a consequence, when <I>value</I> is the smallest negative integer that can be represented by an <FONT FACE="Courier New">long</FONT>, the negation overflows. For this negation, the true mathematical result is one greater than the largest positive integer that can be represented by an <FONT FACE="Courier New">long</FONT>, and the actual <I>result</I> is equal to <I>value</I> with no change in sign.</P>
<P>For more information about the <FONT FACE="Courier New">lneg</FONT> instruction, see Chapter 12, &quot;Integer Arithmetic.&quot;</P>
<P><H3><FONT FACE="Courier New">lookupswitch</H3></FONT> - Access jump table by key match and jump</P>
<P><H3>Opcode:</H3> 171 (0xab)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">lookupswitch</FONT>, <I>...0-3 byte pad...</I>, <I>defaultbyte1</I>, <I>defaultbyte2</I>, <I>defaultbyte3</I>, <I>defaultbyte4</I>, <I>npairs1</I>, <I>npairs2</I>, <I>npairs3</I>, <I>npairs4</I>, <I>..match-offset pairs..</P></EM></H4>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., key</P></EM></H4>
<P>After:<I>...</P></EM></H4>
<P><H3>Description:</H3></P>
<H3><P></H3>The <CODE>lookupswitch</CODE> opcode is followed by zero to three bytes of padding--enough so that the byte immediately following the padding starts at an address that is a multiple of four bytes from the beginning of the method. Each padding byte is a zero. Immediately following the padding is a signed 32-bit default branch offset, <I>default</I>. Following <I>default</I> is <I>npairs</I>, a signed count of the number of case value/branch offset pairs embedded in this <CODE>lookupswitch instruction. The value of </CODE><I>npairs</I> must be greater than or equal to zero. Following <I>npairs</I> are the case value/branch offset pairs themselves. For each pair, the signed 32-bit case value, <I>match</I>, precedes the signed 32-bit branch offset, <I>offset</I>. </I>The virtual machine calculates all of these signed 32-bit values from the four individual bytes as <I>(byte1 <FONT FACE="Courier New"> 24) | (byte2 <FONT FACE="Courier New"> 16) | (byte3 </FONT><FONT FACE="Courier New"> 8) | byte4</FONT></I>.</P>
</I><P>The top word of the operand stack, <I>key</I>, must be an <FONT FACE="Courier New">int</FONT>. To execute the <CODE>lookupswitch instruction, the Java Virtual Machine pops </CODE><I>key</I> off the operand stack and compares it to the <I>match</I> values. If the key is equal to one of the <I>match</I> values, </I>The virtual machine calculates a target (program counter) address by adding the signed <I>offset</I> that corresponds to the matching <I>match</I> value to the address of the <FONT FACE="Courier New">lookupswitch</FONT> opcode. The target address must be the address of an opcode within the same method as the <FONT FACE="Courier New">lookupswitch</FONT> opcode. </I>The virtual machine jumps to the target address and continues execution there.</P>
<P>For more information about the <FONT FACE="Courier New">lookupswitch</FONT> instruction, see Chapter 16, &quot;Control Flow.&quot;</P>
<P><H3><FONT FACE="Courier New">lor</H3></FONT> - Perform boolean OR on <FONT FACE="Courier New">long</FONT>s</P>
<P><H3>Opcode:</H3> 129 (0x81)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">lor</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value1.word1, value1.word2, value2.word1, value2.word2</P></EM></H4>
<P>After:<I>..., result.word1, result.word2</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The top four words of the operand stack must be two <FONT FACE="Courier New">long</FONT>s, <I>value1</I> and <I>value2</I>. To execute the <FONT FACE="Courier New">lor</FONT> instruction, the Java Virtual Machine pops <I>value1</I> and <I>value2</I>, bitwise ORs them, and pushes the <FONT FACE="Courier New">long</FONT> <I>result</I>.</P>
<P>For more information about the <FONT FACE="Courier New">lor</FONT> instruction, see Chapter 13, &quot;Logic.&quot;</P>
<P><H3><FONT FACE="Courier New">lrem</H3></FONT> - Calculate remainder of division of <FONT FACE="Courier New">long</FONT>s</P>
<P><H3>Opcode:</H3> 113 (0x71)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">lrem</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value1.word1, value1.word2, value2.word1, value2.word2</P></EM></H4>
<P>After:<I>..., result.word1, result.word2</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The top four words of the operand stack must be two <FONT FACE="Courier New">long</FONT>s, <I>value1</I> and <I>value2</I>. To execute the <FONT FACE="Courier New">lrem</FONT> instruction, the Java Virtual Machine pops <I>value1</I> and <I>value2</I>, calculates the integer remainder, and pushes the <FONT FACE="Courier New">long</FONT> <I>result</I>. The integer remainder equals <I> value1 - (value1 / value2) * value2</I>.</P>
<P>The <FONT FACE="Courier New">lrem</FONT> instruction implements Javaís remainder operator, <FONT FACE="Courier New">%</FONT>, on <FONT FACE="Courier New">long</FONT>s. The <FONT FACE="Courier New">lrem</FONT> behaves such that the Java expression shown below is always <FONT FACE="Courier New">true</FONT>, where <FONT FACE="Courier New">n</FONT> and <FONT FACE="Courier New">d</FONT> are any two <FONT FACE="Courier New">long</FONT>s:</P>
<P><FONT FACE="Courier New">begin</FONT></P>
<FONT FACE="Courier New"><P>(n/d)*d + (n%d) == n</P>
</FONT><P><FONT FACE="Courier New">end</FONT></P>
<P>This behavior means that the <I>result</I> of an <FONT FACE="Courier New">lrem</FONT> instruction always takes the same sign as the numerator, which is popped off the operand stack as <I>value1</I>.</P>
<P>If <I>value2</I> (the denominator) is zero, the Java Virtual Machine throws <FONT FACE="Courier New">ArithmeticException</FONT>.</P>
<P>For more information about the <FONT FACE="Courier New">lrem</FONT> instruction, see Chapter 12, &quot;Integer Arithmetic.&quot;</P>
<P><H3><FONT FACE="Courier New">lreturn</H3></FONT> - Return <FONT FACE="Courier New">long</FONT> from method</P>
<P><H3>Opcode:</H3> 173 (0xad)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">lreturn</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value.word1, value.word2</P></EM></H4>
<P>After:<I>[empty]</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The return type of the returning method must be <FONT FACE="Courier New">long</FONT>. The top two words of the operand stack must be a <FONT FACE="Courier New">long</FONT>. To execute the <FONT FACE="Courier New">lreturn</FONT> instruction, the Java Virtual Machine pops the <FONT FACE="Courier New">long</FONT> <I>value</I> from the operand stack of the current frame and pushes it onto the operand stack of the invoking methodís frame. </I>The virtual machine discards any other words that may still be on the returning methodís frame. If the returning method is synchronized, the monitor that was acquired when the method was invoked is released. The invoking methodís frame is made current, and </I>The virtual machine continues execution in the invoking method.</P>
<P>For more information about monitors, see Chapter 20, &quot;Thread Synchronization.&quot; For more information about the <FONT FACE="Courier New">lreturn</FONT> instruction, see Chapter 19, &quot;Method Invocation and Return.&quot;</P>
<P><H3><FONT FACE="Courier New">lshl</H3></FONT> - Perform left shift on <FONT FACE="Courier New">long</FONT></P>
<P><H3>Opcode:</H3> 121 (0x79)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">lshl</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value1.word1, value1.word2, value2</P></EM></H4>
<P>After:<I>..., result.word1, result.word2</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The top word of the operand stack, <I>value2</I>, must be an <FONT FACE="Courier New">int</FONT>. The next two words down must be a <FONT FACE="Courier New">long</FONT>, <I>value1</I>. To execute the <FONT FACE="Courier New">lshl</FONT> instruction, the Java Virtual Machine pops <I>value1</I> and <I>value2</I>, shifts <I>value1</I> left by the number of bits specified in the 6 lowest order bits of <I>value2</I> (from 0 to 63 bit positions), and pushes the <FONT FACE="Courier New">long</FONT> <I>result</I>.</P>
<P>For more information about the <FONT FACE="Courier New">lshl</FONT> instruction, see Chapter 13, &quot;Logic.&quot;</P>
<P><H3><FONT FACE="Courier New">lshr</H3></FONT> - Perform arithmetic right shift on <FONT FACE="Courier New">long</FONT></P>
<P><H3>Opcode:</H3> 123 (0x7b)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">lshr</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value1.word1, value1.word2, value2</P></EM></H4>
<P>After:<I>..., result.word1, result.word2</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The top word of the operand stack, <I>value2</I>, must be an <FONT FACE="Courier New">int</FONT>. The next two words down must be a <FONT FACE="Courier New">long</FONT>, <I>value1</I>. To execute the <FONT FACE="Courier New">lshr</FONT> instruction, the Java Virtual Machine pops <I>value1</I> and <I>value2</I>, shifts <I>value1</I> right with sign extension by the number of bits specified in the 6 lowest order bits of <I>value2</I> (from 0 to 63 bit positions), and pushes the <FONT FACE="Courier New">long</FONT> <I>result</I>.</P>
<P>For more information about the <FONT FACE="Courier New">lshr</FONT> instruction, see Chapter 13, &quot;Logic.&quot;</P>
<P><H3><FONT FACE="Courier New">lstore</H3></FONT> - Store <FONT FACE="Courier New">long</FONT> into local variable</P>
<P><H3>Opcode:</H3> 55 (0x37)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">lstore</FONT>, <I>index</P></EM></H4>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value.word1, value.word2</P></EM></H4>
<P>After:<I>...</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The <I>index</I> operand must specify a valid 8-bit unsigned index into the local variables of the current frame. The top two words of the operand stack must be a <FONT FACE="Courier New">long</FONT>. To execute the <FONT FACE="Courier New">lstore</FONT> instruction, the Java Virtual Machine pops the <FONT FACE="Courier New">long</FONT> <I>value</I> from the top of the operand stack and stores it into the two consecutive local variable words at indexes <I>index</I> and <I>index + 1</I>.</P>
<P>Note that the <FONT FACE="Courier New">wide</FONT> instruction can precede the <FONT FACE="Courier New">lstore</FONT> instruction, to enable a <I>value</I> to be stored into a local variable specified by a 16-bit unsigned offset.</P>
<P>For more information about the <FONT FACE="Courier New">lstore</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<P><H3><FONT FACE="Courier New">lstore_0</H3></FONT> - Store <FONT FACE="Courier New">long</FONT> into local variable 0</P>
<P><H3>Opcode:</H3> 63 (0x3f)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">lstore_0</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value.word1, value.word2</P></EM></H4>
<P>After:<I>...</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The indexes zero and one must be valid indexes into the local variables of the current stack frame. The top two words on the operand stack must be a <FONT FACE="Courier New">long</FONT>. To execute the <FONT FACE="Courier New">lstore_0</FONT> instruction, the Java Virtual Machine pops the <FONT FACE="Courier New">long</FONT> <I>value</I> from the top of the operand stack and stores it into the two consecutive local variable words at indexes zero and one.</P>
<P>For more information about the <FONT FACE="Courier New">lstore_0</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<P><H3><FONT FACE="Courier New">lstore_1</H3></FONT> - Store <FONT FACE="Courier New">long</FONT> into local variable 1</P>
<P><H3>Opcode:</H3> 64 (0x40)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">lstore_1</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value.word1, value.word2</P></EM></H4>
<P>After:<I>...</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The indexes one and two must be valid indexes into the local variables of the current stack frame. The top two words on the operand stack must be a <FONT FACE="Courier New">long</FONT>. To execute the <FONT FACE="Courier New">lstore_1</FONT> instruction, the Java Virtual Machine pops the <FONT FACE="Courier New">long</FONT> <I>value</I> from the top of the operand stack and stores it into the two consecutive local variable words at indexes one and two.</P>
<P>For more information about the <FONT FACE="Courier New">lstore_1</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<P><H3><FONT FACE="Courier New">lstore_2</H3></FONT> - Store <FONT FACE="Courier New">long</FONT> into local variable 2</P>
<P><H3>Opcode:</H3> 65 (0x41)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">lstore_2</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value.word1, value.word2</P></EM></H4>
<P>After:<I>...</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The indexes two and three must be valid indexes into the local variables of the current stack frame. The top two words on the operand stack must be a <FONT FACE="Courier New">long</FONT>. To execute the <FONT FACE="Courier New">lstore_2</FONT> instruction, the Java Virtual Machine pops the <FONT FACE="Courier New">long</FONT> <I>value</I> from the top of the operand stack and stores it into the two consecutive local variable words at indexes two and three.</P>
<P>For more information about the <FONT FACE="Courier New">lstore_2</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<P><H3><FONT FACE="Courier New">lstore_3</H3></FONT> - Store <FONT FACE="Courier New">long</FONT> into local variable 3</P>
<P><H3>Opcode:</H3> 66 (0x42)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">lstore_3</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value.word1, value.word2</P></EM></H4>
<P>After:<I>...</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The indexes three and four must be valid indexes into the local variables of the current stack frame. The top two words on the operand stack must be a <FONT FACE="Courier New">long</FONT>. To execute the <FONT FACE="Courier New">lstore_3</FONT> instruction, the Java Virtual Machine pops the <FONT FACE="Courier New">long</FONT> <I>value</I> from the top of the operand stack and stores it into the two consecutive local variable words at indexes three and four.</P>
<P>For more information about the <FONT FACE="Courier New">lstore_3</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<P><H3><FONT FACE="Courier New">lsub</H3></FONT> - Subtract <FONT FACE="Courier New">long</FONT>s</P>
<P><H3>Opcode:</H3> 101 (0x65)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">lsub</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value1.word1, value1.word2, value2.word1, value2.word2</P></EM></H4>
<P>After:<I>..., result.word1, result.word2</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The top four words of the operand stack must be two <FONT FACE="Courier New">long</FONT>s, <I>value1</I> and <I>value2</I>. To execute the <FONT FACE="Courier New">lsub</FONT> instruction, the Java Virtual Machine pops <I>value1</I> and <I>value2</I>, subtracts <I>value2</I> from <I>value1</I> (<I> value1 - value2</I>), and pushes the <FONT FACE="Courier New">long</FONT> <I>result</I>. If overflow occurs, <I>result</I> is the 64 lowest order bits of the true mathematical result represented in a sufficiently wide twoís-complement format, and the sign bit of <I>result</I> is different from the true mathematical result.</P>
<P>For more information about the <FONT FACE="Courier New">lsub</FONT> instruction, see Chapter 12, &quot;Integer Arithmetic.&quot;</P>
<P><H3><FONT FACE="Courier New">lushr</H3></FONT> - Perform logical right shift on <FONT FACE="Courier New">long</FONT></P>
<P><H3>Opcode:</H3> 125 (0x7d)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">lushr</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value1.word1, value1.word2, value2.word1, value2.word2</P></EM></H4>
<P>After:<I>..., result.word1, result.word2</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The top word of the operand stack, <I>value2</I>, must be an <FONT FACE="Courier New">int</FONT>. The next two words down must be a <FONT FACE="Courier New">long</FONT>, <I>value1</I>. To execute the <FONT FACE="Courier New">lushr</FONT> instruction, the Java Virtual Machine pops <I>value1</I> and <I>value2</I>, shifts <I>value1</I> right with zero extension by the number of bits specified in the 6 lowest order bits of <I>value2</I> (from 0 to 63 bit positions), and pushes the <FONT FACE="Courier New">long</FONT> <I>result</I>.</P>
<P>For more information about the <FONT FACE="Courier New">lushr</FONT> instruction, see Chapter 13, &quot;Logic.&quot;</P>
<P><H3><FONT FACE="Courier New">lxor</H3></FONT> - Perform boolean XOR on <FONT FACE="Courier New">long</FONT>s</P>
<P><H3>Opcode:</H3> 131 (0x83)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">lxor</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value1.word1, value1.word2, value2.word1, value2.word2</P></EM></H4>
<P>After:<I>..., result.word1, result.word2</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The top four words of the operand stack must be two <FONT FACE="Courier New">long</FONT>s, <I>value1</I> and <I>value2</I>. To execute the <FONT FACE="Courier New">lxor</FONT> instruction, the Java Virtual Machine pops <I>value1</I> and <I>value2</I>, bitwise exclusive ORs them, and pushes the <FONT FACE="Courier New">long</FONT> <I>result</I>.</P>
<P>For more information about the <FONT FACE="Courier New">lxor</FONT> instruction, see Chapter 13, &quot;Logic.&quot;</P>
<P><H3><FONT FACE="Courier New">monitorenter</H3></FONT> - Enter and acquire object monitor</P>
<P><H3>Opcode:</H3> 194 (0xc2)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">monitorenter</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., objectref</P></EM></H4>
<P>After:<I>...</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The top word of the operand stack, <I>objectref</I>, must be a <FONT FACE="Courier New">reference</FONT>.To execute the <FONT FACE="Courier New">monitorenter</FONT> instruction, the Java Virtual Machine pops <I>objectref</I> and, on behalf of the current thread, acquires the monitor associated with <I>objectref</I>.</P>
<P>If the <I>objectref</I> word is <FONT FACE="Courier New">null</FONT>, </I>The virtual machine throws <FONT FACE="Courier New">NullPointerException</FONT>.</P>
<P>For more information about the <FONT FACE="Courier New">monitorenter</FONT> instruction, see Chapter 20, &quot;Thread Synchronization.&quot;</P>
<P><H3><FONT FACE="Courier New">monitorexit</H3></FONT> - Release and exit object monitor</P>
<P><H3>Opcode:</H3> 195 (0xc3)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">monitorexit</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., objectref</P></EM></H4>
<P>After:<I>...</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The top word of the operand stack, <I>objectref</I>, must be a <FONT FACE="Courier New">reference</FONT>.To execute the <FONT FACE="Courier New">monitorenter</FONT> instruction, the Java Virtual Machine pops <I>objectref</I> and, on behalf of the current thread, releases and exits the monitor associated with <I>objectref</I>.</P>
<P>If the <I>objectref</I> word is <FONT FACE="Courier New">null</FONT>, </I>The virtual machine throws <FONT FACE="Courier New">NullPointerException</FONT>.</P>
<P>For more information about the <FONT FACE="Courier New">monitorexit</FONT> instruction, see Chapter 20, &quot;Thread Synchronization.&quot;</P>
<P><H3><FONT FACE="Courier New">multianewarray</H3></FONT> - Allocate new multi-dimensional array</P>
<P><H3>Opcode:</H3> 197 (0xc5)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">multianewarray</FONT>, <I>indexbyte1</I>, <I>indexbyte2</I>, <I>dimensions</P></EM></H4>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., count1, [count2,...]</P></EM></H4>
<P>After:<I>arrayref</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The <I>dimensions</I> operand, an unsigned byte that indicates the number of dimensions in the array to create, must be greater than or equal to one. The top <I>dimensions</I> words of the operand stack, <I>count1, [count2,...]</I>, must contain <FONT FACE="Courier New">int</FONT>s that have nonnegative values. Each of these words gives the number of elements in one dimension of the array. For example, consider an array declared as:</P>
<P><FONT FACE="Courier New">begin cc</FONT>.</P>
<FONT FACE="Courier New"><P>int[][][] example = new int[3][4][5];</P>
</FONT><P><FONT FACE="Courier New">end</FONT></P>
<P>For this array, <I>dimensions</I> would be equal to three and the operand stack would contain three &quot;count&quot; words. The <I>count1</I> word would be three, <I>count2</I> four, and <I>count3</I> five.</P>
<P>To execute the <FONT FACE="Courier New">multianewarray</FONT> instruction, the Java Virtual Machine first forms an unsigned 16-bit index into the constant pool by calculating <I>(indexbyte1 <FONT FACE="Courier New"> 8) | indexbyte2</I>. </I>The virtual machine then looks up the constant pool entry specified by the calculated index. The constant pool entry at that index must be a <FONT FACE="Courier New">CONSTANT_Class_info</FONT> entry. If it hasnít already, </I>The virtual machine resolves the entry. The entry must be an array type of dimensionality greater than or equal to <I>dimensions</I>.</P>
<P>If the resolution is successful, the Java Virtual Machine creates the <I>dimensions</I>-dimensional array on the heap. </I>The virtual machine initializes the elements of the first-dimension array with references to the second-dimension arrays; it initializes the elements of each of the second-dimension array with references to the third-dimension arrays, and so on. </I>The virtual machine initializes the elements of the last-dimension arrays with their default initial values. Lastly, the Java Virtual Machine pushes a reference to the new <I>dimensions</I>-dimensional array onto the operand stack.</P>
<P>As a result of executing this instruction, </I>The virtual machine may throw any of the linking errors listed in Chapter 8, &quot;The Linking Model,&quot; as possible during resolution of a <FONT FACE="Courier New">CONSTANT_Class_info</FONT> entry. If resolution succeeds and the arrayís component type is a reference type, but the current class does not have permission to access that reference type, </I>The virtual machine throws <FONT FACE="Courier New">IllegalAccessError</FONT>. Otherwise, if any of the counts popped off of the operand stack have a negative value, the Java Virtual Machine throws <FONT FACE="Courier New">NegativeArraySizeException</FONT>.</P>
<P>Note that the dimensionality of the array type specified in the resolved <FONT FACE="Courier New">CONSTANT_Class_info</FONT> entry need not be equal to the <I>dimensions</I> operand--it can also be greater than <I>dimensions</I>. For example, the name of the array class for a three-dimensional array of <FONT FACE="Courier New">int</FONT>s is &quot;<FONT FACE="Courier New">[[[I</FONT>.&quot; The actual constant pool entry referenced by a <FONT FACE="Courier New">multianewarray</FONT> instruction that creates a three-dimensional array of <FONT FACE="Courier New">int</FONT>s must have at least three dimensions, but may have more. For instance, resolved array types of &quot;<FONT FACE="Courier New">[[[I</FONT>,&quot; &quot;<FONT FACE="Courier New">[[[[I</FONT>,&quot; and &quot;<FONT FACE="Courier New">[[[[[[[[I</FONT>&quot; would all yield three-dimensional arrays of <FONT FACE="Courier New">int</FONT> so long as the <I>dimensions</I> operand is three. This flexibility in specifying multidimensional array types to the <FONT FACE="Courier New">multianewarray</FONT> instruction can reduce the number of entries required in the constant pool of some classes.</P>
<P>For more information about the <FONT FACE="Courier New">multianewarray</FONT> instruction, see Chapter 15, &quot;Objects and Arrays.&quot;</P>
<P><H3><FONT FACE="Courier New">new</H3></FONT> - Create a new object</P>
<P><H3>Opcode:</H3> 187 (0xbb)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">new</FONT>, <I>indexbyte1</I>, <I>indexbyte2</P></EM></H4>
<P><H3>Stack:</H3></P>
<P>Before:<I>...</P></EM></H4>
<P>After:<I>..., objectref</P></EM></H4>
<P><H3>Description:</H3></P>
<P>To execute the <FONT FACE="Courier New">new</FONT> instruction, the Java Virtual Machine first forms an unsigned 16-bit index into the constant pool by calculating <I>(indexbyte1 <FONT FACE="Courier New"> 8) | indexbyte2</I>. </I>The virtual machine then looks up the constant pool entry specified by the calculated index. The constant pool entry at that index must be a <FONT FACE="Courier New">CONSTANT_Class_info</FONT> entry. If it hasnít already, </I>The virtual machine resolves the entry. The entry must be a class type, not an interface or array type. </I>The virtual machine allocates sufficient memory from the heap for the new objectís image, and sets the objectís instance variables to their default initial values. Lastly, </I>The virtual machine pushes <I>objectref</I>, a reference to the new object, onto the operand stack.</P>
<P>As a result of executing this instruction, </I>The virtual machine may throw any of the linking errors listed in Chapter 8, &quot;The Linking Model,&quot; as possible during resolution of a <FONT FACE="Courier New">CONSTANT_Class_info</FONT> entry. If resolution succeeds, but the resolved type is an interface,  abstract class, or array, </I>The virtual machine throws an <FONT FACE="Courier New">InstantiationError</FONT>.  Else, if the current class doesnít have permission to access the resolved class, </I>The virtual machine throws an <FONT FACE="Courier New">IllegalAccessError</FONT>.</P>
<P>For more information about the <FONT FACE="Courier New">new</FONT> instruction, see Chapter 15, &quot;Objects and Arrays.&quot;</P>
<P><H3><FONT FACE="Courier New">newarray</H3></FONT> - Allocate new array of primitive type components</P>
<P><H3>Opcode:</H3> 188 (0xbc)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">newarray</FONT>, <I>atype</P></EM></H4>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., count</P></EM></H4>
<P>After:<I>arrayref</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The top word of the operand stack, <I>count</I>, must be an <FONT FACE="Courier New">int</FONT>. The <I>atype</I> operand, which is used to indicate the array type, must take one of the values shown in Table A-2. To execute the <FONT FACE="Courier New">newarray</FONT> instruction, the Java Virtual Machine pops <I>count</I> and creates on the heap an array of size <I>count</I> of the primitive type specified by <I>atype</I>. </I>The virtual machine initializes each array element to its default initial value and pushes <I>arrayref</I>, a reference to the new array, onto the operand stack.</P>
<P>Table A-2. Values for <I>atype</P></EM></H4>
<P><FONT FACE="Courier New">2 columns</FONT></P>
<P>Array Type<I>atype</P></EM></H4>
<P><FONT FACE="Courier New">T_BOOLEAN</FONT>4</P>
<P><FONT FACE="Courier New">T_CHAR</FONT>5</P>
<P><FONT FACE="Courier New">T_FLOAT</FONT>6</P>
<P><FONT FACE="Courier New">T_DOUBLE</FONT>7</P>
<P><FONT FACE="Courier New">T_BYTE</FONT>8</P>
<P><FONT FACE="Courier New">T_SHORT</FONT>9</P>
<P><FONT FACE="Courier New">T_INT</FONT>10</P>
<P><FONT FACE="Courier New">T_LONG</FONT>11</P>
<P><FONT FACE="Courier New">end table</FONT></P>
<P>If <I>count</I> is less than zero, the Java Virtual Machine throws <FONT FACE="Courier New">NegativeArraySizeException</FONT>.</P>
<P>For more information about the <FONT FACE="Courier New">newarray</FONT> instruction, see Chapter 15, &quot;Objects and Arrays.&quot;</P>
<P><H3><FONT FACE="Courier New">nop</H3></FONT> - Do nothing</P>
<P><H3>Opcode:</H3> 0 (0x0)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">nop</FONT></P>
<P><H3>Stack:</H3></P>
<P>No change</P>
<P><H3>Description:</H3></P>
<P>To execute the <FONT FACE="Courier New">nop</FONT> instruction, the Java Virtual Machine takes a coffee break.</P>
<P>For more information about the <FONT FACE="Courier New">nop</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<P><H3><FONT FACE="Courier New">pop</H3></FONT> - Pop top stack word</P>
<P><H3>Opcode:</H3> 87 (0x57)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">pop</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., word</P></EM></H4>
<P>After:<I>...</P></EM></H4>
<P><H3>Description:</H3></P>
<P>To execute the <FONT FACE="Courier New">pop</FONT> instruction, the Java Virtual Machine pops the top word from the operand stack. This instruction can be used to pop any single-word value from the top of the operand stack. It must not be used to remove half of a dual word value (<FONT FACE="Courier New">long</FONT> or <FONT FACE="Courier New">double</FONT>) from the top of the operand stack.</P>
<P>For more information about the <FONT FACE="Courier New">pop</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<P><H3><FONT FACE="Courier New">pop2</H3></FONT> - Pop top two stack words</P>
<P><H3>Opcode:</H3> 88 (0x58)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">pop2</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., word2, word1</P></EM></H4>
<P>After:<I>...</P></EM></H4>
<P><H3>Description:</H3></P>
<P>To execute the <FONT FACE="Courier New">pop2</FONT> instruction, the Java Virtual Machine pops the top two words from the operand stack. This instruction can be used to pop any dual-word value from the top of the operand stack, or any two single-word values. It must not be used to remove one single-word value and half of a dual word value (<FONT FACE="Courier New">long</FONT> or <FONT FACE="Courier New">double</FONT>) from the top of the operand stack.</P>
<P>For more information about the <FONT FACE="Courier New">pop2</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<P><H3><FONT FACE="Courier New">putfield</H3></FONT> - Set field in object</P>
<P><H3>Opcode:</H3> 181 (0xb5)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">putfield</FONT>, <I>indexbyte1</I>, <I>indexbyte2</P></EM></H4>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., objectref, value</P></EM></H4>
<P>After:<I>...</P></EM></H4>
<P>or</P>
<P>Before:<I>..., objectref, value.word1, value.word2</P></EM></H4>
<P>After:<I>...</P></EM></H4>
<P><H3>Description:</H3></P>
<P>To execute the <FONT FACE="Courier New">putfield</FONT> instruction, the Java Virtual Machine first forms an unsigned 16-bit index into the constant pool by calculating <I>(indexbyte1 <FONT FACE="Courier New"> 8) | indexbyte2</I>. </I>The virtual machine then looks up the constant pool entry specified by the calculated index. The constant pool entry at that index must be a <FONT FACE="Courier New">CONSTANT_Fieldref_info</FONT> entry. If it hasnít already, </I>The virtual machine resolves the entry, which yields the fieldís width and the fieldís offset from the beginning of the object image.</P>
<P>The type of the single or double-word <I>value</I> occupying the top of the stack must be compatible with the descriptor of the resolved field. If the resolved fieldís descriptor is <FONT FACE="Courier New">byte</FONT>, <FONT FACE="Courier New">short</FONT>, <FONT FACE="Courier New">char</FONT>, <FONT FACE="Courier New">boolean</FONT>, or <FONT FACE="Courier New">int</FONT>, the type of <I>value</I> must be <FONT FACE="Courier New">int</FONT>. If the resolved fieldís descriptor is  <FONT FACE="Courier New">long</FONT>, the type of <I>value</I> must be <FONT FACE="Courier New">long</FONT>. If the resolved fieldís descriptor is <FONT FACE="Courier New">float</FONT>, the type of <I>value</I> must be <FONT FACE="Courier New">float</FONT>. If the resolved fieldís descriptor is <FONT FACE="Courier New">double</FONT>, the type of <I>value</I> must be <FONT FACE="Courier New">double</FONT>. If the resolved fieldís descriptor is a reference type, the type of <I>value</I> must be <FONT FACE="Courier New">reference</FONT> and must be assignment-compatible the resolved descriptor type. The <I>objectref</I> word must be a <FONT FACE="Courier New">reference</FONT>.</P>
<P></I>The virtual machine pops <I>value</I> and <I>objectref</I> and assigns <I>value</I> to the appropriate field in the object pointed to by <I>objectref</I>.</P>
<P>As a result of executing this instruction, </I>The virtual machine may throw any of the linking errors listed in Chapter 8, &quot;The Linking Model,&quot; as possible during resolution of a <FONT FACE="Courier New">CONSTANT_Fieldref_info</FONT> entry. As part of the process of resolving the <FONT FACE="Courier New">CONSTANT_Fieldref_info</FONT> entry, </I>The virtual machine checks whether the fieldís access permission enables the current class to access the field. If the field is protected, </I>The virtual machine makes certain the field is a member of the either the current class or a superclass of the current class, and that the class of the object pointed to by <I>objectref</I> is either the current class or a subclass of the current class. If not (or if there is any other access permission problem), </I>The virtual machine throws <FONT FACE="Courier New">IllegalAccessError</FONT>. Else, if the field exists and is accessible from the current class, but the field is static, </I>The virtual machine throws <FONT FACE="Courier New">IncompatibleClassChangeError</FONT>. Otherwise, if <I>objectref</I> is <FONT FACE="Courier New">null</FONT>, </I>The virtual machine throws <FONT FACE="Courier New">NullPointerException</FONT>.</P>
<P>For more information about the <FONT FACE="Courier New">putfield</FONT> instruction, see Chapter 15, &quot;Objects and Arrays.&quot;</P>
<P><H3><FONT FACE="Courier New">putstatic</H3></FONT> - Set static field in class</P>
<P><H3>Opcode:</H3> 179 (0xb3)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">putstatic</FONT>, <I>indexbyte1</I>, <I>indexbyte2</P></EM></H4>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., value</P></EM></H4>
<P>After:<I>...</P></EM></H4>
<P>or</P>
<P>Before:<I>..., value.word1, value.word2</P></EM></H4>
<P>After:<I>...</P></EM></H4>
<P><H3>Description:</H3></P>
<P>To execute the <FONT FACE="Courier New">putstatic</FONT> instruction, the Java Virtual Machine first forms an unsigned 16-bit index into the constant pool by calculating <I>(indexbyte1 <FONT FACE="Courier New"> 8) | indexbyte2</I>. </I>The virtual machine then looks up the constant pool entry specified by the calculated index. The constant pool entry at that index must be a <FONT FACE="Courier New">CONSTANT_Fieldref_info</FONT> entry. If it hasnít already, </I>The virtual machine resolves the entry.</P>
<P>The type of the single or double-word <I>value</I> occupying the top of the stack must be compatible with the descriptor of the resolved field. If the resolved fieldís descriptor is <FONT FACE="Courier New">byte</FONT>, <FONT FACE="Courier New">short</FONT>, <FONT FACE="Courier New">char</FONT>, <FONT FACE="Courier New">boolean</FONT>, or <FONT FACE="Courier New">int</FONT>, the type of <I>value</I> must be <FONT FACE="Courier New">int</FONT>. If the resolved fieldís descriptor is  <FONT FACE="Courier New">long</FONT>, the type of <I>value</I> must be <FONT FACE="Courier New">long</FONT>. If the resolved fieldís descriptor is <FONT FACE="Courier New">float</FONT>, the type of <I>value</I> must be <FONT FACE="Courier New">float</FONT>. If the resolved fieldís descriptor is <FONT FACE="Courier New">double</FONT>, the type of <I>value</I> must be <FONT FACE="Courier New">double</FONT>. If the resolved fieldís descriptor is a reference type, the type of <I>value</I> must be <FONT FACE="Courier New">reference</FONT> and must be assignment-compatible the resolved descriptor type.</P>
<P></I>The virtual machine pops and assigns <I>value</I> to the appropriate static field.</P>
<P>As a result of executing this instruction, </I>The virtual machine may throw any of the linking errors listed in Chapter 8, &quot;The Linking Model,&quot; as possible during resolution of a <FONT FACE="Courier New">CONSTANT_Fieldref_info</FONT> entry. As part of the process of resolving the <FONT FACE="Courier New">CONSTANT_Fieldref_info</FONT> entry, </I>The virtual machine checks whether the fieldís access permission enables the current class to access the field. If the field is protected, </I>The virtual machine makes certain the field is a member of the either the current class or a superclass of the current class. If not (or if there is any other access permission problem), </I>The virtual machine throws <FONT FACE="Courier New">IllegalAccessError</FONT>. Else, if the field exists and is accessible from the current class, but the field is not static, </I>The virtual machine throws <FONT FACE="Courier New">IncompatibleClassChangeError</FONT>.</P>
<P>For more information about the <FONT FACE="Courier New">putstatic</FONT> instruction, see Chapter 15, &quot;Objects and Arrays.&quot;</P>
<P><H3><FONT FACE="Courier New">ret</H3></FONT> - Return from subroutine</P>
<P><H3>Opcode:</H3> 169 (0xa9)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">ret</FONT>, <I>index</P></EM></H4>
<P><H3>Stack:</H3></P>
<P>No change</P>
<P><H3>Description:</H3></P>
<P>The <I>index</I> operand is an 8-bit unsigned offset into the local variables. The local variable word specified by <I>index</I> must be a <FONT FACE="Courier New">returnAddress</FONT>. To execute the <FONT FACE="Courier New">ret</FONT> instruction, the Java Virtual Machine sets the program counter to the <FONT FACE="Courier New">returnAddress</FONT> value stored in local variable <I>index</I>, and continues execution there. (In other words, </I>The virtual machine jumps to the <FONT FACE="Courier New">returnAddress</FONT>.)</P>
<P>Note that the <FONT FACE="Courier New">wide</FONT> instruction can precede the <FONT FACE="Courier New">ret</FONT> instruction, to allow a local variable to be accessed with a 16-bit unsigned offset.</P>
<P>For more information about the <FONT FACE="Courier New">ret</FONT> instruction, see Chapter 18, &quot;Finally Clauses.&quot;</P>
<P><H3><FONT FACE="Courier New">return</H3></FONT> - Return (<FONT FACE="Courier New">void</FONT>) from method</P>
<P><H3>Opcode:</H3> 177 (0xb1)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">return</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>...</P></EM></H4>
<P>After:<I>[empty]</P></EM></H4>
<P><H3>Description:</H3></P>
<P>The return type of the returning method must be <FONT FACE="Courier New">void</FONT>.To execute the <FONT FACE="Courier New">return</FONT> instruction, the Java Virtual Machine discards any words that may still be on the returning methodís frame. If the returning method is synchronized, the monitor that was acquired when the method was invoked is released. The invoking methodís frame is made current, and </I>The virtual machine continues execution in the invoking method.</P>
<P>For more information about monitors, see Chapter 20, &quot;Thread Synchronization.&quot; For more information about the <FONT FACE="Courier New">return</FONT> instruction, see Chapter 19, &quot;Method Invocation and Return.&quot;</P>
<P><H3><FONT FACE="Courier New">saload</H3></FONT> - Load <FONT FACE="Courier New">short</FONT> from array</P>
<P><H3>Opcode:</H3> 53 (0x35)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">saload</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., arrayref, index</P></EM></H4>
<P>After:<I>..., value</P></EM></H4>
<P><H3>Description:</H3></P>
<P>To execute the <FONT FACE="Courier New">saload</FONT> instruction, the Java Virtual Machine first pops two words from the operand stack. The <I>arrayref</I> word must be a <FONT FACE="Courier New">reference</FONT> that refers to an array of <FONT FACE="Courier New">short</FONT>s. The <I>index</I> word must be an <FONT FACE="Courier New">int</FONT>. </I>The virtual machine retrieves from the <I>arrayref</I> array the <FONT FACE="Courier New">short</FONT> <I>value</I> specified by <I>index</I>, sign-extends it to an <FONT FACE="Courier New">int</FONT>, and pushes it onto the operand stack.</P>
<P>If <I>arrayref</I> is <FONT FACE="Courier New">null</FONT>, the Java Virtual Machine throws <FONT FACE="Courier New">NullPointerException</FONT>. Otherwise, if <I>index</I> is not a legal index into the <I>arrayref</I> array, </I>The virtual machine throws <FONT FACE="Courier New">ArrayIndexOutOfBoundsException</FONT>.</P>
<P>For more information about the <FONT FACE="Courier New">saload</FONT> instruction, see Chapter 15, &quot;Objects and Arrays.&quot;</P>
<P><H3><FONT FACE="Courier New">sastore</H3></FONT> - Store into <FONT FACE="Courier New">short</FONT> array</P>
<P><H3>Opcode:</H3> 86 (0x56)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">sastore</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., array, index, value</P></EM></H4>
<P>After:<I>...</P></EM></H4>
<P><H3>Description:</H3></P>
<P>To execute the <FONT FACE="Courier New">sastore</FONT> instruction, the Java Virtual Machine first pops three words from the operand stack. The <I>arrayref</I> word must be a <FONT FACE="Courier New">reference</FONT> that refers to an array of <FONT FACE="Courier New">short</FONT>s. The <I>index</I> and <I>value</I> words must be <FONT FACE="Courier New">int</FONT>s. </I>The virtual machine truncates the <FONT FACE="Courier New">int</FONT> <I>value</I> to a <FONT FACE="Courier New">short</FONT> and stores it into the <I>arrayref</I> array location specified by <I>index</I>.</P>
<P>If <I>arrayref</I> is <FONT FACE="Courier New">null</FONT>, the Java Virtual Machine throws <FONT FACE="Courier New">NullPointerException</FONT>. Otherwise, if <I>index</I> is not a legal index into the <I>arrayref</I> array, </I>The virtual machine throws <FONT FACE="Courier New">ArrayIndexOutOfBoundsException</FONT>.</P>
<P>For more information about the <FONT FACE="Courier New">sastore</FONT> instruction, see Chapter 15, &quot;Objects and Arrays.&quot;</P>
<P><H3><FONT FACE="Courier New">sipush</H3></FONT> - Push 16-bit signed integer</P>
<P><H3>Opcode:</H3> 17 (0x11)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">sipush</FONT>, <I>byte1</I>, <I>byte2</P></EM></H4>
<P><H3>Stack:</H3></P>
<P>Before:<I>...</P></EM></H4>
<P>After:<I>..., value</P></EM></H4>
<P><H3>Description:</H3></P>
<P>To execute the <FONT FACE="Courier New">sipush</FONT> instruction, the Java Virtual Machine first forms an intermediate 16-bit signed integer from <I>byte1</I> and <I>byte2</I> by calculating <I>(byte1 <FONT FACE="Courier New"> 8) | byte2</I>. </I>The virtual machine then sign-extends the intermediate 16-bit signed integer to an <FONT FACE="Courier New">int</FONT>, and pushes the resulting <FONT FACE="Courier New">int</FONT> <I>value</I> onto the operand stack.</P>
<P>For more information about the <FONT FACE="Courier New">sipush</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<P><H3><FONT FACE="Courier New">swap</H3></FONT> - Swap top two stack words</P>
<P><H3>Opcode:</H3> 95 (0x5f)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">swap</FONT></P>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., word2, word1</P></EM></H4>
<P>After:<I>..., word1, word2</P></EM></H4>
<P><H3>Description:</H3></P>
<P>To execute the <FONT FACE="Courier New">swap</FONT> instruction, the Java Virtual Machine swaps the top two words of the operand stack. Both <I>word1</I> and <I>word2</I> must be single-word values.</P>
<P>For more information about the <FONT FACE="Courier New">swap</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<P><H3><FONT FACE="Courier New">tableswitch</H3></FONT> - Access jump table by index and jump</P>
<P><H3>Opcode:</H3> 170 (0xaa)</P>
<P><H3>Instruction Format:</H3> <FONT FACE="Courier New">tableswitch</FONT>, <I>...0-3 byte pad...</I>, <I>defaultbyte1</I>, <I>defaultbyte2</I>, <I>defaultbyte3</I>, <I>defaultbyte4</I>, <I>lowbyte1</I>, <I>lowbyte2</I>, <I>lowbyte3</I>, <I>lowbyte4</I>, <I>highbyte1</I>, <I>highbyte2</I>, <I>highbyte3</I>, <I>highbyte4</I>, <I>...jump offsets...</P></EM></H4>
<P><H3>Stack:</H3></P>
<P>Before:<I>..., index</P></EM></H4>
<P>After:<I>...</P></EM></H4>
<P><H3>Description:</H3></P>
<H3><P></H3>The <CODE>tableswitch</CODE> opcode is followed by zero to three bytes of padding--enough so that the byte immediately following the padding starts at an address that is a multiple of four bytes from the beginning of the method. Each padding byte is a zero. Immediately following the padding is a signed 32-bit default branch offset, <I>default</I>. Following <I>default</I> are two signed 32-bit endpoints of the range of case values embedded in this <CODE>tableswitch instruction:</CODE> <I>low</I>, the low endpoint, and <I>high</I>, the high endpoint<CODE>. The value of </CODE> <I>low</I> must be less than or equal to the value of <I>high</I>. Following <I>low</I> and <I>high</I> are <I>high - low + 1</I> signed 32-bit branch offsets--one branch offset for high, one for low, and one for each integer case value in between high and low. These offsets serve as a zero-based jump table. The branch offset for <I>low</I>, the first entry in the jump table, immediately follows the <I>high</I> endpoint value. </I>The virtual machine calculates all of these signed 32-bit values from the four individual bytes as <I>(byte1 <FONT FACE="Courier New"> 24) | (byte2 <FONT FACE="Courier New"> 16) | (byte3 </FONT><FONT FACE="Courier New"> 8) | byte4</FONT></I>.</P>
</I><P>The top word of the operand stack, <I>index</I>, must be an <FONT FACE="Courier New">int</FONT>. To execute the <CODE>tableswitch instruction, the Java Virtual Machine pops </CODE><I>index</I> off the operand stack, compares it to <I>low</I> and <I>high</I>, and selects a branch offset. If <I>index</I> is less than <I>low</I> and greater than <I>high</I>, </I>The virtual machine selects <I>default</I> as the branch offset. Else, </I>The virtual machine selects the branch offset at position <I>index - low</I> in the jump table. Once it has selected a branch offset, </I>The virtual machine calculates a target (program counter) address by adding the signed branch offset to the address of the <FONT FACE="Courier New">tableswitch</FONT> opcode. The target address must be the address of an opcode within the same method as the <FONT FACE="Courier New">tableswitch</FONT> opcode. </I>The virtual machine jumps to the target address and continues execution there.</P>
<P>For more information about the <FONT FACE="Courier New">tableswitch</FONT> instruction, see Chapter 16, &quot;Control Flow.&quot;</P>
<P><H3><FONT FACE="Courier New">wide</H3></FONT> - Extend a local variable index with additional bytes</P>
<P><H3>Opcode:</H3> 196 (0xc4)</P>
<P><H3>Instruction Format:</H3></P>
<P><FONT FACE="Courier New">wide</FONT>, <I>&lt;opcode</FONT></I>, <I>indexbyte1</I>, <I>indexbyte2</P></EM></H4>
<P>or</P>
<P><FONT FACE="Courier New">wide</FONT>, <FONT FACE="Courier New">iinc</FONT>, <I>indexbyte1</I>, <I>indexbyte2</I>, <I>constbyte1</I>, <I>constbyte2</P></EM></H4>
<P><H3>Stack:</H3></P>
<P>To see how the stack changes when an instruction is modified by <FONT FACE="Courier New">wide</FONT>, see the entry for the unmodified instruction. The stack change for an instruction modified by <FONT FACE="Courier New">wide</FONT> is identical to the stack change for that same instruction unmodified.</P>
<P><H3>Description:</H3></P>
<P>The <FONT FACE="Courier New">wide</FONT> opcode modifies instructions that reference the local variables, extending the modified instructionís unsigned 8-bit local variable index to an unsigned 16-bit index. As shown above, a <FONT FACE="Courier New">wide</FONT> instruction comes in two formats. When the <FONT FACE="Courier New">wide</FONT> opcode modifies <FONT FACE="Courier New">iload</FONT>, <FONT FACE="Courier New">fload</FONT>, <FONT FACE="Courier New">aload</FONT>, <FONT FACE="Courier New">lload</FONT>, <FONT FACE="Courier New">dload</FONT>, <FONT FACE="Courier New">istore</FONT>, <FONT FACE="Courier New">fstore</FONT>, <FONT FACE="Courier New">astore</FONT>, <FONT FACE="Courier New">lstore</FONT>, <FONT FACE="Courier New">dstore</FONT>, or <FONT FACE="Courier New">ret</FONT>, the instruction has the first format. When the <FONT FACE="Courier New">wide</FONT> opcode modifies <FONT FACE="Courier New">iinc</FONT>, the instruction has the second format.</P>
<P>To execute any <FONT FACE="Courier New">wide</FONT> instruction, the Java Virtual Machine first forms an unsigned 16-bit index into the local variables by calculating <I>(indexbyte1 </FONT><FONT FACE="Courier New"> 8) | indexbyte2</FONT></I>. </I>Irrespective of the opcode that <FONT FACE="Courier New">wide</FONT> modifies, the calculated index must be a valid index into the local variables of the current frame. If the <FONT FACE="Courier New">wide</FONT> opcode modifies <FONT FACE="Courier New">lload</FONT>, <FONT FACE="Courier New">dload</FONT>, <FONT FACE="Courier New">lstore</FONT>, or <FONT FACE="Courier New">dstore</FONT>, then one more than the calculated index must also be a valid index into the local variables. Given a valid unsigned 16-bit (wide) local variable index, </I>The virtual machine executes the modified instruction using the wide index.</P>
<P>When a <FONT FACE="Courier New">wide</FONT> opcode modifies an <FONT FACE="Courier New">iinc</FONT> instruction, the format of the <FONT FACE="Courier New">iinc</FONT> instruction changes. An unmodified <FONT FACE="Courier New">iinc</FONT> instruction has two operands, an 8-bit unsigned local variable <I>index</I>, and an 8-bit signed increment <I>const</I>. When modified by <FONT FACE="Courier New">wide</FONT>, however, both the <FONT FACE="Courier New">iinc</FONT> instructionís local variable index and its increment are extended by an extra byte. To execute this instruction, </I>The virtual machine forms a signed 16-bit increment by calculating <I>(constbyte1 </FONT><FONT FACE="Courier New"> 8) | constbyte2</FONT></I>.</P>
</I><P>Note that from the perspective of the bytecode verifier, the opcode modified by <FONT FACE="Courier New">wide</FONT> is seen as an operand to the <FONT FACE="Courier New">wide</FONT> opcode. The bytecodes are not allowed to treat opcodes modified by <FONT FACE="Courier New">wide</FONT> independently. For example, it is illegal for a <FONT FACE="Courier New">goto</FONT> instruction to jump directly to an opcode modified by <FONT FACE="Courier New">wide</FONT>.</P>
<P>For more information about the <FONT FACE="Courier New">wide</FONT> instruction, see Chapter 10, &quot;Stack Operations.&quot;</P>
<TABLE BORDER="0" WIDTH="100%">
<TR><TD><A HREF="http://www.pbg.mcgraw-hill.com/betabooks/stores.html" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/stores.html" target="bottom"><IMG SRC="hotkey.gif" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/images/hotkey.gif" ALIGN="LEFT" BORDER="0" WIDTH="40" HEIGHT="40" ALT="Orders"></A>
<IMG SRC="order_text.gif" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/images/order_text.gif" WIDTH="103" HEIGHT="41" ALT="Orders"></TD>
<TD ALIGN="RIGHT"><A HREF="chap20.html" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/venners/chap20.html"><IMG SRC="backward.gif" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/images/backward.gif" BORDER="0" ALT="Backward" WIDTH="32" HEIGHT="32"></A>&nbsp;<A HREF="appb.html" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/venners/appb.html"><IMG SRC="forward.gif" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/images/forward.gif" BORDER="0" ALT="Forward" WIDTH="32" HEIGHT="32"></A></TD></TR>
<TR><TD COLSPAN="2"><A HREF="mailto:computing@mcgraw-hill.com"><IMG SRC="hotkey.gif" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/images/hotkey.gif" ALIGN="LEFT" BORDER="0" WIDTH="40" HEIGHT="40" ALT="Comments"></A>
<IMG SRC="comment_text.gif" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/images/comment_text.gif" WIDTH="73" HEIGHT="39" ALT="Comments"></TD></TR>

</TABLE>
<HR>
<P ALIGN=CENTER>&nbsp;<A HREF="http://www.pbg.mcgraw-hill.com/computing/computing-home.html" tppabs="http://www.pbg.mcgraw-hill.com/computing/computing-home.html" TARGET="_top">COMPUTING
MCGRAW-HILL</A> | <A HREF="http://www.pbg.mcgraw-hill.com/betabooks/betabooks-home.html" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/betabooks-home.html" TARGET="_top">Beta Books</A>
| <A HREF="http://www.pbg.mcgraw-hill.com/computing/contact.html" tppabs="http://www.pbg.mcgraw-hill.com/computing/contact.html" TARGET="_top">Contact Us</A>
| <A HREF="http://www.pbg.mcgraw-hill.com/betabooks/stores.html" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/stores.html" TARGET="_top">Order Information</A>
| <A HREF="http://mcgraw-hill.inforonics.com/compsearch.shtml" tppabs="http://mcgraw-hill.inforonics.com/compsearch.shtml" TARGET="_top">Online Catalog</A></P>

<P ALIGN=CENTER><FONT SIZE="-1"><A HREF="http://www.pbg.mcgraw-hill.com/computing/computing-home.html" tppabs="http://www.pbg.mcgraw-hill.com/computing/computing-home.html" TARGET="_top">Computing McGraw-Hill</A> is an imprint of the <A HREF="http://www.pbg.mcgraw-hill.com/pbg-home.html" tppabs="http://www.pbg.mcgraw-hill.com/pbg-home.html" TARGET="_top">McGraw-Hill Professional Book Group</A>.</FONT></P>

<!-- begin footer -->
<HR>
<A HREF="http://www.mcgraw-hill.com/" tppabs="http://www.mcgraw-hill.com/" TARGET="_top"><IMG SRC="division-white.gif" tppabs="http://www.pbg.mcgraw-hill.com/images/division-white.gif" WIDTH="350" HEIGHT="44" ALT="A Division of the McGraw-Hill Companies" BORDER="0"></A><BR>
<FONT SIZE="-2">Copyright &copy; 1997 <A HREF="http://www.mcgraw-hill.com/" tppabs="http://www.mcgraw-hill.com/" TARGET="_top">
The McGraw-Hill Companies</A>. All rights reserved. Any use is subject to the 
<A HREF="http://www.mcgraw-hill.com/corporate/news_info/copyrttm.htm" tppabs="http://www.mcgraw-hill.com/corporate/news_info/copyrttm.htm" TARGET="_top">
Terms of Use</A>; the corporation also has a comprehensive <A HREF="http://www.mcgraw-hill.com/corporate/news_info/privacy.html" tppabs="http://www.mcgraw-hill.com/corporate/news_info/privacy.html" TARGET="_top">
Privacy Policy</A> governing information we may collect from our customers.</FONT>
<!-- end footer -->
</BODY>
</HTML>
