<!-- All material contained herein is copyright (c) McGraw-Hill Professional Books
All Rights Reserved. No use of this material may be made without express written
permission of the copyright holder. HTML conversions by Mega Space [barry@megaspace.com] -->

<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=ISO-8859-1">
<TITLE>Understanding Digital Signatures: Inside the Java Virtual Machine
 by Bill Venners - Beta Version</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<TABLE BORDER="0" WIDTH="100%">
<TR><TD><A HREF="http://www.pbg.mcgraw-hill.com/betabooks/stores.html" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/stores.html" target="bottom"><IMG SRC="hotkey.gif" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/images/hotkey.gif" ALIGN="LEFT" BORDER="0" WIDTH="40" HEIGHT="40" ALT="Orders"></A>
<IMG SRC="order_text.gif" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/images/order_text.gif" WIDTH="103" HEIGHT="41" ALT="Orders"></TD>
<TD ALIGN="RIGHT"><A HREF="chap04.html" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/venners/chap04.html"><IMG SRC="backward.gif" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/images/backward.gif" BORDER="0" ALT="Backward" WIDTH="32" HEIGHT="32"></A>&nbsp;<A HREF="chap06.html" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/venners/chap06.html"><IMG SRC="forward.gif" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/images/forward.gif" BORDER="0" ALT="Forward" WIDTH="32" HEIGHT="32"></A></TD></TR>
<TR><TD COLSPAN="2"><A HREF="mailto:computing@mcgraw-hill.com"><IMG SRC="hotkey.gif" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/images/hotkey.gif" ALIGN="LEFT" BORDER="0" WIDTH="40" HEIGHT="40" ALT="Comments"></A>
<IMG SRC="comment_text.gif" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/images/comment_text.gif" WIDTH="73" HEIGHT="39" ALT="Comments"></TD></TR>

<TR><TD COLSPAN="2"><FONT FACE="ARIEL,HELVETICA" SIZE="-1"><I>&copy; 1997 The McGraw-Hill Companies, Inc.  All rights reserved.  <BR>Any use of this Beta Book is subject to the rules stated in the <A HREF="http://www.mcgraw-hill.com/corporate/news_info/copyrttm.htm" tppabs="http://www.mcgraw-hill.com/corporate/news_info/copyrttm.htm" target="_top">Terms of Use</A>.</I></FONT><br>
<script language="javascript">
    document.write("<a href='http://banners.linkbuddies.com/click.php?id=237296'><img src='http://banners.linkbuddies.com/image.php?id=237296&ref=" + document.referrer + "' width=468 height=60 alt='Click Here' border=0></a>");
</script></TD></TR>

</TABLE>
<HR>
<P><H1>Chapter Five</H1></P>
<P><H2>The Java Virtual Machine</H2></P>
<P>The previous four chapters of this book gave a broad overview of Javaís architecture. They showed how the Java Virtual Machine fits into the overall architecture relative to other components such as the language and API. The remainder of this book will focus more narrowly on the Java Virtual Machine. This chapter gives an overview of the Java Virtual Machineís internal architecture.</P>
<P>The Java Virtual Machine is called &quot;virtual&quot; because it is an abstract computer defined by a specification. To run a Java program, you need a concrete implementation of the abstract specification. This chapter describes primarily the abstract specification of the Java Virtual Machine. To illustrate the abstract definition of certain features, however, this chapter also discusses various ways in which those features could be implemented.</P>
<H3><EM><P>What is a Java Virtual Machine?</P>
</EM></H3><P>To understand the Java Virtual Machine you must first be aware that you may be talking about any of three different things when you say &quot;Java Virtual Machine.&quot; You may be speaking of:</P>
<UL><LI> the abstract specification,
<LI> a concrete implementation, or
<LI> a runtime instance.</UL>
<P>The abstract specification is a concept, described in detail in the book: <I>The Java Virtual Machine Specification</I>, by Tim Lindholm and Frank Yellin. Concrete implementations, which exist on many platforms and come from many vendors, are either all software or a combination of hardware and software. A runtime instance hosts a single running Java application.</P>
<P>Each Java application runs inside a runtime instance of some concrete implementation of the abstract specification of the Java Virtual Machine. In this book, the term &quot;Java Virtual Machine&quot; is used in all three of these senses. Where the intended sense is not clear from the context, one of the terms &quot;specification,&quot; &quot;implementation,&quot; or &quot;instance&quot; is added to the term &quot;Java Virtual Machine&quot;.</P>
<H3><EM><P>The Lifetime of a Java Virtual Machine</P>
</EM></H3><P>A runtime instance of the Java Virtual Machine has a clear mission in life: to run one Java application. When a Java application starts, a runtime instance is born. When the application completes, the instance dies. If you start three Java applications at the same time, on the same computer, using the same concrete implementation, youíll get three Java Virtual Machine instances. Each Java application runs inside its own Java Virtual Machine.</P>
<P>A Java Virtual Machine instance starts running its solitary application by invoking the <FONT FACE="Courier New">main()</FONT> method of some initial class. The <FONT FACE="Courier New">main()</FONT> method must be public, static, return <FONT FACE="Courier New">void</FONT>, and accept one parameter: a <FONT FACE="Courier New">String</FONT> array. Any class with such a <FONT FACE="Courier New">main()</FONT> method can be used as the starting point for a Java application.</P>
<P>For example, consider an application that prints out its command line arguments:</P>
<PRE>
<P><FONT FACE="Courier New">begin</FONT></P>
<FONT SIZE="2"><P></FONT><FONT FACE="Courier New">// On CD-ROM in file jvm/ex1/Echo.java
<P>class Echo {</P>
<P>&nbsp;</P>
<P>    public static void main(String[] args) {</P>
<P>        int len = args.length;</P>
<P>        for (int i = 0; i &lt; len; ++i) {</P>
<P>            System.out.print(args[i] + " ");</P>
<P>        }</P>
<P>        System.out.println();</P>
<P>    }</P>
<P>}</P>
</FONT><FONT SIZE="2"><P>&nbsp;</P></FONT><FONT FACE="Courier New">end</FONT></P></PRE>
<P>You must in some implementation-dependent way give a Java Virtual Machine the name of the initial class that has the <FONT FACE="Courier New">main()</FONT> method that will start the entire application. One real world example of a Java Virtual Machine implementation is the <FONT FACE="Courier New">java</FONT> program from Sunís JDK. If you wanted to run the <FONT FACE="Courier New">Echo</FONT> application using Sunís <FONT FACE="Courier New">java</FONT> on Window95, for example, you would type in a command such as:</P>
<P><FONT FACE="Courier New">insert</FONT></P>
<FONT FACE="Courier New"><P>java Echo Greetings, Planet.</P>
</FONT><P><FONT FACE="Courier New">end</FONT></P>
<P>The first word in the command, &quot;<FONT FACE="Courier New">java</FONT>,&quot; indicates that the Java Virtual Machine from Sunís JDK should be run by the operating system. The second word, &quot;<FONT FACE="Courier New">Echo</FONT>,&quot; is the name of the initial class. <FONT FACE="Courier New">Echo</FONT> must have a public static method named <FONT FACE="Courier New">main()</FONT> that returns <FONT FACE="Courier New">void</FONT> and takes a <FONT FACE="Courier New">String</FONT> array as its only parameter. The subsequent words, &quot;<FONT FACE="Courier New">Greetings, Planet.</FONT>,&quot; are the command line arguments for the application. These are passed to the <FONT FACE="Courier New">main()</FONT> method in the <FONT FACE="Courier New">String</FONT> array in the order in which they appear on the command line. So, for the above example, the contents of the <FONT FACE="Courier New">String</FONT> array passed to main in <FONT FACE="Courier New">Echo</FONT> are:</P>
<P><FONT FACE="Courier New">arg[0]</FONT> is <FONT FACE="Courier New">"Greetings,"</FONT></P>
<P><FONT FACE="Courier New">arg[1]</FONT> is <FONT FACE="Courier New">"Planet."</FONT></P>
<P>The <FONT FACE="Courier New">main()</FONT> method of an applicationís initial class serves as the starting point for that applicationís initial thread. The initial thread can in turn fire off other threads.</P>
<P>Inside the Java Virtual Machine, threads come in two flavors: <I>daemon</I> and <I>non-daemon</I>. A daemon thread is ordinarily a thread used by the virtual machine itself, such as a thread that performs garbage collection. The application, however, can mark any threads it creates as daemon threads. The initial thread of an application--the one that begins at <FONT FACE="Courier New">main()</FONT>--is a non-daemon thread.</P>
<P>A Java application continues to execute (the virtual machine instance continues to live) as long as any non-daemon threads are still running. When all non-daemon threads of a Java application terminate, the virtual machine instance will exit. If permitted by the security manager, the application can also cause its own demise by invoking the <FONT FACE="Courier New">exit()</FONT> method of class <FONT FACE="Courier New">Runtime</FONT> or <FONT FACE="Courier New">System</FONT>.</P>
<P>In the <FONT FACE="Courier New">Echo</FONT> application above, the <FONT FACE="Courier New">main()</FONT> method doesnít invoke any other threads. After it prints out the command line arguments, <FONT FACE="Courier New">main()</FONT> returns. This terminates the applicationís only non-daemon thread, which causes the virtual machine instance to exit.</P>
<H3><EM><P>The Architecture of the Java Virtual Machine</P>
</EM></H3><P>In the Java Virtual Machine specification, the behavior of a virtual machine instance is described in terms of subsystems, memory areas, data types, and instructions. These components describe an abstract inner architecture for the abstract Java Virtual Machine. The purpose of these components is not so much to dictate an inner architecture for implementations. It is more to provide a way to strictly define the external behavior of implementations. The specification defines the required behavior of any Java Virtual Machine implementation in terms of these abstract components and their interactions.</P>
<P>Figure 5-1 shows a block diagram of the Java Virtual Machine that includes the major subsystems and memory areas described in the specification. As mentioned in previous chapters, each Java Virtual Machine has a <I>class loader subsystem</I>: a mechanism for loading types (classes and interfaces) given fully qualified names. Each Java Virtual Machine also has an <I>execution engine</I>: a mechanism responsible for executing the instructions contained in the methods of loaded classes.</P>
<P><IMG SRC="fig5-1.gif" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/venners/images/fig5-1.gif" ALT="Figure 5-1"></P>

<P>When a Java Virtual Machine runs a program, it needs memory to store many things, including bytecodes and other information it extracts from loaded class files, objects the program instantiates, parameters to methods, return values, local variables, and intermediate results of computations. The Java Virtual Machine organizes the memory it needs to execute a program into several <I>runtime data areas</I>.</P>
<P>Although the same runtime data areas exist in some form in every Java Virtual Machine implementation, their specification is quite abstract. Many decisions about the structural details of the runtime data areas are left to the designers of individual implementations.</P>
<P>Different implementations of the virtual machine can have very different memory constraints. Some implementations may have a lot of memory in which to work, others may have very little. Some implementations may be able to take advantage of virtual memory, others may not. The abstract nature of the specification of the runtime data areas helps make it easier to implement the Java Virtual Machine on a wide variety of computers and devices.</P>
<P>Some runtime data areas are shared among all of an applicationís threads and others are unique to individual threads. Each instance of the Java Virtual Machine has one <I>method area</I> and one <I>heap</I>. These areas are shared by all threads running inside the virtual machine. When the virtual machine loads a class file, it parses information about a type from the binary data contained in the class file. It places this type information into the method area. As the program runs, the virtual machine places all objects the program instantiates onto the heap. See Figure 5-2 for a graphical depiction of these memory areas.</P>
<P><IMG SRC="fig5-2.gif" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/venners/images/fig5-2.gif" ALT="Figure 5-2"></P>

<P>As each new thread comes into existence, it gets its own <I>pc register</I> (program counter) and <I>Java stack</I>. If the thread is executing a Java method (not a native method), the value of the pc register indicates the next instruction to execute. A threadís Java stack stores the state of Java (not native) method invocations for the thread. The state of a Java method invocation includes its local variables, the parameters with which it was invoked, its return value (if any), and intermediate calculations. The state of native method invocations is stored in an implementation-dependent way in <I>native method stacks</I>, as well as possibly in registers or other implementation-dependent memory areas.</P>
<P>The Java stack is composed of <I>stack frames</I> (or <I>frames</I>). A stack frame contains the state of one Java method invocation. When a thread invokes a method, the Java Virtual Machine pushes a new frame onto that threadís Java stack. When the method completes, the virtual machine pops and discards the frame for that method.</P>
<P>The Java Virtual Machine has no registers to hold intermediate data values. The instruction set uses the Java stack for storage of intermediate data values. This approach was taken by Javaís designers to keep the Java Virtual Machine's instruction set compact and to facilitate implementation on architectures with few or irregular general purpose registers.</P>
<P>See Figure 5-3 for a graphical depiction of the memory areas the Java Virtual Machine creates for each thread. These areas are private to the owning thread. No thread can access the pc register or Java stack of another thread.</P>
<P><IMG SRC="fig5-3.gif" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/venners/images/fig5-3.gif" ALT="Figure 5-3"></P>

<P>Figure 5-3 shows a snapshot of a virtual machine instance in which three threads are executing. At the instant of the snapshot, threads one and two are executing Java methods. Thread three is executing a native method.</P>
<P>In Figure 5-3, as in all graphical depictions of the Java stack in this book, the stacks are shown growing downwards. The &quot;top&quot; of each stack is shown at the bottom of the figure. Stack frames for currently executing methods are shown in a lighter shade. For threads that are currently executing a Java method, the pc register indicates the next instruction to execute. In Figure 5-3, such pc registers (the ones for threads one and two) are shown in a lighter shade. Because thread three is currently executing a native method, the contents of its pc register--the one shown in dark gray--is undefined.</P>
<H3><P>Data Types</P>
</H3><P>The Java Virtual Machine computes by performing operations on certain types of data. Both the data types and operations are strictly defined by the Java Virtual Machine specification. The data types can be divided into a set of <I>primitive types</I> and a <I>reference type</I>. Variables of the primitive types hold <I>primitive values</I>, and variables of the reference type hold <I>reference values</I>. Reference values refer to objects, but are not objects themselves. Primitive values, by contrast, do not refer to anything. They are the actual data themselves. You can see a graphical depiction of the Java Virtual Machineís families of data types in Figure 5-4.</P>
<P><IMG SRC="fig5-4.gif" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/venners/images/fig5-4.gif" ALT="Figure 5-4"></P>

<P>All the primitive types of the Java programming language, except <FONT FACE="Courier New">boolean</FONT>, are primitive types of the Java Virtual Machine. When a compiler translates Java source code into bytecodes, it uses <FONT FACE="Courier New">int</FONT>s or <FONT FACE="Courier New">byte</FONT>s to represent <FONT FACE="Courier New">boolean</FONT>s. In the Java Virtual Machine, <FONT FACE="Courier New">false</FONT> is represented by integer zero and <FONT FACE="Courier New">true</FONT> by any non-zero integer. Operations involving <FONT FACE="Courier New">boolean</FONT> values use <FONT FACE="Courier New">int</FONT>s. Arrays of <FONT FACE="Courier New">boolean</FONT> are accessed as arrays of <FONT FACE="Courier New">byte</FONT>, though they may be represented on the heap as arrays of <FONT FACE="Courier New">byte</FONT> or as bit fields.</P>
<P>The primitive types of the Java programming language other than <FONT FACE="Courier New">boolean</FONT> form the <I>numeric types </I>of the Java Virtual Machine. The numeric types are divided between the <I>integral types</I>: <FONT FACE="Courier New">byte</FONT>, <FONT FACE="Courier New">short</FONT>, <FONT FACE="Courier New">int</FONT>, <FONT FACE="Courier New">long</FONT>, and <FONT FACE="Courier New">char</FONT>, and the<I> floating-point types</I>: <FONT FACE="Courier New">float</FONT> and <FONT FACE="Courier New">double</FONT>. As with the Java programming language, the primitive types of the Java Virtual Machine have the same range everywhere. A <FONT FACE="Courier New">long</FONT> in the Java Virtual Machine always acts like a 64-bit signed twos complement number, independent of the underlying host platform.</P>
<P>The Java Virtual Machine works with one other primitive type that is unavailable to the Java programmer: the <FONT FACE="Courier New">returnValue</FONT> type. This primitive type is used to implement <FONT FACE="Courier New">finally</FONT> clauses of Java programs. The use of the <FONT FACE="Courier New">returnValue</FONT> type is described in detail in Chapter 18, &quot;Finally Clauses.&quot;</P>
<P>The reference type of the Java Virtual Machine is cleverly named <FONT FACE="Courier New">reference</FONT>. Values of type <FONT FACE="Courier New">reference</FONT> come in three flavors: the <I>class type</I>, the <I>interface type</I>, and the <I>array type</I>. All three types have values that are references to dynamically created objects. The class typeís values are references to class instances. The array typeís values are references to arrays, which are full-fledged objects in the Java Virtual Machine. The interface typeís values are references to class instances that implement an interface. One other reference value is the <FONT FACE="Courier New">null</FONT> value, which indicates the <FONT FACE="Courier New">reference</FONT> variable doesnít refer to any object.</P>
<P>The Java Virtual Machine specification defines the range of values for each of the data types, but does not define their sizes. The number of bits used to store each data type value is a decision of the designers of individual implementations. The ranges of the Java Virtual Machines data typeís are shown in Table 5-1. More information on the floating point ranges is given in Chapter 14, &quot;Floating Point Arithmetic.&quot;</P>
<P>Table 5-1. Ranges of the Java Virtual Machineís data types</P>
<P><TABLE WIDTH="500">
<TR><TD VALIGN="TOP"><STRONG>Type</STRONG></TD><TD VALIGN="TOP"><STRONG>Range</STRONG></TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">byte</FONT></TD><TD VALIGN="TOP">8-bit signed two's complement integer (-2<SUP>7</SUP> to 2<SUP>7</SUP> - 1, inclusive)</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">short</FONT></TD><TD VALIGN="TOP">16-bit signed two's complement integer (-2<SUP>15</SUP> to 2<SUP>15</SUP> - 1, inclusive)</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">int</FONT></TD><TD VALIGN="TOP">32-bit signed two's complement integer (-2<SUP>31</SUP> to 2<SUP>31</SUP> - 1, inclusive)</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">long</FONT></TD><TD VALIGN="TOP">64-bit signed two's complement integer (-2<SUP>63</SUP> to 2<SUP>63</SUP> - 1, inclusive)</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">char</FONT></TD><TD VALIGN="TOP">16-bit unsigned Unicode character (0 to 2<SUP>16 </SUP>- 1, inclusive)</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">float</FONT></TD><TD VALIGN="TOP">32-bit IEEE 754 single-precision float</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">double</FONT></TD><TD VALIGN="TOP">64-bit IEEE 754 double-precision float</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">returnValue</FONT></TD><TD VALIGN="TOP">address of an opcode within the same method</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">reference</FONT></TD><TD VALIGN="TOP">reference to an object on the heap, or <FONT FACE="Courier New">null</FONT></TD></TR>
</TABLE>
<H3><P>Word Size</P>
</H3><P>The basic unit of size for data values in the Java Virtual Machine is the <I>word</I>--a fixed size chosen by the designer of each Java Virtual Machine implementation. The word size must be large enough to hold a value of type <FONT FACE="Courier New">byte</FONT>, <FONT FACE="Courier New">short</FONT>, <FONT FACE="Courier New">int</FONT>, <FONT FACE="Courier New">char</FONT>, <FONT FACE="Courier New">float</FONT>, <FONT FACE="Courier New">returnValue</FONT>, or <FONT FACE="Courier New">reference</FONT>. Two words must be large enough to hold a value of type <FONT FACE="Courier New">long</FONT> or <FONT FACE="Courier New">double</FONT>. An implementation designer must therefore choose a word size that is at least 32 bits, but otherwise can pick whatever word size will yield the most efficient implementation. The word size is often chosen to be the size of a native pointer on the host platform.</P>
<P>The specification of many of the Java Virtual Machineís runtime data areas are based upon this abstract concept of a word. For example, two sections of a Java stack frame--the local variables and operand stack--are defined in terms of words. These areas can contain values of any of the virtual machineís data types. When placed into the local variables or operand stack, a value occupies either one or two words.</P>
<P>As they run, Java programs cannot determine the word size of their host virtual machine implementation. The word size does not affect the behavior of a program. It is only an internal attribute of a virtual machine implementation.</P>
<H3><P>The Class Loader Subsystem</P>
</H3><P>The part of a Java Virtual Machine implementation that takes care of finding and loading types is the <I>class loader subsystem</I>. Chapter 1, &quot;Introduction to Javaís Architecture,&quot; gives an overview of this subsystem. Chapter 3, &quot;Security,&quot; shows how the subsystem fits into Javaís security model. This chapter describes the class loader subsystem in more detail and show how it relates to the other components of the virtual machineís internal architecture.</P>
<P>As mentioned in Chapter 1, the Java Virtual Machine contains two kinds of class loaders: a <I>primordial class loader</I> and <I>class loader objects</I>. The primordial class loader is a part of the virtual machine implementation, and class loader objects are part of the running Java application. Classes loaded by different class loaders are placed into separate <I>name spaces</I> inside the Java Virtual Machine.</P>
<P>The class loader subsystem involves many other parts of the Java Virtual Machine and several classes from the <FONT FACE="Courier New">java.lang</FONT> library. For example, class loader objects are regular Java objects whose class descends from <FONT FACE="Courier New">java.lang.ClassLoader</FONT>. The methods of class <FONT FACE="Courier New">ClassLoader</FONT> allow Java applications to access the virtual machineís class loading machinery. Also, for every type a Java Virtual Machine loads, it creates an instance of class <FONT FACE="Courier New">java.lang.Class</FONT> to represent that type. Like all objects, class loader objects and instances of class <FONT FACE="Courier New">Class</FONT> reside on the heap. Data for loaded types resides in the method area.</P>
<I><P>Loading, Linking and Initialization</P>
</I><P>The class loader subsystem is responsible for more than just locating and importing the binary data for classes. It must also verify the correctness of imported classes, allocate and initialize memory for class variables, and assist in the resolution of symbolic references. These activities are performed in a strict order:</P>
<OL><LI>Loading: finding and importing the binary data for a type</P>
<LI>Linking: performing verification, preparation, and (optionally) resolution</P>
<UL>a. Verification: ensuring the correctness of the imported type</P>
b. Preparation: allocating memory for class variables and initializing the memory to default values</P>
c. Resolution: transforming symbolic references from the type into direct references.</P></OL>
<LI>Initialization: invoking Java code that initializes class variables to their proper starting values.</OL>
<P>The details of these processes are given Chapter 7, &quot;The Lifetime of a Class.&quot;</P>
<I><P>The Primordial Class Loader</P>
</I><P>Java Virtual Machine implementations must be able to recognize and load classes and interfaces stored in binary files that conform to the Java class file format. An implementation is free to recognize other binary forms besides class files, but it must recognize class files. One example of an alternative binary format recognized by a particular Java Virtual Machine implementation is the CAB file. This file format, which is an archive of class files and other data files, is defined by Microsoft and recognized by their implementation of the Java Virtual Machine.</P>
<P>Every Java Virtual Machine implementation has a primordial class loader, which knows how to load trusted classes, including the classes of the Java API. The Java Virtual Machine specification doesnít define how the primordial loader should locate classes. That is another decision the specification leaves to implementation designers.</P>
<P>Given a fully qualified type name, the primordial class loader must <I>in some way</I> attempt to locate a file with the typeís simple name plus &quot;<FONT FACE="Courier New">.class</FONT>&quot;. One common approach is demonstrated by the Java Virtual Machine implementation in Sunís 1.1 JDK on Windows95. This implementation searches a user-defined directory path stored in an environment variable named <FONT FACE="Courier New">CLASSPATH</FONT>. The primordial loader looks in each directory, in the order the directories appear in the <FONT FACE="Courier New">CLASSPATH</FONT>, until it finds a file with the appropriate name: the typeís simple name plus &quot;<FONT FACE="Courier New">.class</FONT>&quot;. Unless the type is part of the unnamed package, the primordial loader expects the file to be in a subdirectory of one the directories in the <FONT FACE="Courier New">CLASSPATH</FONT>. The path name of the subdirectory is built from the package name of the type. For example, if the primordial class loader is searching for class <FONT FACE="Courier New">java.lang.Object</FONT>, it will look for <FONT FACE="Courier New">Object.class</FONT> in the <FONT FACE="Courier New">java\lang</FONT> subdirectory of each <FONT FACE="Courier New">CLASSPATH</FONT> directory.</P>
<I><P>Class Loader Objects</P>
</I><P>Although class loader objects themselves are part of the Java application, three of the methods in class <FONT FACE="Courier New">ClassLoader</FONT> are gateways into the Java Virtual Machine:</P>
<PRE><P><FONT FACE="Courier New">begin</FONT></P>
<FONT FACE="Courier New"><P>// Three of the methods declared in class java.lang.ClassLoader:</P>
<P>protected final Class defineClass(byte data[], int offset,</P>
<P>    int length);</P>
<P>protected final Class findSystemClass(String name);</P>
<P>protected final void resolveClass(Class c);</P>
</FONT><P><FONT FACE="Courier New">end</FONT></P></PRE>
<P>Any Java Virtual Machine implementation must take care to connect these methods of class <FONT FACE="Courier New">ClassLoader</FONT> to the internal class loader subsystem. </P>
<P>The <FONT FACE="Courier New">defineClass()</FONT> method accepts a <FONT FACE="Courier New">byte</FONT> array, <FONT FACE="Courier New">data[]</FONT>, as input. Starting at position <FONT FACE="Courier New">offset</FONT> in the array and continuing for <FONT FACE="Courier New">length</FONT> bytes, class <FONT FACE="Courier New">ClassLoader</FONT> expects binary data conforming to the Java class file format--binary data that represents a new type for the running application. Every Java Virtual Machine implementation must make sure the <FONT FACE="Courier New">defineClass()</FONT> method of class <FONT FACE="Courier New">ClassLoader</FONT> can cause a new type to be imported into the method area.</P>
<P>The <FONT FACE="Courier New">findSystemClass()</FONT> method accepts a <FONT FACE="Courier New">String</FONT> representing a fully qualified name of a type. When a class loader object invokes this method, it is requesting that the virtual machine attempt to load the named type via its primordial class loader. If the primordial class loader has already loaded or successfully loads the type, it returns a reference to the <FONT FACE="Courier New">Class</FONT> object representing the type. If it canít locate the binary data for the type, it throws <FONT FACE="Courier New">ClassNotFoundException</FONT>. Every Java Virtual Machine implementation must make sure the <FONT FACE="Courier New">findSystemClass()</FONT> method can invoke the primordial class loader in this way.</P>
<P>The <FONT FACE="Courier New">resolveClass()</FONT> method accepts a reference to a <FONT FACE="Courier New">Class</FONT> instance. This method causes the type represented by the <FONT FACE="Courier New">Class</FONT> instance to be linked and initialized (if it hasnít already been linked and initialized). The <FONT FACE="Courier New">defineClass()</FONT> method, described above, only takes care of loading. (See the above section, &quot;Loading, Linking, and Initialization&quot; for definitions of these terms.) When <FONT FACE="Courier New">defineClass()</FONT> returns a <FONT FACE="Courier New">Class</FONT> instance, the binary file for the type has definitely been located and imported into the method area, but not necessarily linked and initialized. Java Virtual Machine implementations make sure the <FONT FACE="Courier New">resolveClass()</FONT> method of class <FONT FACE="Courier New">ClassLoader</FONT> can cause the class loader subsystem to perform linking and initialization.</P>
<P>The details of how a Java Virtual Machine performs class loading, linking, and initialization, with class loader objects is given in Chapter 8, &quot;The Linking Model.&quot;</P>
<I><P>Name Spaces</P>
</I><P>As mentioned in Chapter 3, &quot;Security,&quot; each class loader maintains its own name space populated by the types it has loaded. Because each class loader has its own name space, a single Java application can load multiple types with the same fully qualified name. A typeís fully qualified name, therefore, is not always enough to uniquely identify it inside a Java Virtual Machine instance. If multiple types of that same name have been loaded into different name spaces, the identity of the class loader that loaded the type (the identity of the name space it is in) will also be needed to uniquely identify that type.</P>
<P>Name spaces arise inside a Java Virtual Machine instance as a result of the process of resolution. As part of the data for each loaded type, the Java Virtual Machine keeps track of the class loader that imported the type. When the virtual machine needs to resolve a symbolic reference from one class to another, it requests the referenced class from the same class loader that loaded the referencing class. This process is described in detail in Chapter 8, &quot;The Linking Model.&quot;</P>
<H3><P>The Method Area</P>
</H3><P>Inside a Java Virtual Machine instance, information about loaded types is stored in a logical area of memory called the method area. When the Java Virtual Machine loads a type, it uses a class loader to locate the appropriate class file. The class loader reads in the class file--a linear stream of binary data--and passes it to the virtual machine. The virtual machine extracts information about the type from the binary data and stores the information in the method area. Memory for class (static) variables declared in the class is also taken from the method area.</P>
<P>The manner in which a Java Virtual Machine implementation represents type information internally is a decision of the implementation designer. For example, multi-byte quantities in class files are stored in big-endian (most significant byte first) order. When the data is imported into the method area, however, a virtual machine can store the data in any manner. If an implementation sits on top of a little-endian processor, the designers may decide to store multi-byte values in the method area in little-endian order.</P>
<P>The virtual machine will search through and use the type information stored in the method area as it executes the application it is hosting. Designers must attempt to devise data structures that will facilitate speedy execution of the Java application, but must also think of compactness. If designing an implementation that will operate under low memory constraints, designers may decide to trade off some execution speed in favor of compactness. If designing an implementation that will run on a virtual memory system, on the other hand, designers may decide to store redundant information in the method area to facilitate execution speed. (If the underlying host doesnít offer virtual memory, but does offer a hard disk, designers could create their own virtual memory system as part of their implementation.) Designers can choose whatever data structures and organization they feel optimize their implementations performance, in the context of its requirements.</P>
<P>All threads share the same method area, so access to the method areaís data structures must be designed to be thread-safe. If two threads are attempting to find a class named <FONT FACE="Courier New">Lava</FONT>, for example, and <FONT FACE="Courier New">Lava</FONT> has not yet been loaded, only one thread should be allowed to load it while the other one waits.</P>
<P>The size of the method area need not be fixed. As the Java application runs, the virtual machine can expand and contract the method area to fit the applicationís needs. Also, the memory of the method area need not be contiguous. It could be allocated on a heap--even on the virtual machineís own heap. Implementations may allow users or programmers to specify an initial size for the method area, as well as a maximum or minimum size.</P>
<P>The method area can also be garbage collected. Because Java programs can be dynamically extended via class loader objects, classes can become &quot;unreferenced&quot; by the application. If a class becomes unreferenced, a Java Virtual Machine can unload the class (garbage collect it) to keep the memory occupied by the method area at a minimum. The unloading of classes--including the conditions under which a class can become &quot;unreferenced&quot;--is described in Chapter 7, &quot;The Lifetime of a Class.&quot;</P>
<I><P>Type Information</P>
</I><P>For each type it loads, a Java Virtual Machine must store the following kinds of information in the method area:</P>
<UL><LI> The fully qualified name of the type
<LI> The fully qualified name of the typeís direct superclass (unless the type is an interface or class <FONT FACE="Courier New">java.lang.Object</FONT>, neither of which have a superclass)
<LI> Whether or not the type is a class or an interface
<LI> The typeís modifiers ( some subset of` <FONT FACE="Courier New">public</FONT>, <FONT FACE="Courier New">abstract</FONT>, <FONT FACE="Courier New">final</FONT>)
<LI> An ordered list of the fully qualified names of any direct superinterfaces</UL>
<P>Inside the Java class file and Java Virtual Machine, type names are always stored as <I>fully qualified names</I>. In Java source code, a fully qualified name is the name of a typeís package, plus a dot, plus the typeís <I>simple name</I>. For example, the fully qualified name of class <FONT FACE="Courier New">Object</FONT> in package <FONT FACE="Courier New">java.lang</FONT> is <FONT FACE="Courier New">java.lang.Object</FONT>. In class files, the dots are replaced by slashes, as in <FONT FACE="Courier New">java/lang/Object</FONT>. In the method area, fully qualified names can be represented in whatever form and data structures a designer chooses.</P>
<P>In addition to the basic type information listed above, the virtual machine must also store for each loaded type:</P>
<UL><LI> The constant pool for the type
<LI> Field information
<LI> Method information
<LI> All class (static) variables declared in the type, except constants
<LI> A reference to class <FONT FACE="Courier New">ClassLoader</FONT>
<LI> A reference to class <FONT FACE="Courier New">Class</FONT>
<P>This data is described in the following sections.</UL>
<I><P>The Constant Pool</P>
</I><P>For each type it loads, a Java Virtual Machine must store a <I>constant pool</I>. A constant pool is an ordered set of constants used by the type, including literals (string, integer, and floating point constants) and symbolic references to types, fields, and methods. Entries in the constant pool are referenced by index, much like the elements of an array. Because it holds symbolic references to all types, fields, and methods used by a type, the constant pool plays a central role in the dynamic linking of Java programs. The constant pool is described in more detail later in this chapter and in Chapter 6, &quot;The Java Class File.&quot;</P>
<I><P>Field Information</P>
</I><P>For each field declared in the type, the following information must be stored in the method area. In addition to the information for each field, the order in which the fields are declared by the class or interface must also be recorded. Hereís the list for fields:</P>
<UL><LI> The fieldís name
<LI> The fieldís type
<LI> The fieldís modifiers (some subset of <FONT FACE="Courier New">public</FONT>, <FONT FACE="Courier New">private</FONT>, <FONT FACE="Courier New">protected</FONT>, <FONT FACE="Courier New">static</FONT>, <FONT FACE="Courier New">final</FONT>, <FONT FACE="Courier New">volatile</FONT>, <FONT FACE="Courier New">transient</FONT>)</UL>
<I><P>Method Information</P>
</I><P>For each method declared in the type, the following information must be stored in the method area. As with fields, the order in which the methods are declared by the class or interface must be recorded as well as the data. Hereís the list:</P>
<UL><LI> The methodís name
<LI> The methodís return type (or <FONT FACE="Courier New">void</FONT>)
<LI> The number and types (in order) of the methodís parameters
<LI> The methodís modifiers (some subset of <FONT FACE="Courier New">public</FONT>, <FONT FACE="Courier New">private</FONT>, <FONT FACE="Courier New">protected</FONT>, <FONT FACE="Courier New">static</FONT>, <FONT FACE="Courier New">final</FONT>, <FONT FACE="Courier New">synchronized</FONT>, <FONT FACE="Courier New">native</FONT>, <FONT FACE="Courier New">abstract</FONT>)</UL>
<P>In addition to the items listed above, the following information must also be stored with each method that is not abstract or native:</P>
<UL><LI> The methodís bytecodes
<LI> The sizes of the operand stack and local variables sections of the methodís stack frame (these are described in a later section of this chapter)
<LI> An exception table (this is described in Chapter 17, &quot;Exceptions&quot;)</UL>
<I><P>Class Variables</P>
</I><P>Class variables are shared among all instances of a class and can be accessed even in the absence of any instance. These variables are associated with the class--not with instances of the class--so they are logically part of the class data in the method area. Before a Java Virtual Machine uses a class, it must allocate memory from the method area for each non-final class variable declared in the class.</P>
<P>Constants (class variables declared final) are not treated in the same way as non-final class variables. Every type that uses a final class variable gets a copy of the constant value in its own constant pool. As part of the constant pool, final class variables are stored in the method area--just like non-final class variables. But whereas non-final class variables are stored as part of the data for the type that <I>declares</I> them, final class variables are stored as part of the data for any type that <I>uses</I> them. This special treatment of constants is explained in more detail in Chapter 6, &quot;The Java Class File.&quot;</P>
<I><P>A Reference to Class <FONT FACE="Courier New">ClassLoader</FONT></P>
</I><P>For each type it loads, a Java Virtual Machine must keep track of whether or not the type was loaded via the primordial class loader or a class loader object. For those types loaded via a class loader object, the virtual machine must store a reference to the class loader object that loaded the type. This information is stored as part of the typeís data in the method area.</P>
<P>The virtual machine uses this information during dynamic linking. When one type refers to another type, the virtual machine requests the referenced type from the same class loader that loaded the referencing type. This process of dynamic linking is also central to the way the virtual machine forms separate name spaces. To be able to properly perform dynamic linking and maintain multiple name spaces, the virtual machine needs to know what class loader loaded each type in its method area. The details of dynamic linking and name spaces are given in Chapter 8, &quot;The Linking Model.&quot;</P>
<I><P>A Reference to Class <FONT FACE="Courier New">Class</FONT></P>
</I><P>An instance of class <FONT FACE="Courier New">java.lang.Class</FONT> is created by the Java Virtual Machine for every type it loads. The virtual machine must in some way associate a reference to the <FONT FACE="Courier New">Class</FONT> instance for a type with the typeís data in the method area.</P>
<P>Your Java programs can obtain and use references to <FONT FACE="Courier New">Class</FONT> objects. One static method in class <FONT FACE="Courier New">Class</FONT>, allows you to get a reference to the <FONT FACE="Courier New">Class</FONT> instance for any loaded class:</P>
<P><FONT FACE="Courier New">begin</FONT></P>
<FONT FACE="Courier New"><P>// A method declared in class java.lang.Class:</P>
<P>public static Class forName(String className);</P>
</FONT><P><FONT FACE="Courier New">end</FONT></P>
<P>If you invoke <FONT FACE="Courier New">forName("java.lang.Object")</FONT>, for example, you will get a reference to the <FONT FACE="Courier New">Class</FONT> object that represents <FONT FACE="Courier New">java.lang.Object</FONT>. If you invoke <FONT FACE="Courier New">forName("java.util.Enumeration")</FONT>, you will get a reference to the <FONT FACE="Courier New">Class</FONT> object that represents the <FONT FACE="Courier New">Enumeration</FONT> interface from the <FONT FACE="Courier New">java.util</FONT> package. You can use <FONT FACE="Courier New">forName()</FONT> to get a <FONT FACE="Courier New">Class</FONT> reference for any loaded type from any package, so long as the type can be (or already has been) loaded into the current name space. If the virtual machine is unable to load the requested type into the current name space, <FONT FACE="Courier New">forName()</FONT> will throw <FONT FACE="Courier New">ClassNotFoundException</FONT>.</P>
<P>An alternative way to get a <FONT FACE="Courier New">Class</FONT> reference is to invoke <FONT FACE="Courier New">getClass()</FONT> on any object reference. This method is inherited by every object from class <FONT FACE="Courier New">Object</FONT> itself:</P>
<P><FONT FACE="Courier New">begin</FONT></P>
<FONT FACE="Courier New"><P>// A method declared in class java.lang.Object:</P>
<P>public final Class getClass();</P>
</FONT><P><FONT FACE="Courier New">end</FONT></P>
<P>If you have a reference to an object of class <FONT FACE="Courier New">java.lang.Integer</FONT>, for example, you could get the <FONT FACE="Courier New">Class</FONT> object for <FONT FACE="Courier New">java.lang.Integer</FONT> simply by invoking <FONT FACE="Courier New">getClass()</FONT> on your reference to the <FONT FACE="Courier New">Integer</FONT> object.</P>
<P>Given a reference to a <FONT FACE="Courier New">Class</FONT> object, you can find out information about the type by invoking methods declared in class <FONT FACE="Courier New">Class</FONT>. If you look at these methods, you will quickly realize that class <FONT FACE="Courier New">Class</FONT> gives the running application access to the information stored in the method area. Here are some of the methods declared in class <FONT FACE="Courier New">Class</FONT>:</P>
<P><FONT FACE="Courier New">begin</FONT></P>
<FONT FACE="Courier New"><P>// Some of the methods declared in class java.lang.Class:</P>
<P>public String getName();</P>
<P>public Class getSuperClass();</P>
<P>public boolean isInterface();</P>
<P>public Class[] getInterfaces();</P>
<P>public ClassLoader getClassLoader()</P>
</FONT><P><FONT FACE="Courier New">end</FONT></P>
<P>These methods just return information about a loaded type. <FONT FACE="Courier New">getName()</FONT> returns the fully qualified name of the type. <FONT FACE="Courier New">getSuperClass()</FONT> returns the <FONT FACE="Courier New">Class</FONT> instance for the typeís direct superclass. If the type is class <FONT FACE="Courier New">java.lang.Object</FONT> or an interface, none of which have a superclass, <FONT FACE="Courier New">getSuperClass()</FONT> returns <FONT FACE="Courier New">null</FONT>. <FONT FACE="Courier New">isInterface()</FONT> returns <FONT FACE="Courier New">true</FONT> if the <FONT FACE="Courier New">Class</FONT> object describes an interface, <FONT FACE="Courier New">false</FONT> if it describes a class. <FONT FACE="Courier New">getInterfaces()</FONT> returns an array of <FONT FACE="Courier New">Class</FONT> objects, one for each direct superinterface. The superinterfaces appear in the array in the order they are declared as superinterfaces by the type. If the type has no direct superinterfaces, <FONT FACE="Courier New">getInterfaces()</FONT> returns an array of length zero. <FONT FACE="Courier New">getClassLoader()</FONT> returns a reference to the <FONT FACE="Courier New">ClassLoader</FONT> object that loaded this type, or <FONT FACE="Courier New">null</FONT> if the type was loaded by the primordial class loader. All this information comes straight out of the method area.</P>
<I><P>Method Tables</P>
</I><P>The type information stored in the method area must be organized to be quickly accessible. In addition to the raw type information listed above, implementations may include other data structures that speed up access to the raw data. One example of such a data structure is a <I>method table</I>. For each non-abstract class a Java Virtual Machine loads, it could generate a method table and include it as part of the class information it stores in the method area. A method table is an array of direct references to all the instance methods that may be invoked on a class instance, including instance methods inherited from superclasses. (A method table isnít helpful in the case of abstract classes or interfaces, because the program will never instantiate these.) A method table allows a virtual machine to quickly locate an instance method invoked on an object. Method tables are described in detail in Chapter 8, &quot;The Linking Model.&quot;</P>
<I><P>An Example of Method Area Use</P>
</I><P>As an example of how the Java Virtual Machine uses the information it stores in the method area, consider these classes:</P>
<PRE><P><FONT FACE="Courier New">begin</FONT></P>
<FONT SIZE="2"><P></FONT><FONT FACE="Courier New">// On CD-ROM in file jvm/ex2/Lava.java
<P>class Lava {</P>
<P>&nbsp;</P>
<P>    private int speed = 5; // 5 kilometers per hour</P>
<P>&nbsp;</P>
<P>    void flow() {</P>
<P>    }</P>
<P>}</P>
</FONT><FONT SIZE="2"><P>&nbsp;</P></P>
<P></FONT><FONT FACE="Courier New">// On CD-ROM in file jvm/ex2/Volcano.java
<P>class Volcano {</P>
<P>&nbsp;</P>
<P>    public static void main(String[] args) {</P>
<P>        Lava lava = new Lava();</P>
<P>        lava.flow();</P>
<P>    }</P>
<P>}</P>
</FONT><FONT SIZE="2"><P>&nbsp;</P></FONT><FONT FACE="Courier New">end</FONT></P></PRE>
<P>The following paragraphs describe how an implementation might execute the first instruction in the bytecodes for the <FONT FACE="Courier New">main()</FONT> method of the <FONT FACE="Courier New">Volcano</FONT> application. Different implementations of the Java Virtual Machine can operate in very different ways. The following description illustrates one way--but not the only way--a Java Virtual Machine could execute the first instruction of <FONT FACE="Courier New">Volcano</FONT>ís <FONT FACE="Courier New">main()</FONT> method.</P>
<P>To run the <FONT FACE="Courier New">Volcano</FONT> application, you give the name &quot;<FONT FACE="Courier New">Volcano</FONT>&quot; to a Java Virtual Machine in an implementation-dependent manner. Given the name <FONT FACE="Courier New">Volcano</FONT>, the virtual machine finds and reads in file <FONT FACE="Courier New">Volcano.class</FONT>. It extracts the definition of class <FONT FACE="Courier New">Volcano</FONT> from the binary data in the imported class file and places the information into the method area. The virtual machine then invokes the <FONT FACE="Courier New">main()</FONT> method, by interpreting the bytecodes stored in the method area. As the virtual machine executes <FONT FACE="Courier New">main()</FONT>, it maintains a pointer to the constant pool (a data structure in the method area) for the current class (class <FONT FACE="Courier New">Volcano</FONT>).</P>
<P>Note that this Java Virtual Machine has already begun to execute the bytecodes for <FONT FACE="Courier New">main()</FONT> in class <FONT FACE="Courier New">Volcano</FONT> even though it hasnít yet loaded class <FONT FACE="Courier New">Lava</FONT>. Like many (probably most) implementations of the Java Virtual Machine, this implementation doesnít wait until all classes used by the application are loaded before it begins executing <FONT FACE="Courier New">main()</FONT>. It loads classes only as it needs them.</P>
<P><FONT FACE="Courier New">main()</FONT>ís first instruction tells the Java Virtual Machine to allocate enough memory for the class listed in constant pool entry one. The virtual machine uses its pointer into <FONT FACE="Courier New">Volcano</FONT>ís constant pool to look up entry one and finds a symbolic reference to class <FONT FACE="Courier New">Lava</FONT>. It checks the method area to see if <FONT FACE="Courier New">Lava</FONT> has already been loaded.</P>
<P>The symbolic reference is just a string giving the classís fully qualified name: <FONT FACE="Courier New">"Lava"</FONT>. Here you can see that the method area must be organized so a class can be located--as quickly as possible--given only the classís fully qualified name. Implementation designers can choose whatever algorithm and data structures best fit their needs--a hash table, a search tree, anything. This same mechanism can be used by the static <FONT FACE="Courier New">forName()</FONT> method of class <FONT FACE="Courier New">Class</FONT>, which returns a <FONT FACE="Courier New">Class</FONT> reference given a fully qualified name.</P>
<P>When the virtual machine discovers that it hasnít yet loaded a class named &quot;<FONT FACE="Courier New">Lava</FONT>,&quot; it proceeds to find and read in file <FONT FACE="Courier New">Lava.class</FONT>. It extracts the definition of class <FONT FACE="Courier New">Lava</FONT> from the imported binary data and places the information into the method area.</P>
<P>The Java Virtual Machine then replaces the symbolic reference in <FONT FACE="Courier New">Volcano</FONT>ís constant pool entry one, which is just the string <FONT FACE="Courier New">"Lava"</FONT>, with a pointer to the class data for <FONT FACE="Courier New">Lava</FONT>. If the virtual machine ever has to use <FONT FACE="Courier New">Volcano</FONT>ís constant pool entry one again, it wonít have to go through the relatively slow process of searching through the method area for class <FONT FACE="Courier New">Lava</FONT> given only a symbolic reference, the string <FONT FACE="Courier New">"Lava"</FONT>. It can just use the pointer to more quickly access the class data for <FONT FACE="Courier New">Lava</FONT>. This process of replacing symbolic references with direct references (in this case, a native pointer) is called <I>constant pool resolution</I>. The symbolic reference is <I>resolved</I> into a direct reference by searching through the method area until the referenced entity is found, loading new classes if necessary.</P>
<P>Finally, the virtual machine is ready to actually allocate memory for a new <FONT FACE="Courier New">Lava</FONT> object. Once again, the virtual machine consults the information stored in the method area. It uses the pointer (which was just put into <FONT FACE="Courier New">Volcano</FONT>ís constant pool entry one) to the <FONT FACE="Courier New">Lava</FONT> data (which was just imported into the method area) to find out how much heap space is required by a <FONT FACE="Courier New">Lava</FONT> object.</P>
<P>A Java Virtual Machine can always determine the amount of memory required to represent an object by looking into the class data stored in the method area. The actual amount of heap space required by a particular object, however, is implementation-dependent. The internal representation of objects inside a Java Virtual Machine is another decision of implementation designers. Object representation is discussed in more detail later in this chapter.</P>
<P>Once the Java Virtual Machine has determined the amount of heap space required by a <FONT FACE="Courier New">Lava</FONT> object, it allocates that space on the heap and initializes the instance variable <FONT FACE="Courier New">speed</FONT> to zero, its default initial value. If class <FONT FACE="Courier New">Lava</FONT>ís superclass, <FONT FACE="Courier New">Object</FONT>, has any instance variables, those are also initialized to default initial values. (The details of initialization of both classes and objects are given in Chapter 7, &quot;The Lifetime of a Class.&quot;)</P>
<P>The first instruction of <FONT FACE="Courier New">main()</FONT> completes by pushing a reference to the new <FONT FACE="Courier New">Lava</FONT> object onto the stack. A later instruction will use the reference to invoke Java code that initializes the <FONT FACE="Courier New">speed</FONT> variable to its proper initial value, five. Another instruction will use the reference to invoke the <FONT FACE="Courier New">flow()</FONT> method on the referenced <FONT FACE="Courier New">Lava</FONT> object.</P>
<H3><P>The Heap</P>
</H3><P>Whenever a class instance or array is created in a running Java application, the memory for the new object is allocated from a single heap. As there is only one heap inside a Java Virtual Machine instance, all threads share it. Because a Java application runs inside its &quot;own&quot; exclusive Java Virtual Machine instance, there is a separate heap for every individual running application. There is no way two different Java applications could trample on each otherís heap data. Two different threads of the same application, however, could trample on each otherís heap data. This is why you must be concerned about proper synchronization of multi-threaded access to objects (heap data) in your Java programs.</P>
<P>The Java Virtual Machine has an instruction that allocates memory on the heap for a new object, but has no instruction for freeing that memory. Just as you canít explicitly free an object in Java source code, you canít explicitly free an object in Java bytecodes. The virtual machine itself is responsible for deciding whether and when to free memory occupied by objects that are no longer referenced by the running application. Usually, a Java Virtual Machine implementation uses a <I>garbage collector</I> to manage the heap.</P>
<I><P>Garbage Collection</P>
</I><P>A garbage collectorís primary function is to automatically reclaim the memory used by objects that are no longer referenced by the running application. It may also move objects as the application runs to reduce heap fragmentation.</P>
<P>A garbage collector is not strictly required by the Java Virtual Machine specification. The specification only requires that an implementation manage its own heap <I>in some manner</I>. For example, an implementation could simply have a fixed amount of heap space available and throw an <FONT FACE="Courier New">OutOfMemory</FONT> exception when that space fills up. While this implementation may not win many prizes, it does qualify as a Java Virtual Machine. The Java Virtual Machine specification does not say how much memory an implementation must make available to running programs. It does not say how an implementation must manage its heap. It says to implementation designers only that the program will be allocating memory from the heap, but not freeing it. It is up to designers to figure out how they want to deal with that fact.</P>
<P>No garbage collection technique is dictated by the Java Virtual Machine specification. Designers can use whatever techniques seem most appropriate given their goals, constraints, and talents. Because references to objects can exist in many places--Java Stacks, the heap, the method area, native method stacks--the choice of garbage collection technique heavily influences the design of an implementationís runtime data areas. Various garbage collection techniques are described in Chapter 9, &quot;Garbage Collection.&quot;</P>
<P>As with the method area, the memory that makes up the heap need not be contiguous, and may be expanded and contracted as the running program progresses. An implementationís method area could, in fact, be implemented on top of its heap. In other words, when a virtual machine needs memory for a freshly loaded class, it could take that memory from the same heap on which objects reside. The same garbage collector that frees memory occupied by unreferenced objects could take care of finding and freeing (unloading) unreferenced classes. Implementations may allow users or programmers to specify an initial size for the heap, as well as a maximum and minimum size.</P>
<I><P>Object Representation</P>
</I><P>The Java Virtual Machine specification is silent on how objects should be represented on the heap. Object representation--an integral aspect of the overall design of the heap and garbage collector--is a decision of implementation designers</P>
<P>The primary data that must in some way be represented for each object is the instance variables declared in the objectís class and all its superclasses. Given an object reference, the virtual machine must be able to quickly locate the instance data for the object. In addition, there must be some way to access an objectís class data (stored in the method area) given a reference to the object. For this reason, the memory allocated for an object usually includes some kind of pointer into the method area.</P>
<P>One possible heap design divides the heap into two parts: a handle pool and an object pool. An object reference is a native pointer to a handle pool entry. A handle pool entry has two components: a pointer to instance data in the object pool and a pointer to class data in the method area. The advantage of this scheme is that it makes it easy for the virtual machine to combat heap fragmentation. When the virtual machine moves an object in the object pool, it need only update one pointer with the objectís new address: the relevant pointer in the handle pool. The disadvantage of this approach is that every access to an objectís instance data requires dereferencing two pointers. This approach to object representation is shown graphically in Figure 5-5. This kind of heap is demonstrated interactively by the HeapOfFish applet, described in Chapter 9, &quot;Garbage Collection.&quot;</P>
<P><IMG SRC="fig5-5.gif" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/venners/images/fig5-5.gif" ALT="Figure 5-5"></P>

<P>Another design makes an object reference a native pointer to a bundle of data that contains the objectís instance data and a pointer to the objectís class data. This approach requires dereferencing only one pointer to access an objectís instance data, but makes moving objects more complicated. When the virtual machine moves an object to combat fragmentation of this kind of heap, it must update every reference to that object anywhere in the runtime data areas. This approach to object representation is shown graphically in Figure 5-6.</P>
<P><IMG SRC="fig5-6.gif" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/venners/images/fig5-6.gif" ALT="Figure 5-6"></P>

<P>The virtual machine needs to get from an object reference to that objectís class data for several reasons. When a running program attempts to cast an object reference to another type, the virtual machine must check to see if the type being cast to is the actual class of the referenced object or one of its supertypes. . It must perform the same kind of check when a program performs an <FONT FACE="Courier New">instanceof</FONT> operation. In either case, the virtual machine must look into the class data of the referenced object. When a program invokes an instance method, the virtual machine must perform dynamic binding: it must choose the method to invoke based not on the type of the reference but on the class of the object. To do this, it must once again have access to the class data given only a reference to the object.</P>
<P>No matter what object representation an implementation uses, it is likely that a method table is close at hand for each object. Method tables, because they speed up the invocation of instance methods, can play an important role in achieving good overall performance for a virtual machine implementation. Method tables are not required by the Java Virtual Machine specification and may not exist in all implementations. Implementations that have extremely low memory requirements, for instance, may not be able to afford the extra memory space method tables occupy. If an implementation does use method tables, however, an objectís method table will likely be quickly accessible given just a reference to the object.</P>
<P>One way an implementation could connect a method table to an object reference is shown graphically in Figure 5-7. This figure shows that the pointer kept with the instance data for each object points to a special structure. The special structure has two components:</P>
<UL><LI> A pointer to the full the class data for the object
<LI> The method table for the object
<P> The method table is an array of pointers to the data for each instance method that can be invoked on objects of that class. The method data pointed to by method table includes:
<LI> The sizes of the operand stack and local variables sections of the methodís stack 
<LI> The methodís bytecodes
<LI> An exception table</UL>
<P>This gives the virtual machine enough information to invoke the method. The method table include pointers to data for methods declared explicitly in the objectís class or inherited from superclasses. In other words, the pointers in the method table may point to methods defined in the objectís class or any of its superclasses. More information on method tables is given in Chapter 8, &quot;The Linking Model.&quot;</P>
<P><IMG SRC="fig5-7.gif" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/venners/images/fig5-7.gif" ALT="Figure 5-7"></P>

<P>If you are familiar with the inner workings of C++, you may recognize the method table as similar to the VTBL or virtual table of C++ objects. In C++, objects are represented by their instance data plus an array of pointers to any virtual functions that can be invoked on the object. This approach could also be taken by a Java Virtual Machine implementation. An implementation could include a copy of the method table for a class as part of the heap image for every instance of that class. This approach would consume more heap space than the approach shown in Figure 5-7, but might yield slightly better performance on a systems that enjoy large quantities of available memory.</P>
<P>One other kind of data that is not shown in Figures 5-5 and 5-6, but which is logically part of an objectís data on the heap, is the objectís <I>lock</I>. Each object in a Java Virtual Machine is associated with a lock (or <I>mutex</I>) that a program can use to coordinate multi-threaded access to the object. Only one thread at a time can &quot;own&quot; an objectís lock. While a particular thread owns a particular objectís lock, only that thread can access that objectís instance variables. All other threads that attempt to access the objectís variables have to wait until the owning thread releases the objectís lock. If a thread requests a lock that is already owned by another thread, the requesting thread has to wait until the owning thread releases the lock. Once a thread owns a lock, it can request the same lock again multiple times, but then has to release the lock the same number of times before it is made available to other threads. If a thread requests a lock three times, for example, that thread will continue to own the lock until it has released it three times.</P>
<P>Many objects will go through their entire lifetimes without ever being locked by a thread. The data required to implement an objectís lock is not needed unless the lock is actually requested by a thread. As a result, many implementations, such as the ones shown in Figure 5-5 and 5-6, may not include a pointer to &quot;lock data&quot; within the object itself. Such implementations must create the necessary data to represent a lock when the lock is requested for the first time. In this scheme, the virtual machine must associate the lock with the object in some indirect way, such as by placing the lock data into a search tree based on the objectís address.</P>
<P>Along with data that implements a lock, every Java object is logically associated with data that implements a <I>wait set</I>. Whereas locks help threads to work independently on shared data without interfering with one another, wait sets help threads to cooperate with one another--to work together towards a common goal.</P>
<P>Wait sets are used in conjunction with wait and notify methods. Every class inherits from <FONT FACE="Courier New">Object</FONT> three &quot;wait methods&quot; (overloaded forms of a method named <FONT FACE="Courier New">wait()</FONT>) and two &quot;notify methods&quot; (<FONT FACE="Courier New">notify()</FONT> and <FONT FACE="Courier New">notifyAll()</FONT>). When a thread invokes a wait method on an object, the Java Virtual Machine suspends that thread and adds it to that objectís wait set. When a thread invokes a notify method on an object, the virtual machine will at some future time wake up one or more threads from that objectís wait set. As with the data that implements an objectís lock, the data that implements an objectís wait set is not needed unless a wait or notify method is actually invoked on the object. As a result, many implementations of the Java Virtual Machine may keep the wait set data separate from the actual object data. Such implementations could allocate the data needed to represent an objectís wait set when a wait or notify method is first invoked on that object by the running application. For more information about locks and wait sets, see Chapter 20, &quot;Thread Synchronization.&quot;</P>
<P>One last example of a type of data that may be included as part of the image of an object on the heap is any data needed by the garbage collector. The garbage collector must in some way keep track of which objects are referenced by the program. This task invariably requires data to be kept for each object on the heap. The kind of data required depends upon the garbage collection technique being used. For example, if an implementation uses a <I>mark and sweep</I> algorithm, it must be able to mark an object as referenced or unreferenced. For each unreferenced object, it may also need to indicate whether or not the objectís finalizer has been run. As with thread locks, this data may be kept separate from the object image. Some garbage collection techniques only require this extra data while the garbage collector is actually running. A mark and sweep algorithm, for instance, could potentially use a separate bitmap for marking referenced and unreferenced objects. More detail on various garbage collection techniques, and the data that is required by each of them, is given in Chapter 9, &quot;Garbage Collection.&quot;</P>
<P>In addition to data that a garbage collector uses to distinguish between reference and unreferenced objects, a garbage collector needs data to keep track of which objects on which it has already executed a finalizer. Garbage collectors must run the finalizer of any object whose class declares one before it reclaims the memory occupied by that object. The Java language specification states that a garbage collector will only execute an objectís finalizer once, but allows that finalizer to &quot;resurrect&quot; the object: to make the object referenced again. When the object becomes unreferenced for a second time, the garbage collector must not finalize it again. Because most objects will likely not have a finalizer, and very few of those will resurrect their objects, this scenario of garbage collecting the same object twice will probably be extremely rare. As a result, the data used to keep track of objects that have already been finalized, though logically part of the data associated with an object, will likely not be part of the object representation on the heap. In most cases, garbage collectors will keep this information in a separate place. Chapter 9, &quot;Garbage Collection,&quot; gives more information about finalization.</P>
<I><P>Array Representation</P>
</I><P>In Java, arrays are full-fledged objects. Like objects, arrays are always stored on the heap. Also like objects, implementation designers can decide how they want to represent arrays on the heap.</P>
<P>Arrays have a <FONT FACE="Courier New">Class</FONT> instance associated with their class, just like any other object. All arrays of the same dimension and type have the same class. The length of an array (or the lengths of each dimension of a multidimensional array) does not play any role in establishing the arrayís class. For example, an array of three <FONT FACE="Courier New">int</FONT>s has the same class as an array of three hundred <FONT FACE="Courier New">int</FONT>s. The length of an array is considered part of its instance data.</P>
<P>The name of an arrayís class has one open square bracket for each dimension plus a letter or string representing the arrayís type. For example, the class name for an array of <FONT FACE="Courier New">int</FONT>s is <FONT FACE="Courier New">"[I"</FONT>. The class name for a three-dimensional array of <FONT FACE="Courier New">byte</FONT>s is <FONT FACE="Courier New">"[[[B"</FONT>. The class name for a two-dimensional array of <FONT FACE="Courier New">Object</FONT>s is <FONT FACE="Courier New">"[[Ljava.lang.Object"</FONT>. The full details of this naming convention for array classes is given in Chapter 6, &quot;The Java Class File.&quot;</P>
<P>Multi-dimensional arrays are represented as arrays of arrays. A two dimensional array of <FONT FACE="Courier New">int</FONT>s, for example, would be represented by a one dimensional array of references to several one dimensional arrays of <FONT FACE="Courier New">int</FONT>s. This is shown graphically in Figure 5-8.</P>
<P><IMG SRC="fig5-8.gif" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/venners/images/fig5-8.gif" ALT="Figure 5-8"></P>

<P>The data that must be kept on the heap for each array is the arrayís length, the array data, and some kind of reference to the arrayís class data. Given a reference to an array, the virtual machine must be able to determine the arrayís length, to get and set its elements by index (checking to make sure the array bounds are not exceeded), and to invoke any methods declared by <FONT FACE="Courier New">Object</FONT>, the direct superclass of all arrays.</P>
<H3><P>The Program Counter</P>
</H3><P>Each thread of a running program has its own pc register, or program counter, which is created when the thread is started. The pc register is one word in size, so it can hold both a native pointer and a <FONT FACE="Courier New">returnValue</FONT>. As a thread executes a Java method, the pc register contains the address of the current instruction being executed by the thread. An &quot;address&quot; can be a native pointer or an offset from the beginning of a methodís bytecodes. If a thread is executing a native method, the value of the pc register is undefined.</P>
<H3><P>The Java Stack</P>
</H3><P>When a new thread is launched, the Java Virtual Machine creates a new Java stack for the thread. As mentioned earlier, a Java stack stores a threadís state in discrete frames. The Java Virtual Machine only performs two operations directly on Java Stacks: it pushes and pops frames.</P>
<P>The method that is currently being executed by a thread is the threadís <I>current method</I>. The stack frame for the current method is the <I>current frame</I>. The class in which the current method is defined is called the <I>current class</I>, and the current classís constant pool is the <I>current constant pool</I>. As it executes a method, the Java Virtual Machine keeps track of the current class and current constant pool. When the virtual machine encounters instructions that operate on data stored in the stack frame, it performs those operations on the current frame.</P>
<P>When a thread invokes a Java method, the virtual machine creates and pushes a new frame onto the threadís Java stack. This new frame then becomes the current frame. As the method executes, it uses the frame to store parameters, local variables, intermediate computations, and other data.</P>
<P>A method can complete in either of two ways. If a method completes by returning, it is said to have <I>normal completion</I>.  If it completes by throwing an exception, it is said to have <I>abrupt completion</I>. When a method completes, whether normally or abruptly, the Java Virtual Machine pops and discards the methodís stack frame. The frame for the previous method then becomes the current frame.</P>
<P>All the data on a threadís Java stack is private to that thread. There is no way for a thread to access or alter the Java stack of another thread. Because of this, you need never worry about synchronizing multi-threaded access to local variables in your Java programs. When a thread invokes a method, the methodís local variables are stored in a frame on the invoking threadís Java stack. Only one thread can ever access those local variables: the thread that invoked the method.</P>
<P>Like the method area and heap, the Java stack and stack frames need not be contiguous in memory. Frames could be allocated on a contiguous stack, or they could be allocated on a heap, or some combination of both. The actual data structures used to represent the Java stack and stack frames is a decision of implementation designers. Implementations may allow users or programmers to specify an initial size for Java stacks, as well as a maximum or minimum size.</P>
<H3><P>The Stack Frame</P>
</H3><P>The stack frame has three parts: local variables, operand stack, and frame data. The sizes of the local variables and operand stack, which are measured in words, depend upon the needs of each individual method. These sizes are determined at compile time and included in the class file data for each method. The size of the frame data is implementation dependent.</P>
<P>When the Java Virtual Machine invokes a Java method, it checks the class data to determine the number of words required by the method in the local variables and operand stack. It creates a stack frame of the proper size for the method and pushes it onto the Java stack.</P>
<I><P>Local Variables</P>
</I><P>The local variables section of the Java stack frame is organized as a zero-based array of words. Instructions that use a value from the local variables section provide an index into the zero-based array. Values of type <FONT FACE="Courier New">int</FONT>, <FONT FACE="Courier New">float</FONT>, <FONT FACE="Courier New">reference</FONT>, and <FONT FACE="Courier New">returnValue</FONT> occupy one entry in the local variables array. Values of type <FONT FACE="Courier New">byte</FONT>, <FONT FACE="Courier New">short</FONT>, and <FONT FACE="Courier New">char</FONT> are converted to <FONT FACE="Courier New">int</FONT> before being stored into the local variables. Values of type <FONT FACE="Courier New">long</FONT> and <FONT FACE="Courier New">double</FONT> occupy two consecutive entries in the array.</P>
<P>To refer to a long or double in the local variables, instructions provide the index of the first of the two consecutive entries occupied by the value. For example, if a <FONT FACE="Courier New">long</FONT> occupies array entries three and four, instructions would refer to that <FONT FACE="Courier New">long</FONT> by index three. All values in the local variables are word-aligned. Dual-entry <FONT FACE="Courier New">long</FONT>s and <FONT FACE="Courier New">double</FONT>s can start at any index.</P>
<P>The local variables section contains a methodís parameters and local variables. Compilers place the parameters into the local variable array first, in the order in which they are declared. Figure 5-9 shows the local variables section for the following two methods:</P>
<PRE><P><FONT FACE="Courier New">begin</FONT></P>
<FONT SIZE="2"><P></FONT><FONT FACE="Courier New">// On CD-ROM in file jvm/ex3/Example3a.java
<P>class Example3a {</P>
<P>&nbsp;</P>
<P>    public static int runClassMethod(int i, long l, float f,</P>
<P>        double d, Object o, byte b) {</P>
<P>&nbsp;</P>
<P>        return 0;</P>
<P>    }</P>
<P>&nbsp;</P>
<P>    public int runInstanceMethod(char c, double d, short s,</P>
<P>        boolean b) {</P>
<P>&nbsp;</P>
<P>        return 0;</P>
<P>    }</P>
<P>}</P>
</FONT><FONT SIZE="2"><P>&nbsp;</P></FONT><FONT FACE="Courier New">end</FONT></P></PRE>
<P><IMG SRC="fig5-9.gif" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/venners/images/fig5-9.gif" ALT="Figure 5-9"></P>

<P>Note that Figure 5-9 shows that the first parameter in the local variables for <FONT FACE="Courier New">runInstanceMethod()</FONT> is of type <FONT FACE="Courier New">reference</FONT>, even though no such parameter appears in the source code. This is the hidden <FONT FACE="Courier New">this</FONT> reference passed to every instance method. Instance methods use this reference to access the instance data of the object upon which they were invoked. As you can see by looking at the local variables for <FONT FACE="Courier New">runClassMethod()</FONT> in Figure 5-9, class methods do not receive a hidden <FONT FACE="Courier New">this</FONT>. Class methods are not invoked on objects. You canít directly access a classís instance variables from a class method, because there is no instance associated with the method invocation.</P>
<P>Note also that types <FONT FACE="Courier New">byte</FONT>, <FONT FACE="Courier New">short</FONT>, <FONT FACE="Courier New">char</FONT>, and <FONT FACE="Courier New">boolean</FONT> in the source code become <FONT FACE="Courier New">int</FONT>s in the local variables. This is also true of the operand stack. As mentioned earlier, the <FONT FACE="Courier New">boolean</FONT> type is not supported directly by the Java Virtual Machine. The Java compiler always uses <FONT FACE="Courier New">int</FONT>s to represent <FONT FACE="Courier New">boolean</FONT> values in the local variables or operand stack. Data types <FONT FACE="Courier New">byte</FONT>, <FONT FACE="Courier New">short</FONT>, and <FONT FACE="Courier New">char</FONT>, however, are supported directly by the Java Virtual Machine. These can be stored on the heap as instance variables or array elements, or in the method area as class variables. When placed into local variables or the operand stack, however, values of type <FONT FACE="Courier New">byte</FONT>, <FONT FACE="Courier New">short</FONT>, and <FONT FACE="Courier New">char</FONT> are converted into <FONT FACE="Courier New">int</FONT>s. They are manipulated as <FONT FACE="Courier New">int</FONT>s while on the stack frame, then converted back into <FONT FACE="Courier New">byte</FONT>, <FONT FACE="Courier New">short</FONT>, or <FONT FACE="Courier New">char</FONT> when stored back into heap or method area.</P>
<P>Also note that <FONT FACE="Courier New">Object</FONT> <FONT FACE="Courier New">o</FONT> is passed as a reference to <FONT FACE="Courier New">runClassMethod()</FONT>. In Java, all objects are passed by reference. As all objects are stored on the heap, you will never find an image of an object in the local variables or operand stack, only object references.</P>
<P>Aside from a methodís parameters, which compilers must place into the local variables array first and in order of declaration, Java compilers can arrange the local variables array as they wish. Compilers can place the methodís local variables into the array in any order, and they can use the same array entry for more than one local variable. For example, if two local variables have limited scopes that donít overlap, such as the <FONT FACE="Courier New">i</FONT> and <FONT FACE="Courier New">j</FONT> local variables in <FONT FACE="Courier New">Example3b</FONT> below, compilers are free to use the same array entry for both variables. During the first half of the method, before <FONT FACE="Courier New">j</FONT> comes into scope, entry zero could be used for <FONT FACE="Courier New">i</FONT>. During the second half of the method, after <FONT FACE="Courier New">i</FONT> has gone out of scope, entry zero could be used for <FONT FACE="Courier New">j</FONT>.</P>
<PRE><P><FONT FACE="Courier New">begin</FONT></P>
<FONT SIZE="2"><P></FONT><FONT FACE="Courier New">// On CD-ROM in file jvm/ex3/Example3b.java
<P>class Example3b {</P>
<P>&nbsp;</P>
<P>    public static void runtwoLoops() {</P>
<P>&nbsp;</P>
<P>        for (int i = 0; i &lt; 10; ++i) {</P>
<P>            System.out.println(i);</P>
<P>        }</P>
<P>&nbsp;</P>
<P>        for (int j = 9; j </FONT>= 0; --j) {</P>
<P>            System.out.println(j);</P>
<P>        }</P>
<P>    }</P>
<P>}</P>
</FONT><FONT SIZE="2"><P>&nbsp;</P></FONT><FONT FACE="Courier New">end</FONT></P></PRE>
<P>As with all the other runtime memory areas, implementation designers can use whatever data structures they deem most appropriate to represent the local variables. The Java Virtual Machine specification does not indicate how <FONT FACE="Courier New">long</FONT>s and <FONT FACE="Courier New">double</FONT>s should be split across the two array entries they occupy. Implementations that use a word size of 64 bits could, for example, store the entire long or double in the lower of the two consecutive entries, leaving the higher entry unused.</P>
<I><P>Operand Stack</P>
</I><P>Like the local variables, the operand stack is organized as an array of words. But unlike the local variables, which are accessed via array indices, the operand stack is accessed by pushing and popping values. If an instruction pushes a value onto the operand stack, a later instruction can pop and use that value.</P>
<P>The virtual machine stores the same data types in the operand stack that it stores in the local variables: <FONT FACE="Courier New">int</FONT>, <FONT FACE="Courier New">long</FONT>, <FONT FACE="Courier New">float</FONT>, <FONT FACE="Courier New">double</FONT>, <FONT FACE="Courier New">reference</FONT>, and <FONT FACE="Courier New">returnType</FONT>. It converts values of type <FONT FACE="Courier New">byte</FONT>, <FONT FACE="Courier New">short</FONT>, and <FONT FACE="Courier New">char</FONT> to <FONT FACE="Courier New">int</FONT> before pushing them onto the operand stack.</P>
<P>Other than the program counter, which canít be directly accessed by instructions, the Java Virtual Machine has no registers. The Java Virtual Machine is stack-based rather than register-based because its instructions take their operands from the operand stack rather than from registers. Instructions can also take operands from other places, such as immediately following the opcode (the byte representing the instruction) in the bytecode stream, or from the constant pool. The Java Virtual Machine instruction setís main focus of attention, however, is the operand stack.</P>
<P>The Java Virtual Machine uses the operand stack as a work space. Many instructions pop values from the operand stack, operate on them, and push the result. For example, the <FONT FACE="Courier New">iadd</FONT> instruction adds two integers by popping two <FONT FACE="Courier New">int</FONT>s off the top of the operand stack, adding them, and pushing the <FONT FACE="Courier New">int</FONT> result. Here is how a Java Virtual Machine would add two local variables that contain <FONT FACE="Courier New">int</FONT>s and store the <FONT FACE="Courier New">int</FONT> result in a third local variable:</P>
<PRE><P><FONT FACE="Courier New">begin</FONT></P>
<FONT FACE="Courier New"><P>iload_0    // push the int in local variable 0 onto the stack</P>
<P>iload_1    // push the int in local variable 1 onto the stack</P>
<P>iadd       // pop two ints, add them, push result</P>
<P>istore_2   // pop int, store into local variable 2</P>
</FONT><P><FONT FACE="Courier New">end</FONT></P></PRE>
<P>In this sequence of bytecodes, the first two instructions, <FONT FACE="Courier New">iload_0</FONT> and <FONT FACE="Courier New">iload_1</FONT>, push the <FONT FACE="Courier New">int</FONT>s stored in local variable positions zero and one onto the operand stack. The <FONT FACE="Courier New">iadd</FONT> instruction pops those two <FONT FACE="Courier New">int</FONT> values, adds them, and pushes the <FONT FACE="Courier New">int</FONT> result back onto the operand stack. The fourth instruction, <FONT FACE="Courier New">istore_2</FONT>, pops the result of the add off the top of the operand stack and stores it into local variable position two. In Figure 5-10, you can see a graphical depiction of the state of the local variables and operand stack while executing the above instructions. In this figure, unused slots of the local variables and operand stack are left blank.</P>
<P><IMG SRC="fig5-10.gif" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/venners/images/fig5-10.gif" ALT="Figure 5-10"></P>

<I><P>Frame Data</P>
</I><P>In addition to the local variables and operand stack, the Java stack frame includes data to support constant pool resolution, normal method return, and exception dispatch. This data is stored in the <I>frame data</I> portion of the Java stack frame.</P>
<P>Many instructions in the Java Virtual Machineís instruction set refer to entries in the constant pool. Some instructions merely push constant values of type <FONT FACE="Courier New">int</FONT>, <FONT FACE="Courier New">long</FONT>, <FONT FACE="Courier New">float</FONT>, <FONT FACE="Courier New">double</FONT>, or <FONT FACE="Courier New">String</FONT> from the constant pool onto the operand stack. Some instructions use constant pool entries to refer to classes or arrays to instantiate, fields to access, or methods to invoke. Other instructions determine whether a particular object is a descendant of a particular class or interface specified by a constant pool entry.</P>
<P>Whenever the Java Virtual Machine encounters any of the instructions that refer to an entry in  the constant pool, it uses the frame dataís pointer to the constant pool to access that information. As mentioned earlier, references to types, fields, and methods in the constant pool are initially symbolic. When the virtual machine looks up a constant pool entry that refers to a class, interface, field, or method, that reference may still be symbolic. If so, the virtual machine must resolve the reference at that time.</P>
<P>Aside from constant pool resolution, the frame data must assist the virtual machine in processing a normal or abrupt method completion. If a method completes normally (by returning), the virtual machine must restore the stack frame of the invoking method. It must set the pc register to point to the instruction in the invoking method that follows the instruction that invoked the completing method. If the completing method returns a value, the virtual machine must push that value onto the operand stack of the invoking method.</P>
<P>The frame data must also contain some kind of reference to the methodís exception table, which the virtual machine uses to process any exceptions thrown during the course of execution of the method. An exception table, which is described in detail in Chapter 17, &quot;Exceptions,&quot; defines ranges within the bytecodes of a method that are protected by catch clauses. Each entry in an exception table gives a starting and ending position of the range protected by a catch clause, an index into the constant pool that gives the exception class being caught, and a starting position of the catch clauseís code.</P>
<P>When a method throws an exception, the Java Virtual Machine uses the exception table referred to by the frame data to determine how to handle the exception. If the virtual machine finds a matching catch clause in the methodís exception table, it transfers control to the beginning of that catch clause. If the virtual machine doesnít find a matching catch clause, the method completes abnormally. The virtual machine uses the information in the frame data to restore the invoking methodís frame. It then rethrows the same exception in the context of the invoking method.</P>
<P>In addition to data to support constant pool resolution, normal method return, and exception dispatch, the stack frame may also include other information that is implementation dependent, such as data to support debugging.</P>
<I><P>Possible Implementations of the Java Stack</P>
</I><P>Implementation designers can represent the Java stack in whatever way they wish. As mentioned earlier, one potential way to implement the stack is by allocating each frame separately from a heap. As an example of this approach, consider the following class:</P>
<PRE><P><FONT FACE="Courier New">begin</FONT></P>
<FONT SIZE="2"><P></FONT><FONT FACE="Courier New">// On CD-ROM in file jvm/ex3/Example3c.java
<P>class Example3c {</P>
<P>&nbsp;</P>
<P>    public static void addAndPrint() {</P>
<P>        double result = addTwoTypes(1, 88.88);</P>
<P>        System.out.println(result);</P>
<P>    }</P>
<P>&nbsp;</P>
<P>    public static double addTwoTypes(int i, double d) {</P>
<P>        return i + d;</P>
<P>    }</P>
<P>}</P>
</FONT><FONT SIZE="2"><P>&nbsp;</P></FONT><FONT FACE="Courier New">end</FONT></P></PRE>
<P>Figure 5-11 shows three snapshots of the Java stack for a thread that invokes the <FONT FACE="Courier New">addAndPrint()</FONT> method. In the implementation of the Java Virtual Machine represented in this figure, each frame is allocated separately from a heap. To invoke the <FONT FACE="Courier New">addTwoTypes()</FONT> method, the <FONT FACE="Courier New">addAndPrint()</FONT> method first pushes an <FONT FACE="Courier New">int</FONT> one and <FONT FACE="Courier New">double</FONT> 88.88 onto its operand stack. It then invokes the <FONT FACE="Courier New">addTwoTypes()</FONT> method. </P>
<P><IMG SRC="fig5-11.gif" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/venners/images/fig5-11.gif" ALT="Figure 5-11"></P>

<P>The instruction to invoke <FONT FACE="Courier New">addTwoTypes()</FONT> refers to a constant pool entry. The Java Virtual Machine looks up the entry and resolves it if necessary.</P>
<P>Note that the <FONT FACE="Courier New">addAndPrint()</FONT> method uses the constant pool to identify the <FONT FACE="Courier New">addTwoTypes()</FONT> method, even though it is part of the same class. Like references to fields and methods of other classes, references to the fields and methods of the <I>same</I> class are initially symbolic and must be resolved before they are used.</P>
<P>The resolved constant pool entry points to information in the method area about the <FONT FACE="Courier New">addTwoTypes()</FONT> method. The virtual machine uses this information to determine the sizes required by <FONT FACE="Courier New">addTwoTypes()</FONT> for the local variables and operand stack. In the class file generated by Sunís <FONT FACE="Courier New">javac</FONT> compiler from the JDK 1.1, <FONT FACE="Courier New">addTwoTypes()</FONT> requires three words in the local variables and four words in the operand stack. (As mentioned earlier, the size of the frame data portion is implementation dependent.) The virtual machine allocates enough memory for the <FONT FACE="Courier New">addTwoTypes()</FONT> frame from a heap. It then pops the <FONT FACE="Courier New">double</FONT> and <FONT FACE="Courier New">int</FONT> parameters (88.88 and one) from <FONT FACE="Courier New">addAndPrint()</FONT>ís operand stack and places them into <FONT FACE="Courier New">addTwoType()</FONT>ís local variable slots one and zero.</P>
<P>When <FONT FACE="Courier New">addTwoTypes()</FONT> returns, it first pushes the <FONT FACE="Courier New">double</FONT> return value (in this case, 89.88) onto its operand stack. The virtual machine uses the information in the frame data to locate the stack frame of the invoking method, <FONT FACE="Courier New">addAndPrint()</FONT>. It pushes the <FONT FACE="Courier New">double</FONT> return value onto <FONT FACE="Courier New">addAndPrint()</FONT>ís operand stack and frees the memory occupied by <FONT FACE="Courier New">addTwoType()</FONT>ís frame. It makes <FONT FACE="Courier New">addAndPrint()</FONT>ís frame current and continues executing the <FONT FACE="Courier New">addAndPrint()</FONT> method at the first instruction past the <FONT FACE="Courier New">addTwoType()</FONT> method invocation.</P>
<P>Figure 5-12 shows snapshots of the Java stack of a different virtual machine implementation executing the same methods. Instead of allocating each frame separately from a heap, this implementation allocates frames from a contiguous stack. This approach allows the implementation to overlap the frames of adjacent methods. The portion of the invoking methodís operand stack that contains the parameters to the invoked method become the base of the invoked methodís local variables. In this example, <FONT FACE="Courier New">addAndPrint()</FONT>ís entire operand stack becomes <FONT FACE="Courier New">addTwoType()</FONT>ís entire local variables section.</P>
<P><IMG SRC="fig5-12.gif" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/venners/images/fig5-12.gif" ALT="Figure 5-12"></P>

<P>This approach saves memory space because the same memory is used by the calling method to store the parameters as is used by the invoked method to access the parameters. It saves time because the Java Virtual Machine doesnít have to spend time copying the parameter values from one frame to another.</P>
<P>Note that the operand stack of the current frame is always at the &quot;top&quot; of the Java stack. Although this may be easier to visualize in the contiguous memory implementation of Figure 5-12, it is true no matter how the Java stack is implemented. (As mentioned earlier, in all the graphical images of the stack shown in this book, the stack grows downwards. The &quot;top&quot; of the stack is always shown at the bottom of the picture.) Instructions that push values onto (or pop values off of) the operand stack always operate on the current frame. Thus, pushing a value onto the operand stack can be seen as pushing a value onto the top of the entire Java stack. In the remainder of this book, &quot;pushing a value onto the stack&quot; refers to pushing a value onto the operand stack of the current frame.</P>
<P>One other possible approach to implementing the Java stack is a hybrid of the two approaches shown in Figure 5-11 and Figure 5-12. A Java Virtual Machine implementation can allocate a chunk of contiguous memory from a heap when a thread starts. In this memory, the virtual machine can use the overlapping frames approach shown in Figure 5-12. If the stack outgrows the contiguous memory, the virtual machine can allocate another chunk of contiguous memory from the heap. It can use the separate frames approach shown in Figure 5-11 to connect the invoking methodís frame sitting in the old chunk with the invoked methodís frame sitting in the new chunk. Within the new chunk, it can once again use the contiguous memory approach.</P>
<H3><P>Native Method Stacks</P>
</H3><P>In addition to all the runtime data areas defined by the Java Virtual Machine specification and described above, a running Java application may use other data areas created by or for native methods. When a thread invokes a native method, it enters a new world in which the structures and security restrictions of the Java Virtual Machine no longer hamper its freedom. A native method can likely access the runtime data areas of the virtual machine (it depends upon the native method interface), but can also do anything else it wants. It may use registers inside the native processor, allocate memory on any number of native heaps, or use any kind of stack.</P>
<P>Native methods are inherently implementation dependent. Implementation designers are free to decide what mechanisms they will use to enable a Java application running on their implementation to invoke native methods.</P>
<P>Any native method interface will use some kind of native method stack. When a thread invokes a Java method, the virtual machine creates a new frame and pushes it onto the Java stack. When a thread invokes a native method, however, that thread leaves the Java stack behind. Instead of pushing a new frame onto the threadís Java stack, the Java Virtual Machine will simply dynamically link to and directly invoke the native method. One way to think of it is that the Java Virtual Machine is dynamically extending itself with native code. It is as if the Java Virtual Machine implementation is just calling another (dynamically linked) method within itself, at the behest of the running Java program.</P>
<P>If an implementationís native method interface uses a C-linkage model, then the native method stacks are C stacks. When a C program invokes a C function, the stack operates in a certain way. The arguments to the function are pushed onto the stack in a certain order. The return value is passed back to the invoking function in a certain way. This would be the behavior of the of native method stacks in that implementation.</P>
<P>A native method interface will likely (once again, it is up to the designers to decide) be able to call back into the Java Virtual Machine and invoke a Java method. In this case, the thread leaves the native method stack and enters another Java stack.</P>
<P>Figure 5-13 shows a graphical depiction of a thread that invokes a native method that calls back into the virtual machine to invoke another Java method. This figure shows the full picture of what a thread can expect inside the Java Virtual Machine. A thread may spend its entire lifetime executing Java methods, working with frames on its Java stack. Or, it may jump back and forth between the Java stack and native method stacks.</P>
<P><IMG SRC="fig5-13.gif" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/venners/images/fig5-13.gif" ALT="Figure 5-13"></P>

<P>As depicted in Figure 5-13, a thread first invoked two Java methods, the second of which invoked a native method. This act caused the virtual machine to use a native method stack. In this figure, the native method stack is shown as a finite amount of contiguous memory space. Assume it is a C stack. The stack area used by each C-linkage function is shown in gray and bounded by a dashed line. The first C-linkage function, which was invoked as a native method, invoked another C-linkage function. The second C-linkage function invoked a Java method through the native method interface. This Java method invoked another Java method, which is the current method shown in the figure.</P>
<P>As with the other runtime memory areas, the memory they occupied by native method stacks need not be of a fixed size. It can expand and contract as needed by the running application. Implementations may allow users or programmers to specify an initial size for the method area, as well as a maximum or minimum size.</P>
<H3><P>Execution Engine</P>
</H3><P>At the core of any Java Virtual Machine implementation is its execution engine. In the Java Virtual Machine specification, the behavior of the execution engine is defined in terms of an instruction set. For each instruction, the specification describes in detail <I>what</I> an implementation should do when it encounters the instruction as it executes bytecodes, but says very little about <I>how</I>. As mentioned in previous chapters, implementation designers are free to decide how their implementations will execute bytecodes. Their implementations can interpret, just-in-time compile, execute natively in silicon, use a combination of these, or dream up some brand new technique.</P>
<P>Similar to the three senses of the term &quot;Java Virtual Machine&quot; described at the beginning of this chapter, the term &quot;execution engine&quot; can also be used in any of three senses: an abstract specification, a concrete implementation, or a runtime instance. The abstract specification defines the behavior of an execution engine in terms of the instruction set. Concrete implementations, which may use a variety of techniques, are either software, hardware, or a combination of both. A runtime instance of an execution engine is a thread.</P>
<P>Each thread of a running Java application is a distinct instance of the virtual machineís execution engine. From the beginning of its lifetime to the end, a thread is either executing bytecodes or native methods. A thread may execute bytecodes directly, by interpreting or executing natively in silicon, or indirectly, by just-in-time compiling and executing the resulting native code. A Java Virtual Machine implementation may use other threads invisible to the running application, such as a thread that performs garbage collection. Such threads need not be &quot;instances&quot; of the implementationís execution engine. All threads that belong to the running application, however, are execution engines in action.</P>
<I><P>The Instruction Set</P>
</I><P>A method's bytecode stream is a sequence of instructions for the Java Virtual Machine. Each instruction consists of a one-byte <I>opcode</I> followed by zero or more <I>operands</I>. The opcode indicates the operation to be performed. Operands supply extra information needed by the Java Virtual Machine to perform the operation specified by the opcode. The opcode itself indicates whether or not it is followed by operands, and the form the operands (if any) take. Many Java Virtual Machine instructions take no operands, and therefore consist only of an opcode. Depending upon the opcode, the virtual machine may refer to data stored in other areas in addition to (or instead of) operands that trail the opcode. When it executes an instruction, the virtual machine may use entries in the current constant pool, entries in the current frameís local variables, or values sitting on the top of the current frameís operand stack.</P>
<P>The abstract execution engine runs by executing bytecodes one instruction at a time. This process takes place for each thread (execution engine instance) of the application running in the Java Virtual Machine. An execution engine fetches an opcode and, if that opcode has operands, fetches the operands. It executes the action requested by the opcode and its operands, then fetches another opcode. Execution of bytecodes continues until a thread completes either by returning from its starting method or by not catching a thrown exception.</P>
<P>From time to time, the execution engine may encounter an instruction that requests a native method invocation. On such occasions, the execution engine will dutifully attempt to invoke that native method. When the native method returns (if it completes normally, not by throwing an exception), the execution engine will continue executing the next instruction in the bytecode stream.</P>
<P>One way to think of native methods, therefore, is as programmer-customized extensions to the Java Virtual Machineís instruction set. If an instruction requests an invocation of a native method, the execution engine invokes the native method. Running the native method is how the Java Virtual Machine executes the instruction. When the native method returns, the virtual machine moves on to the next instruction. If the native method completes abnormally (by throwing an exception), the virtual machine follows the same steps to handle the exception as it does when any instruction throws an exception.</P>
<P>Part of the job of executing an instruction is determining the next instruction to execute. An execution engine determines the next opcode to fetch in one of three ways. For many instructions, the next opcode to execute directly follows the current opcode and its operands, if any, in the bytecode stream. For some instructions, such as <FONT FACE="Courier New">goto</FONT> or <FONT FACE="Courier New">return</FONT>, the execution engine determines the next opcode as part of its execution of the current instruction. If an instruction throws an exception, the execution engine determines the next opcode to fetch by searching for an appropriate catch clause.</P>
<P>Several instructions can throw exceptions. The <FONT FACE="Courier New">athrow</FONT> instruction, for example, throws an exception explicitly. This instruction is the compiled form of the <FONT FACE="Courier New">throw</FONT> statement in Java source code. Every time the <FONT FACE="Courier New">athrow</FONT> instruction is executed, it will throw an exception. Other instructions throw exceptions only when certain conditions are encountered. For example, if the Java Virtual Machine discovers, to its chagrin, that the program is attempting to perform an integer divide by zero, it will throw an <FONT FACE="Courier New">ArithmeticException</FONT>. This can occur while executing any of four instructions--<FONT FACE="Courier New">idiv</FONT>, <FONT FACE="Courier New">ldiv</FONT>, <FONT FACE="Courier New">irem</FONT>, and <FONT FACE="Courier New">lrem</FONT>--which perform divisions or calculate remainders on <FONT FACE="Courier New">int</FONT>s or <FONT FACE="Courier New">long</FONT>s.</P>
<P>Each type of opcode in the Java Virtual Machineís instruction set has a mnemonic. In the typical assembly language style, streams of Java bytecodes can be represented by their mnemonics followed by (optional) operand values.</P>
<P>For an example of methodís bytecode stream and mnemonics, consider the <FONT FACE="Courier New">doMathForever()</FONT> method of this class:</P>
<PRE><P><FONT FACE="Courier New">begin</FONT></P>
<FONT SIZE="2"><P></FONT><FONT FACE="Courier New">// On CD-ROM in file jvm/ex4/Act.java
<P>class Act {</P>
<P>&nbsp;</P>
<P>    public static void doMathForever() {</P>
<P>        int i = 0;</P>
<P>        for (;;) {</P>
<P>            i += 1;</P>
<P>            i *= 2;</P>
<P>        }</P>
<P>    }</P>
<P>}</P>
</FONT><FONT SIZE="2"><P>&nbsp;</P></FONT><FONT FACE="Courier New">end</FONT></P>
<P>The stream of bytecodes for <FONT FACE="Courier New">doMathForever()</FONT> can be disassembled into mnemonics as shown below. The Java Virtual Machine specification does not define any official syntax for representing the mnemonics of a methodís bytecodes. The code below illustrates the manner in which streams of bytecode mnemonics will be represented in this book. The left hand column shows the offset in bytes from the beginning of the methodís bytecodes to the start of each instruction. The center column shows the instruction and any operands. The right hand column contains comments, which are preceded with a double slash, just as in Java source code.</P>
<P><FONT FACE="Courier New">begin</FONT></P>
<FONT FACE="Courier New"><P>// Bytecode stream: 03 3b 84 00 01 1a 05 68 3b a7 ff f9</P>
<P>// Disassembly:</P>
<P>// Method void doMathForever()</P>
<P>// Left column: offset of instruction from beginning of method</P>
<P>// |   Center column: instruction mnemonic and any operands</P>
<P>// |   |                   Right column: comment</P>
<P>   0   iconst_0           // 03</P>
<P>   1   istore_0           // 3b</P>
<P>   2   iinc 0, 1          // 84 00 01</P>
<P>   5   iload_0            // 1a</P>
<P>   6   iconst_2           // 05</P>
<P>   7   imul               // 68</P>
<P>   8   istore_0           // 3b</P>
<P>   9   goto 2            // a7 ff f9</P>
</FONT><P><FONT FACE="Courier New">end</FONT></P></PRE>
<P>This way of representing mnemonics is very similar to the output of the <FONT FACE="Courier New">javap</FONT> program of Sunís JDK. <FONT FACE="Courier New">javap</FONT> allows you to look at the bytecode mnemonics of the methods of any class file. Note that jump addresses are given as offsets from the beginning of the method. The <FONT FACE="Courier New">goto</FONT> instruction causes the virtual machine to jump to the instruction at offset two (an <FONT FACE="Courier New">iinc</FONT>). The actual operand in the stream is minus seven. To execute this instruction, the virtual machine adds the operand to the current contents of the pc register. The result is the address of the <FONT FACE="Courier New">iinc</FONT> instruction at offset two. To make the mnemonics easier to read, the operands for jump instructions are shown as if the addition has already taken place. Instead of saying &quot;<FONT FACE="Courier New">goto -7</FONT>,&quot; the mnemonics say, &quot;<FONT FACE="Courier New">goto 2</FONT>.&quot;</P>
<P>The central focus of the Java Virtual Machineís instruction set is the operand stack. Values are generally pushed onto the operand stack before they are used. Although the Java Virtual Machine has no registers for storing arbitrary values, each method has a set of local variables. The instruction set treats the local variables, in effect, as a set of registers that are referred to by indexes. Nevertheless, other than the <FONT FACE="Courier New">iinc</FONT> instruction, which increments a local variable directly, values stored in the local variables must be moved to the operand stack before being used.</P>
<P>For example, to divide one local variable by another, the virtual machine must push both onto the stack, perform the division, and then store the result back into the local variables. To move the value of an array element or object field into a local variable, the virtual machine must first push the value onto the stack, then store it into the local variable. To set an array element or object field to a value stored in a local variable, the virtual machine must follow the reverse procedure. First, it must push the value of the local variable onto the stack, then pop it off the stack and into the array element or object field on the heap.</P>
<P>Several goals--some conflicting--guided the design of the Java Virtual Machineís instruction set. These goals are basically the same as those described in Part I of this book as the motivation behind Javaís entire architecture: platform independence, network mobility, and security.</P>
<P>The platform independence goal was a major influence in the design of the instruction set. The instruction setís stack-centered approach, described above, was chosen over a register-centered approach to facilitate efficient implementation on architectures with few or irregular registers, such as the Intel 80X86. This feature of the instruction set--the stack-centered design--make it easier to implement the Java Virtual Machine on a wide variety of host architectures.</P>
<P>As mentioned in Chapter 4, &quot;Network Mobility,&quot; one major design consideration was class file compactness. Compactness is important because it facilitates speedy transmission of class files across networks. In the bytecodes stored in class files, all instructions--except two that deal with table jumping--are aligned on byte boundaries. The total number of opcodes is small enough so that opcodes occupy only one byte. This design strategy favors class file compactness possibly at the cost of some performance when the program runs. In some Java Virtual Machine implementations, especially those executing bytecodes in silicon, the single-byte opcode may preclude certain optimizations that could improve performance. Also, better performance may have been possible on some implementations if the bytecode streams were word-aligned instead of byte-aligned. (An implementation could always realign bytecode streams, or translate opcodes into a more efficient form as classes are loaded. Bytecodes are byte-aligned in the class file and in the specification of the abstract method area and execution engine. Concrete implementations can store the loaded bytecode streams any way they wish.)</P>
<P>Another goal that guided the design of the instruction set was the ability to do bytecode verification, especially all at once by a data flow analyzer. The verification capability is needed as part of Javaís security framework. The ability to use a data flow analyzer on the bytecodes when they are loaded, rather than verifying each instruction as it is executed, facilitates execution speed. One way this design goal manifests itself in the instruction set is that most opcodes indicate the type they operate on.</P>
<P>For example, instead of simply having one instruction that pops a word from the operand stack and stores it in a local variable, the Java Virtual Machineís instruction set has two. One instruction, <FONT FACE="Courier New">istore</FONT>, pops and stores an <FONT FACE="Courier New">int</FONT>. The other instruction, <FONT FACE="Courier New">fstore</FONT>, pops and stores a <FONT FACE="Courier New">float</FONT>. Both of these instructions perform the exact same function when executed: they pop a word and store it. Distinguishing between popping and storing an <FONT FACE="Courier New">int</FONT> versus a <FONT FACE="Courier New">float</FONT> is important only to the verification process.</P>
<P>For many instructions, the virtual machine needs to know the types being operated on to know how to perform the operation. For example, the Java Virtual Machine supports two ways of adding two words together, yielding a one-word result. One addition treats the words as <FONT FACE="Courier New">int</FONT>s, the other as <FONT FACE="Courier New">float</FONT>s. The difference between these two instructions facilitates verification, but also tells the virtual machine whether it should perform integer or floating point arithmetic.</P>
<P>A few instructions operate on any type. The <FONT FACE="Courier New">dup</FONT> instruction, for example, duplicates the top word of a stack irrespective of its type. Some instructions, such as <FONT FACE="Courier New">goto</FONT>, donít operate on typed values. The majority of the instructions, however, operate on a specific type. The mnemonics for most of these &quot;typed&quot; instructions indicate their type by a single character prefix that starts their mnemonic. Table 5-2 shows the prefixes for the various types. A few instructions, such as <FONT FACE="Courier New">arraylength</FONT> or <FONT FACE="Courier New">instanceof</FONT>, donít include a prefix because their type is obvious. The <FONT FACE="Courier New">arraylength</FONT> opcode requires an array reference. The <FONT FACE="Courier New">instanceof</FONT> opcode requires an object reference.</P>
<P>Table 5-2. Type prefixes of bytecode mnemonics</P>
<P><TABLE WIDTH="500">
<TR><TD VALIGN="TOP"><STRONG>Type</STRONG></TD><TD VALIGN="TOP"><STRONG>Code</STRONG></TD><TD VALIGN="TOP"><STRONG>Example</STRONG></TD><TD VALIGN="TOP"><STRONG>Description</STRONG></TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">byte</FONT></TD><TD VALIGN="TOP"><FONT FACE="Courier New">b</FONT></TD><TD VALIGN="TOP"><FONT FACE="Courier New">baload</FONT></TD><TD VALIGN="TOP">load <FONT FACE="Courier New">byte</FONT> from array</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">short</FONT></TD><TD VALIGN="TOP"><FONT FACE="Courier New">s</FONT></TD><TD VALIGN="TOP"><FONT FACE="Courier New">saload</FONT></TD><TD VALIGN="TOP">load <FONT FACE="Courier New">short</FONT> from array</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">int</FONT></TD><TD VALIGN="TOP"><FONT FACE="Courier New">i</FONT></TD><TD VALIGN="TOP"><FONT FACE="Courier New">iaload</FONT></TD><TD VALIGN="TOP">load <FONT FACE="Courier New">int</FONT> from array</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">long</FONT></TD><TD VALIGN="TOP"><FONT FACE="Courier New">l</FONT></TD><TD VALIGN="TOP"><FONT FACE="Courier New">laload</FONT></TD><TD VALIGN="TOP">load <FONT FACE="Courier New">long</FONT> from array</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">char</FONT></TD><TD VALIGN="TOP"><FONT FACE="Courier New">c</FONT></TD><TD VALIGN="TOP"><FONT FACE="Courier New">caload</FONT></TD><TD VALIGN="TOP">load <FONT FACE="Courier New">char</FONT> from array</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">float</FONT></TD><TD VALIGN="TOP"><FONT FACE="Courier New">f</FONT></TD><TD VALIGN="TOP"><FONT FACE="Courier New">faload</FONT></TD><TD VALIGN="TOP">load <FONT FACE="Courier New">float</FONT> from array</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">double</FONT></TD><TD VALIGN="TOP"><FONT FACE="Courier New">d</FONT></TD><TD VALIGN="TOP"><FONT FACE="Courier New">daload</FONT></TD><TD VALIGN="TOP">load <FONT FACE="Courier New">double</FONT> from array</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">reference</FONT></TD><TD VALIGN="TOP"><FONT FACE="Courier New">a</FONT></TD><TD VALIGN="TOP"><FONT FACE="Courier New">aaload</FONT></TD><TD VALIGN="TOP">load <FONT FACE="Courier New">reference</FONT> from array</TD></TR>
</TABLE>
<P>Values on the operand stack must be used in a manner appropriate to their type. It is illegal, for example, to push four <FONT FACE="Courier New">int</FONT>s, then add them as if they were two <FONT FACE="Courier New">long</FONT>s. It is illegal to push a <FONT FACE="Courier New">float</FONT> value onto the operand stack from the local variables, then store it as an <FONT FACE="Courier New">int</FONT> in an array on the heap. It is illegal to push a <FONT FACE="Courier New">double</FONT> value from an object field on the heap, then store the topmost of its two words into the local variables as an value of type <FONT FACE="Courier New">reference</FONT>. The strict type rules that are enforced by Java compilers must also be enforced by Java Virtual Machine implementations.</P>
<P>Implementations must also observe rules when executing instructions that perform generic stack operations independent of type. As mentioned above, the <FONT FACE="Courier New">dup</FONT> instruction pushes a copy of the top word of the stack, irrespective of type. This instruction can be used on any value that occupies one word: an <FONT FACE="Courier New">int</FONT>, <FONT FACE="Courier New">float</FONT>, <FONT FACE="Courier New">reference</FONT>, or <FONT FACE="Courier New">returnValue</FONT>. It is illegal, however, to use <FONT FACE="Courier New">dup</FONT> when the top of the stack contains either a <FONT FACE="Courier New">long</FONT> or <FONT FACE="Courier New">double</FONT>, the data types that occupy two consecutive operand stack locations. A <FONT FACE="Courier New">long</FONT> or <FONT FACE="Courier New">double</FONT> sitting on the top of the operand stack can be duplicated in their entirety by the <FONT FACE="Courier New">dup2</FONT> instruction, which pushes a copy of the top two words onto the operand stack. The generic instructions cannot be used to split up dual-word values.</P>
<P>To keep the instruction set small enough to enable each opcode to be represented by a single byte, not all operations are supported on all types. Most operations are not supported for types <FONT FACE="Courier New">byte</FONT>, <FONT FACE="Courier New">short</FONT>, and <FONT FACE="Courier New">char</FONT>. These types are converted to <FONT FACE="Courier New">int</FONT> when moved from the heap or method area to the stack frame. They are operated on as <FONT FACE="Courier New">int</FONT>s, then converted back to <FONT FACE="Courier New">byte</FONT>, <FONT FACE="Courier New">short</FONT>, or <FONT FACE="Courier New">char</FONT> before being stored back into the heap or method area.</P>
<P>Table 5-3 shows the computation types that correspond to each storage type in the Java Virtual Machine. As used here, a <I>storage type</I> is the manner in which values of the type are represented on the heap. The storage type corresponds to the type of the variable in Java source code. A <I>computation type</I> is the manner in which the type is represented on the Java stack frame.</P>
<P>Table 5-3. Storage and computation types inside the Java Virtual Machine</P>
<P><TABLE WIDTH="500">
<TR><TD VALIGN="TOP"><STRONG>Storage Type</STRONG></TD><TD VALIGN="TOP"><STRONG>Minimum Bits in Heap or Method Area</STRONG></TD><TD VALIGN="TOP"><STRONG>Computation Type Words in the Java Stack Frame</STRONG></TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">byte</FONT></TD><TD VALIGN="TOP">8<FONT FACE="Courier New">int</FONT></TD><TD VALIGN="TOP">load <FONT FACE="Courier New">byte</FONT> from array1</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">short</FONT></TD><TD VALIGN="TOP">16<FONT FACE="Courier New">int</FONT></TD><TD VALIGN="TOP">load <FONT FACE="Courier New">short</FONT> from array1</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">int</FONT></TD><TD VALIGN="TOP">32<FONT FACE="Courier New">int</FONT></TD><TD VALIGN="TOP">load <FONT FACE="Courier New">int</FONT> from array1</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">long</FONT></TD><TD VALIGN="TOP">64<FONT FACE="Courier New">long</FONT></TD><TD VALIGN="TOP">load <FONT FACE="Courier New">long</FONT> from array2</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">char</FONT></TD><TD VALIGN="TOP">16<FONT FACE="Courier New">int</FONT></TD><TD VALIGN="TOP">load <FONT FACE="Courier New">char</FONT> from array1</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">floa</FONT></TD><TD VALIGN="TOP">t32<FONT FACE="Courier New">floa</FONT></TD><TD VALIGN="TOP">tload <FONT FACE="Courier New">float</FONT> from array1</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">double</FONT></TD><TD VALIGN="TOP">64<FONT FACE="Courier New">double</FONT></TD><TD VALIGN="TOP">load <FONT FACE="Courier New">double</FONT> from array2</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">reference</FONT></TD><TD VALIGN="TOP">32<FONT FACE="Courier New">reference</FONT></TD><TD VALIGN="TOP">load <FONT FACE="Courier New">reference</FONT> from array1</TD></TR>
</TABLE>
<P>Implementations of the Java Virtual Machine must in some way ensure that values are operated on by instructions appropriate to their type. They can verify bytecodes up front as part of the class verification process, on the fly as the program executes, or some combination of both. Bytecode verification is described in more detail in Chapter 7, &quot;The Lifetime of a Class.&quot; The entire instruction set is covered in detail in Chapters 10 through 20.</P>
<I><P>Execution Techniques</P>
</I><P>Various execution techniques that may be used by an implementation--interpreting, just-in-time compiling, hot-spot compiling, native execution in silicon--were described in Chapter 1, &quot;Introduction to Javaís Architecture.&quot; The main point to remember about execution techniques is that an implementation can use any technique to execute bytecodes so long as it adheres to the semantics of the Java Virtual Machine instruction set.</P>
<I><P>Threads</P>
</I><P>The Java Virtual Machine specification defines a threading model that aims to facilitate implementation on a wide variety of architectures. One goal of the Java threading model is to enable implementation designers, where possible and appropriate, to use native threads. Alternatively, designers can implement a thread mechanism as part of their virtual machine implementation. One advantage to using native threads on a multi-processor host is that different threads of a Java application could run simultaneously on different processors.</P>
<P>One tradeoff of Javaís threading model is that the specification of priorities is lowest-common-denominator. A Java thread can run at any one of ten priorities. Priority one is the lowest, and priority ten is the highest. If designers use native threads, they can map the ten Java priorities onto the native priorities however seems most appropriate. The Java Virtual Machine specification defines the behavior of threads at different priorities only by saying that all threads at the highest priority will get some CPU time. Threads at lower priorities are guaranteed to get CPU time only when all higher priority threads are blocked. Lower priority threads <I>may</I> get some CPU time when higher priority threads arenít blocked, but there are no guarantees.</P>
<P>The specification doesnít assume time-slicing between threads of different priorities, because not all architectureís time-slice. (As used here, <I>time-slicing</I> means that all threads at all priorities will be guaranteed some CPU time, even when no threads are blocked.) Even among those architectures that do time-slice, the algorithms used to allot time slots to threads at various priorities can differ greatly.</P>
<P>As mentioned in Chapter 2, &quot;Platform Independence,&quot; you must not rely on time-slicing for program correctness. You should use thread priorities only to give the Java Virtual Machine hints at what it should spend more time on. To coordinate the activities of multiple threads, you should use synchronization.</P>
<P>The thread implementation of any Java Virtual Machine must support two aspects of <I>synchronization</I>: object locking and thread wait and notify. Object locking helps keep threads from interfering with one another while working independently on shared data. Thread wait and notify helps threads to cooperate with one another while working together toward some common goal. Running applications access the Java Virtual Machineís locking capabilities via the instruction set, and its wait and notify capabilities via the <FONT FACE="Courier New">wait()</FONT>, <FONT FACE="Courier New">notify()</FONT>, and <FONT FACE="Courier New">notifyAll()</FONT> methods of class <FONT FACE="Courier New">Object</FONT>. For more details, see Chapter 20, &quot;Thread Synchronization.&quot;</P>
<P>In the Java Virtual Machine Specification, the behavior of Java threads is defined in terms of <I>variables</I>, a <I>main memory</I>, and <I>working memories</I>. Each Java Virtual Machine instance has a main memory, which contains all the programís variables: instance variables of objects, components of arrays, and class variables. Each thread has a working memory, in which the thread stores &quot;working copies&quot; of variables it uses or assigns. Local variables and parameters, because they are private to individual threads, can be logically seen as part of either the working memory or main memory.</P>
<P>The Java Virtual Machine Specification defines many rules that govern the low-level interactions of threads with main memory. For example, one rule states that all operations on primitive types, except in some cases <FONT FACE="Courier New">long</FONT>s and <FONT FACE="Courier New">double</FONT>s, are <I>atomic</I>. For example, if two threads compete to write two different values to an <FONT FACE="Courier New">int</FONT> variable, even in the absence of synchronization, the variable will end up with one value or the other. The variable will not contain a corrupted value. In other words, one thread will win the competition and write its value to the variable first. The losing thread need not sulk, however, because it will write its value the variable second, overwriting the &quot;winning&quot; threadís value.</P>
<P>The exception to this rule is any <FONT FACE="Courier New">long</FONT> or <FONT FACE="Courier New">double</FONT> variable that is not declared <FONT FACE="Courier New">volatile</FONT>. Rather than being treated as a single atomic 64-bit value, such variables may be treated by some implementations as two atomic 32-bit values. Storing a non-volatile <FONT FACE="Courier New">long</FONT> to memory, for example, could involve two 32-bit write operations. This non-atomic treatment of <FONT FACE="Courier New">long</FONT>s and <FONT FACE="Courier New">double</FONT>s means that two threads competing to write two different values to a <FONT FACE="Courier New">long</FONT> or <FONT FACE="Courier New">double</FONT> variable can legally yield a corrupted result.</P>
<P>Although implementation designers are not required to treat operations involving non-volatile <FONT FACE="Courier New">long</FONT>s and <FONT FACE="Courier New">double</FONT>s atomically, the Java Virtual Machine specification encourages them to do so anyway. This non-atomic treatment of <FONT FACE="Courier New">long</FONT>s and <FONT FACE="Courier New">double</FONT>s is an exception to the general rule that operations on primitive types are atomic. This exception is intended to facilitate efficient implementation of the threading model on processors that donít provide efficient ways to transfer 64-bit values to and from memory. In the future, this exception may be eliminated. For the time being, however, Java programmers must be sure to synchronize access to shared <FONT FACE="Courier New">long</FONT>s and <FONT FACE="Courier New">double</FONT>s.</P>
<P>Fundamentally, the rules governing low-level thread behavior specify when a thread may and when it must:</P>
<OL><LI>copy values of variables from the main memory to its working memory, and</P>
<LI>write values from its working memory back into the main memory.</OL>
<P>For certain conditions, the rules specify a precise and predictable order of memory reads and writes. For other conditions, however, the rules do not specify any order. The rules are designed to enable Java programmers to build multi-threaded programs that exhibit predictable behavior, while giving implementation designers some flexibility. This flexibility enables designers of Java Virtual Machine implementations to take advantage of standard hardware and software techniques that can improve the performance of multi-threaded applications.</P>
<P>The fundamental high-level implication of all the low-level rules that govern the behavior of threads is this: If access to certain variables isnít synchronized, threads are allowed update those variables in main memory in any order. Without synchronization, your multi-threaded applications may exhibit surprising behavior on some Java Virtual Machine implementations. With proper use of synchronization, however, you can create multi-threaded Java applications that behave in a predictable way on any implementation of the Java Virtual Machine.</P>
<H3><P>Native Method Interface</P>
</H3><P>Java Virtual Machine implementations arenít required to support any particular native method interface. Some implementations may support no native method interfaces at all. Others may support several, each geared towards a different purpose.</P>
<P>Sunís Java Native Interface, or JNI, is geared towards portability. JNI is designed so it can be supported by any implementation of the Java Virtual Machine, no matter what garbage collection technique or object representation the implementation uses. This in turn enables developers to link the same (JNI compatible) native method binaries to any JNI-supporting virtual machine implementation on a particular host platform.</P>
<P>Implementation designers can choose to create proprietary native method interfaces in addition to, or instead of, JNI. To achieve its portability, the JNI uses a lot of indirection through pointers to pointers and pointers to functions. To obtain the ultimate in performance, designers of an implementation may decide to offer their own low-level native method interface that is tied closely to the structure of their particular implementation. Designers could also decide to offer a higher-level native method interface than JNI, such as one that brings Java objects into a component software model.</P>
<P>To do useful work, a native method must be able to interact to some degree with the internal state of the Java Virtual Machine instance. For example, a native method interface may allow native methods to do some or all of the following:</P>
<UL><LI> Pass and return data
<LI> Access instance variables or invoke methods in objects on the garbage-collected heap
<LI> Access class variables or invoke class methods
<LI> Accessing arrays
<LI> Lock an object on the heap for exclusive use by the current thread
<LI> Create new objects on the garbage-collected heap
<LI> Load new classes
<LI> Throw new exceptions
<LI> Catch exceptions thrown by Java methods that the native method invoked
<LI> Catch asynchronous exceptions thrown by the virtual machine
<LI> Indicate to the garbage collector that it no longer needs to use a particular object</UL>
<P>Designing a native method interface that offers these services can be complicated. The design needs to ensure that the garbage collector doesnít free any objects that are being used by native methods. If an implementationís garbage collector moves objects to keep heap fragmentation at a minimum, the native method interface design must make sure that either:</P>
<OL><LI>an object can be moved after its reference has been passed to a native method, or</P>
<LI>any objects whose references have been passed to a native method are pinned until the native method returns or otherwise indicates it is done with the objects</OL>
<P>As you can see, native method interfaces are very intertwined with the inner workings of a Java Virtual Machine.</P>
<H3><EM><P>The Real Machine</P>
</EM></H3><P>As mentioned at the beginning of this chapter, all the subsystems, runtime data areas, and internal behaviors defined by the Java Virtual Machine specification are abstract. Designers arenít required to organize their implementations around &quot;real&quot; components that map closely to the abstract components of the specification. The abstract internal components and behaviors are merely a vocabulary with which the specification defines the required external behavior of any Java Virtual Machine implementation.</P>
<P>In other words, an implementation can be anything on the inside, so long as it behaves like a Java Virtual Machine on the outside. Implementations must be able to recognize Java class files and must adhere to the semantics of the Java code the class files contain. But otherwise, anything goes. How bytecodes are executed, how the runtime data areas are organized, how garbage collection is accomplished, how threads are implemented, how the primordial class loader finds classes, what native method interfaces are supported--these are some of the many decisions left to implementation designers.</P>
<P>The flexibility of the specification gives designers the freedom to tailor their implementations to fit their circumstances. In some implementations, minimizing usage of resources may be critical. In other implementations, where resources are plentiful, maximizing performance may be the one and only goal.</P>
<P>By clearly marking the line between the external behavior and the internal implementation of a Java Virtual Machine, the specification preserves compatibility among all implementations while promoting innovation. Designers are encouraged to apply their talents and creativity towards building ever-better Java Virtual Machines.</P>
<H3><EM><P>Eternal Math: A Simulation</P>
</EM></H3><P>The CD-ROM contains several simulation applets that serve as interactive illustrations for the material presented in this book. The applet shown in Figure 5-14 simulates a Java Virtual Machine executing a few bytecodes. You can run this applet by loading <FONT FACE="Courier New">applets/EternalMath.html</FONT> from the CD-ROM into any Java enabled web browser or applet viewer that supports JDK 1.1.</P>
<P>The instructions in the simulation represent the body of the <FONT FACE="Courier New">doMathForever()</FONT> method of class <FONT FACE="Courier New">Act</FONT>, shown above in the &quot;Instruction Set&quot; section of this chapter. This simulation shows the local variables and operand stack of the current frame, the pc register, and the bytecodes in the method area. It also shows an optop register, which you can think of as part of the frame data of this particular implementation of the Java Virtual Machine. The optop register always points to one word beyond the top of the operand stack. </P>
<P>The applet has four buttons: Step, Reset, Run, and Stop. Each time you press the Step button, the Java Virtual Machine simulator will execute the instruction pointed to by the pc register. Initially, the pc register points to an <FONT FACE="Courier New">iconst_0</FONT> instruction. The first time you press the Step button, therefore, the virtual machine will execute <FONT FACE="Courier New">iconst_0</FONT>. It will push a zero onto the stack and set the pc register to point to the next instruction to execute. Subsequent presses of the Step button will execute subsequent instructions and the pc register will lead the way. If you press the Run button, the simulation will continue with no further coaxing on your part until you press the Stop button. To start the simulation over, press the Reset button.</P>
<P>The value of each register (pc and optop) is shown two ways. The contents of each register, an integer offset from the beginning of either the methodís bytecodes or the operand stack, is shown in an edit box. Also, a small arrow (either &quot;pc</FONT>&quot; or &quot;optop</FONT>&quot;) indicates the location contained in the register.</P>
<P>In the simulation the operand stack is shown growing down the panel (up in memory offsets) as words are pushed onto it. The top of the stack recedes back up the panel as words are popped from it.</P>
<P>The <FONT FACE="Courier New">doMathForever()</FONT> method has only one local variable, <FONT FACE="Courier New">i</FONT>, which sits at array position zero. The first two instructions, <FONT FACE="Courier New">iconst_0</FONT> and <FONT FACE="Courier New">istore_0</FONT> initialize the local variable to zero. The next instruction, <FONT FACE="Courier New">iinc</FONT>, increments <FONT FACE="Courier New">i</FONT> by one. This instruction implements the <FONT FACE="Courier New">i += 1</FONT> statement from <FONT FACE="Courier New">doMathForever()</FONT>. The next instruction, <FONT FACE="Courier New">iload_0</FONT>, pushes the value of the local variable onto the operand stack. <FONT FACE="Courier New">iconst_2</FONT> pushes an <FONT FACE="Courier New">int</FONT> 2 onto the operand stack. <FONT FACE="Courier New">imul</FONT> pops the top two <FONT FACE="Courier New">ints</FONT> from the operand stack, multiplies them, and pushes the result. The <FONT FACE="Courier New">istore_0</FONT> instruction pops the result of the multiply and puts it into the local variable. The previous four instructions implement the <FONT FACE="Courier New">i *= 2</FONT> statement from <FONT FACE="Courier New">doMathForever()</FONT>. The last instruction, <FONT FACE="Courier New">goto</FONT>, sends the program counter back to the <FONT FACE="Courier New">iinc</FONT> instruction. The <FONT FACE="Courier New">goto</FONT> implements the <FONT FACE="Courier New">for</FONT> <FONT FACE="Courier New">(;;)</FONT> loop of <FONT FACE="Courier New">doMathForever()</FONT>.</P>
<P>With enough patience and clicks of the Step button (or a long enough run of the Run button), you can get an arithmetic overflow. When the Java Virtual Machine encounters such a condition, it just truncates, as is shown by this simulation. It does not throw any exceptions.</P>
<P>For each step of the simulation, a panel at the bottom of the applet contains an explanation of what the next instruction will do. Happy clicking.</P>
<P><IMG SRC="fig5-14.gif" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/venners/images/fig5-14.gif" ALT="Figure 5-14"></P>

<H3><EM><P>On the CD-ROM</P>
</EM></H3><P>The CD-ROM contains the source code examples from this chapter in the <FONT FACE="Courier New">jvm</FONT> directory. The <I>Eternal Math</I> applet is contained in a web page on the CD-ROM in file <FONT FACE="Courier New">applets/EternalMath.html</FONT>. The source code for this applet is found alongside its class files, in the <FONT FACE="Courier New">applets/JVMSimulators</FONT> and <FONT FACE="Courier New">applets/JVMSimulators/COM/artima/jvmsim</FONT> directories.</P>
<H3><EM><P>The Resources Page</P>
</EM></H3><P>For links to more information about the Java Virtual Machine, visit the resources page for this chapter: <FONT FACE="Courier New"><A HREF="http://www.artima.com/insidejvm/jvm.html" tppabs="http://www.artima.com/insidejvm/jvm.html">http://www.artima.com/insidejvm/jvm.html</A></FONT>.</P>
<TABLE BORDER="0" WIDTH="100%">
<TR><TD><A HREF="http://www.pbg.mcgraw-hill.com/betabooks/stores.html" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/stores.html" target="bottom"><IMG SRC="hotkey.gif" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/images/hotkey.gif" ALIGN="LEFT" BORDER="0" WIDTH="40" HEIGHT="40" ALT="Orders"></A>
<IMG SRC="order_text.gif" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/images/order_text.gif" WIDTH="103" HEIGHT="41" ALT="Orders"></TD>
<TD ALIGN="RIGHT"><A HREF="chap04.html" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/venners/chap04.html"><IMG SRC="backward.gif" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/images/backward.gif" BORDER="0" ALT="Backward" WIDTH="32" HEIGHT="32"></A>&nbsp;<A HREF="chap06.html" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/venners/chap06.html"><IMG SRC="forward.gif" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/images/forward.gif" BORDER="0" ALT="Forward" WIDTH="32" HEIGHT="32"></A></TD></TR>
<TR><TD COLSPAN="2"><A HREF="mailto:computing@mcgraw-hill.com"><IMG SRC="hotkey.gif" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/images/hotkey.gif" ALIGN="LEFT" BORDER="0" WIDTH="40" HEIGHT="40" ALT="Comments"></A>
<IMG SRC="comment_text.gif" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/images/comment_text.gif" WIDTH="73" HEIGHT="39" ALT="Comments"></TD></TR>

</TABLE>
<HR>
<P ALIGN=CENTER>&nbsp;<A HREF="http://www.pbg.mcgraw-hill.com/computing/computing-home.html" tppabs="http://www.pbg.mcgraw-hill.com/computing/computing-home.html" TARGET="_top">COMPUTING
MCGRAW-HILL</A> | <A HREF="http://www.pbg.mcgraw-hill.com/betabooks/betabooks-home.html" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/betabooks-home.html" TARGET="_top">Beta Books</A>
| <A HREF="http://www.pbg.mcgraw-hill.com/computing/contact.html" tppabs="http://www.pbg.mcgraw-hill.com/computing/contact.html" TARGET="_top">Contact Us</A>
| <A HREF="http://www.pbg.mcgraw-hill.com/betabooks/stores.html" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/stores.html" TARGET="_top">Order Information</A>
| <A HREF="http://mcgraw-hill.inforonics.com/compsearch.shtml" tppabs="http://mcgraw-hill.inforonics.com/compsearch.shtml" TARGET="_top">Online Catalog</A></P>

<P ALIGN=CENTER><FONT SIZE="-1"><A HREF="http://www.pbg.mcgraw-hill.com/computing/computing-home.html" tppabs="http://www.pbg.mcgraw-hill.com/computing/computing-home.html" TARGET="_top">Computing McGraw-Hill</A> is an imprint of the <A HREF="http://www.pbg.mcgraw-hill.com/pbg-home.html" tppabs="http://www.pbg.mcgraw-hill.com/pbg-home.html" TARGET="_top">McGraw-Hill Professional Book Group</A>.</FONT></P>

<!-- begin footer -->
<HR>
<A HREF="http://www.mcgraw-hill.com/" tppabs="http://www.mcgraw-hill.com/" TARGET="_top"><IMG SRC="division-white.gif" tppabs="http://www.pbg.mcgraw-hill.com/images/division-white.gif" WIDTH="350" HEIGHT="44" ALT="A Division of the McGraw-Hill Companies" BORDER="0"></A><BR>
<FONT SIZE="-2">Copyright &copy; 1997 <A HREF="http://www.mcgraw-hill.com/" tppabs="http://www.mcgraw-hill.com/" TARGET="_top">
The McGraw-Hill Companies</A>. All rights reserved. Any use is subject to the 
<A HREF="http://www.mcgraw-hill.com/corporate/news_info/copyrttm.htm" tppabs="http://www.mcgraw-hill.com/corporate/news_info/copyrttm.htm" TARGET="_top">
Terms of Use</A>; the corporation also has a comprehensive <A HREF="http://www.mcgraw-hill.com/corporate/news_info/privacy.html" tppabs="http://www.mcgraw-hill.com/corporate/news_info/privacy.html" TARGET="_top">
Privacy Policy</A> governing information we may collect from our customers.</FONT>
<!-- end footer -->
</BODY>
</HTML>
