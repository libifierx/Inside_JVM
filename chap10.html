<!-- All material contained herein is copyright (c) McGraw-Hill Professional Books
All Rights Reserved. No use of this material may be made without express written
permission of the copyright holder. HTML conversions by Mega Space [barry@megaspace.com] -->

<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=ISO-8859-1">
<TITLE>Understanding Digital Signatures: Inside the Java Virtual Machine
 by Bill Venners - Beta Version</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<TABLE BORDER="0" WIDTH="100%">
<TR><TD><A HREF="http://www.pbg.mcgraw-hill.com/betabooks/stores.html" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/stores.html" target="bottom"><IMG SRC="hotkey.gif" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/images/hotkey.gif" ALIGN="LEFT" BORDER="0" WIDTH="40" HEIGHT="40" ALT="Orders"></A>
<IMG SRC="order_text.gif" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/images/order_text.gif" WIDTH="103" HEIGHT="41" ALT="Orders"></TD>
<TD ALIGN="RIGHT"><A HREF="chap09.html" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/venners/chap09.html"><IMG SRC="backward.gif" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/images/backward.gif" BORDER="0" ALT="Backward" WIDTH="32" HEIGHT="32"></A>&nbsp;<A HREF="chap11.html" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/venners/chap11.html"><IMG SRC="forward.gif" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/images/forward.gif" BORDER="0" ALT="Forward" WIDTH="32" HEIGHT="32"></A></TD></TR>
<TR><TD COLSPAN="2"><A HREF="mailto:computing@mcgraw-hill.com"><IMG SRC="hotkey.gif" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/images/hotkey.gif" ALIGN="LEFT" BORDER="0" WIDTH="40" HEIGHT="40" ALT="Comments"></A>
<IMG SRC="comment_text.gif" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/images/comment_text.gif" WIDTH="73" HEIGHT="39" ALT="Comments"></TD></TR>

<TR><TD COLSPAN="2"><FONT FACE="ARIEL,HELVETICA" SIZE="-1"><I>&copy; 1997 The McGraw-Hill Companies, Inc.  All rights reserved.  <BR>Any use of this Beta Book is subject to the rules stated in the <A HREF="http://www.mcgraw-hill.com/corporate/news_info/copyrttm.htm" tppabs="http://www.mcgraw-hill.com/corporate/news_info/copyrttm.htm" target="_top">Terms of Use</A>.</I></FONT><br>
<script language="javascript">
    document.write("<a href='http://banners.linkbuddies.com/click.php?id=237296'><img src='http://banners.linkbuddies.com/image.php?id=237296&ref=" + document.referrer + "' width=468 height=60 alt='Click Here' border=0></a>");
</script></TD></TR>

</TABLE>
<HR>
<P><H1>Chapter Ten</H1></P>
<P><H2>Stack and Local Variable Operations</H2></P>
<P>As mentioned in Chapter 5, &quot;The Java Virtual Machine,&quot; the abstract specification of the execution engine is defined in terms of an instruction set. The remaining chapters of this book (Chapters 10 through 20) are a tutorial of that instruction set. They describe the instructions in functional groups and give relevant background information for each group.</P>
<P>This chapter covers instructions that deal with the operand stack and local variables. As the Java Virtual Machine is a stack-based machine, almost all of its instructions involve the operand stack in some way. Most instructions push values, pop values, or both as they perform their functions. This chapter describes the instructions that focus most exclusively on the operand stack--those that push constants onto the operand stack, perform generic stack operations, and transfer values back and forth between the operand stack and local variables.</P>
<P>Accompanying this chapter on the CD-ROM is an applet that interactively illustrates the material presented in the chapter. The applet, named <I>Fibonacci Forever</I>, simulates the Java Virtual Machine executing a method that generates the Fibonacci sequence. In the process, it demonstrates how the virtual machine pushes constants, pops values to local variables, and pushes values from local variables. At the end of this chapter, you will find a description of this applet and the bytecodes it executes.</P>
<I><P>Pushing Constants Onto the Stack</P>
</I><P>Many opcodes push constants onto the stack. Opcodes indicate the constant value to push in three different ways. The constant value is either implicit in the opcode itself, follows the opcode in the bytecode stream as an operand, or is taken from the constant pool.</P>
<P>Some opcodes by themselves indicate a type and constant value to push. For example, the <CODE>iconst_1</CODE> opcode tells the Java Virtual Machine to push integer value one. Such opcodes are defined for some commonly pushed numbers of various types. All of these instructions are redundant to the instructions that take operands from the bytecode stream or refer to the constant pool, but these are more efficient. Because these instructions occupy only one byte in the bytecode stream, they increase the efficiency of bytecode execution and reduce the size of bytecode streams. The opcodes that push <FONT FACE="Courier New">int</FONT>s and <FONT FACE="Courier New">float</FONT>s are shown in Table 10-1.</P>
<P>Table 10-1. Pushing single-word constants onto the stack</P>
<TABLE WIDTH="500">
<TR><TD VALIGN="TOP"><STRONG>Opcode</STRONG></TD><TD VALIGN="TOP"><STRONG>Operand(s)</STRONG></TD><TD VALIGN="TOP"><STRONG>Description</STRONG></TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">iconst_m1</FONT></TD><TD VALIGN="TOP">(none)</TD><TD VALIGN="TOP">pushes <FONT FACE="Courier New">int</FONT> -1 onto the stack</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">iconst_0</FONT></TD><TD VALIGN="TOP">(none)</TD><TD VALIGN="TOP">pushes <FONT FACE="Courier New">int</FONT> 0 onto the stack</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">iconst_1</FONT></TD><TD VALIGN="TOP">(none)</TD><TD VALIGN="TOP">pushes <FONT FACE="Courier New">int</FONT> 1 onto the stack</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">iconst_2</FONT></TD><TD VALIGN="TOP">(none)</TD><TD VALIGN="TOP">pushes <FONT FACE="Courier New">int</FONT> 2 onto the stack</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">iconst_3</FONT></TD><TD VALIGN="TOP">(none)</TD><TD VALIGN="TOP">pushes <FONT FACE="Courier New">int</FONT> 3 onto the stack</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">iconst_4</FONT></TD><TD VALIGN="TOP">(none)</TD><TD VALIGN="TOP">pushes <FONT FACE="Courier New">int</FONT> 4 onto the stack</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">iconst_5</FONT></TD><TD VALIGN="TOP">(none)</TD><TD VALIGN="TOP">pushes <FONT FACE="Courier New">int</FONT> 5 onto the stack</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">fconst_0</FONT></TD><TD VALIGN="TOP">(none)</TD><TD VALIGN="TOP">pushes <FONT FACE="Courier New">float</FONT> 0 onto the stack</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">fconst_1</FONT></TD><TD VALIGN="TOP">(none)</TD><TD VALIGN="TOP">pushes <FONT FACE="Courier New">float</FONT> 1 onto the stack</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">fconst_2</FONT></TD><TD VALIGN="TOP">(none)</TD><TD VALIGN="TOP">pushes <FONT FACE="Courier New">float</FONT> 2 onto the stack</TD></TR>
</TABLE>
<P>The opcodes shown in the previous table push <FONT FACE="Courier New">int</FONT>s and <FONT FACE="Courier New">float</FONT>s, which are single-word values. Each slot on the Java stack is one word in size (at least 32 bits wide). Therefore each time an <FONT FACE="Courier New">int</FONT> or <FONT FACE="Courier New">float</FONT> is pushed onto the stack, it occupies one slot. </P>
<P>The opcodes shown in Table 10-2 push <FONT FACE="Courier New">long</FONT>s and <FONT FACE="Courier New">double</FONT>s. <FONT FACE="Courier New">long</FONT> and <FONT FACE="Courier New">double</FONT> values occupy 64 bits. Each time a <FONT FACE="Courier New">long</FONT> or <FONT FACE="Courier New">double</FONT> is pushed onto the stack, its value occupies two slots on the stack. Opcodes that indicate a specific <FONT FACE="Courier New">long</FONT> or <FONT FACE="Courier New">double</FONT> value to push are shown in Table 10-2. </P>
<P>Table 10-2. Pushing dual-word constants onto the stack</P>
<TABLE WIDTH="500">
<TR><TD VALIGN="TOP"><STRONG>Opcode</STRONG></TD><TD VALIGN="TOP"><STRONG>Operand(s)</STRONG></TD><TD VALIGN="TOP"><STRONG>Description</STRONG></TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">lconst_0</FONT></TD><TD VALIGN="TOP">(none)</TD><TD VALIGN="TOP">pushes <FONT FACE="Courier New">long</FONT> 0 onto the stack</P>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">lconst_1</FONT></TD><TD VALIGN="TOP">(none)</TD><TD VALIGN="TOP">pushes <FONT FACE="Courier New">long</FONT> 1 onto the stack</P>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">dconst_0</FONT></TD><TD VALIGN="TOP">(none)</TD><TD VALIGN="TOP">pushes <FONT FACE="Courier New">double</FONT> 0 onto the stack</P>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">dconst_1</FONT></TD><TD VALIGN="TOP">(none)</TD><TD VALIGN="TOP">pushes <FONT FACE="Courier New">double</FONT> 1 onto the stack</P>
</TABLE>
<P>One other opcode pushes an implicit constant value onto the stack. The <CODE>aconst_null</CODE> opcode, shown in Table 10-3, pushes a <FONT FACE="Courier New">null</FONT> object reference onto the stack.</P>
<P>As mentioned in earlier chapters, the format of an object reference depends upon the Java Virtual Machine implementation. An object reference will somehow refer to a Java object on the garbage-collected heap. A <FONT FACE="Courier New">null</FONT> object reference indicates an object reference variable does not currently refer to any valid object. The <CODE>aconst_null</CODE> opcode is used in the process of assigning <FONT FACE="Courier New">null</FONT> to an object reference variable. </P>
<P>Table 10-3. Pushing a <FONT FACE="Courier New">null</FONT> reference onto the stack</P>
<TABLE WIDTH="500">
<TR><TD VALIGN="TOP"><STRONG>Opcode</STRONG></TD><TD VALIGN="TOP"><STRONG>Operand(s)</STRONG></TD><TD VALIGN="TOP"><STRONG>Description</STRONG></TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">aconst_null</FONT></TD><TD VALIGN="TOP">(none)</TD><TD VALIGN="TOP">pushes a null object reference onto the stack</TD></TR>
</TABLE>
<P>Two opcodes indicate the constant to push with an operand that immediately follows the opcode. These opcodes, shown in Table 10-4, are used to push integer constants that are within the valid range for <FONT FACE="Courier New">byte</FONT> or <FONT FACE="Courier New">short</FONT> types. The <FONT FACE="Courier New">byte</FONT> or <FONT FACE="Courier New">short</FONT> that follows the opcode is expanded to an <FONT FACE="Courier New">int</FONT> before it is pushed onto the stack. Operations on <FONT FACE="Courier New">bytes</FONT> and <FONT FACE="Courier New">short</FONT>s that have been pushed onto the stack are actually done on their <FONT FACE="Courier New">int</FONT> equivalents.</STRONG></TD></TR>
<P>Table 10-4. Pushing <FONT FACE="Courier New">byte</FONT> and <FONT FACE="Courier New">short</FONT> constants onto the stack</STRONG></TD></TR>
<TABLE WIDTH="500">
<TR><TD VALIGN="TOP"><STRONG>Opcode</STRONG></TD><TD VALIGN="TOP"><STRONG>Operand(s)</STRONG></TD><TD VALIGN="TOP"><STRONG>Description</STRONG></TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">bipush</FONT></TD><TD VALIGN="TOP">byte1</TD><TD VALIGN="TOP">expands byte1 (a <FONT FACE="Courier New">byte</FONT> type) to an <FONT FACE="Courier New">int</FONT> and pushes it onto the stack</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">sipush</FONT></TD><TD VALIGN="TOP">byte1, byte2</TD><TD VALIGN="TOP">expands byte1, byte2 (a <FONT FACE="Courier New">short</FONT> type) to an <FONT FACE="Courier New">int</FONT> and pushes it onto the stack</TD></TR>
</TABLE>
<P>Three opcodes push constants from the constant pool. These opcodes take operands that specify a constant pool index. The Java Virtual Machine looks up the constant pool entry given the index, determines the constant's type and value, and pushes it onto the stack.</P>
<P>The constant pool index is an unsigned value that immediately follows the opcode in the bytecode stream. Opcodes <CODE>ldc</CODE> and <CODE>ldc_w</CODE> push a single-word item onto the stack, either an <FONT FACE="Courier New">int</FONT>, <FONT FACE="Courier New">float</FONT>, or an object reference to a <FONT FACE="Courier New">String</FONT>. The difference between <CODE>ldc</CODE> and <CODE>ldc_w</CODE> is that <CODE>ldc</CODE> can only refer to constant pool locations one through 255 because its index is just 1 byte. (Constant pool location zero is unused.) <CODE>ldc_w</CODE> has a 2-byte index, so it can refer to any constant pool location. <CODE>lcd2_w</CODE> also has a 2-byte index, and it is used to refer to any constant pool location containing a <FONT FACE="Courier New">long</FONT> or <FONT FACE="Courier New">double</FONT>, which occupy two words. The opcodes that push constants from the constant pool are shown in Table 10-5. </P>
<P>Table 10-5. Pushing constant pool entries onto the stack</P>
<TABLE WIDTH="500">
<TR><TD VALIGN="TOP"><STRONG>Opcode</STRONG></TD><TD VALIGN="TOP"><STRONG>Operand(s)</STRONG></TD><TD VALIGN="TOP"><STRONG>Description</STRONG></TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">ldc</FONT></TD><TD VALIGN="TOP">indexbyte1</TD><TD VALIGN="TOP">pushes single-word value from constant pool entry specified by indexbyte1 onto the stack</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">ldc_w</FONT></TD><TD VALIGN="TOP">indexbyte1, indexbyte2</TD><TD VALIGN="TOP">pushes single-word value from constant pool entry specified by indexbyte1, indexbyte2 onto the stack</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">ldc2_w</FONT></TD><TD VALIGN="TOP">indexbyte1, indexbyte2</TD><TD VALIGN="TOP">pushes dual-word value from constant pool entry specified by indexbyte1, indexbyte2 onto the stack</TD></TR>
</TABLE>
<P>All string literals from Java source code end up as entries in a constant pool. If multiple classes of the same application use the same string literal, that string literal will appear in the class file of every class that uses it. For example, if three classes use the string literal <FONT FACE="Courier New">"Harumph!"</FONT>, that string will appear in the constant pool of each of three class files. Methods of those classes can use the <FONT FACE="Courier New">ldc</FONT> or <FONT FACE="Courier New">ldc_w</FONT> instructions to push onto the operand stack a reference to a <FONT FACE="Courier New">String</FONT> object that has the value <FONT FACE="Courier New">"Harumph!"</FONT>.</P>
<P>As mentioned in Chapter 8, &quot;The Linking Model,&quot; the Java Virtual Machine resolves all string literals that have the same sequence of characters into the same <FONT FACE="Courier New">String</FONT> object. In other words, if multiple classes use the same literal string, say <FONT FACE="Courier New">"Harumph!"</FONT>, the Java Virtual Machine will only create one <FONT FACE="Courier New">String</FONT> object with the value <FONT FACE="Courier New">"Harumph!"</FONT> to represent all of those string literals.</P>
<P>When the virtual machine resolves the constant pool entry for a literal string, it &quot;interns&quot; the string. First, it checks to see if the stringís sequence of characters have already been interned. If so, it just uses the same reference as the already-interned string. Otherwise, it creates a new <FONT FACE="Courier New">String</FONT> object, adds a reference to the new <FONT FACE="Courier New">String</FONT> object to its set of interned strings, and uses the reference to the newly-interned string.</P>
<H3><EM><P>Generic Stack Operations</P>
</EM></H3><P>Although most instructions in the Java Virtual Machineís instruction set operate on a particular type, some instructions manipulate the stack independent of type. As mentioned in Chapter 5, &quot;The Java Virtual Machine,&quot; these generic (typeless) instructions cannot be used to break up dual-word values. These instructions are shown in Table 10-6.</P>
<P>Table 10-6. Stack manipulation</P>
<TABLE WIDTH="500">
<TR><TD VALIGN="TOP"><STRONG>Opcode</STRONG></TD><TD VALIGN="TOP"><STRONG>Operand(s)</STRONG></TD><TD VALIGN="TOP"><STRONG>Description</STRONG></TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">nop</FONT></TD><TD VALIGN="TOP">(none)</TD><TD VALIGN="TOP">do nothing</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">pop</FONT></TD><TD VALIGN="TOP">(none)</TD><TD VALIGN="TOP">pop the top word from the operand stack</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">pop2</FONT></TD><TD VALIGN="TOP">(none)</TD><TD VALIGN="TOP">pop the top two words from the operand stack</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">swap</FONT></TD><TD VALIGN="TOP">(none)</TD><TD VALIGN="TOP">swap the top operand stack two words </TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">dup</FONT></TD><TD VALIGN="TOP">(none)</TD><TD VALIGN="TOP">duplicate top operand stack word </TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">dup2</FONT></TD><TD VALIGN="TOP">(none)</TD><TD VALIGN="TOP">duplicate top two operand stack words</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">dup_x1</FONT></TD><TD VALIGN="TOP">(none)</TD><TD VALIGN="TOP">duplicate top operand stack word and put two down</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">dup_x2</FONT></TD><TD VALIGN="TOP">(none)</TD><TD VALIGN="TOP">duplicate top operand stack word and put three down</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">dup2_x1</FONT></TD><TD VALIGN="TOP">(none)</TD><TD VALIGN="TOP">duplicate top two operand stack words and put three down</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">dup2_x2</FONT></TD><TD VALIGN="TOP">(none)</TD><TD VALIGN="TOP">duplicate top two operand stack words and put four down</TD></TR>
</TABLE>
<P>The last four instructions shown in Table 10-6 can be a bit difficult to understand. Consult the description of these instructions in Appendix A for a picture of the stack before and after these instructions have been executed.</P>
<I><STRONG><P>Pushing Local Variables Onto the Stack</P>
</I><P></STRONG>Several opcodes exist that push <FONT FACE="Courier New">int</FONT> and <FONT FACE="Courier New">float</FONT> local variables onto the operand stack. Some opcodes are defined that implicitly refer to a commonly used local variable position. For example, <CODE>iload_0</CODE> loads the <FONT FACE="Courier New">int</FONT> local variable at position zero. Other local variables are pushed onto the stack by an opcode that takes the local variable index from the first byte following the opcode. The <CODE>iload</CODE> instruction is an example of this type of opcode. The first byte following <CODE>iload</CODE> is interpreted as an unsigned 8-bit index that refers to a local variable. </P>
<P>The opcodes that push <FONT FACE="Courier New">int</FONT> and <FONT FACE="Courier New">float</FONT> local variables onto the stack are shown in Table 10-7. </P>
<P>Table 10-7. Pushing single-word local variables onto the stack</P>
<TABLE WIDTH="500">
<TR><TD VALIGN="TOP"><STRONG>Opcode</STRONG></TD><TD VALIGN="TOP"><STRONG>Operand(s)</STRONG></TD><TD VALIGN="TOP"><STRONG>Description</STRONG></TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">iload</FONT></TD><TD VALIGN="TOP">vindex</TD><TD VALIGN="TOP">pushes <FONT FACE="Courier New">int</FONT> from local variable position vindex</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">iload</FONT>_0</TD><TD VALIGN="TOP">(none)</TD><TD VALIGN="TOP">pushes <FONT FACE="Courier New">int</FONT> from local variable position zero</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">iload</FONT>_1</TD><TD VALIGN="TOP">(none)</TD><TD VALIGN="TOP">pushes <FONT FACE="Courier New">int</FONT> from local variable position one</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">iload</FONT>_2</TD><TD VALIGN="TOP">(none)</TD><TD VALIGN="TOP">pushes <FONT FACE="Courier New">int</FONT> from local variable position two</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">iload</FONT>_3</TD><TD VALIGN="TOP">(none)</TD><TD VALIGN="TOP">pushes <FONT FACE="Courier New">int</FONT> from local variable position three</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">fload</FONT></TD><TD VALIGN="TOP">vindex</TD><TD VALIGN="TOP">pushes <FONT FACE="Courier New">float</FONT> from local variable position vindex</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">fload</FONT>_0</TD><TD VALIGN="TOP">(none)</TD><TD VALIGN="TOP">pushes <FONT FACE="Courier New">float</FONT> from local variable position zero</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">fload</FONT>_1</TD><TD VALIGN="TOP">(none)</TD><TD VALIGN="TOP">pushes <FONT FACE="Courier New">float</FONT> from local variable position one</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">fload</FONT>_2</TD><TD VALIGN="TOP">(none)</TD><TD VALIGN="TOP">pushes <FONT FACE="Courier New">float</FONT> from local variable position two</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">fload</FONT>_3</TD><TD VALIGN="TOP">(none)</TD><TD VALIGN="TOP">pushes <FONT FACE="Courier New">float</FONT> from local variable position three</TD></TR>
</TABLE>
<P>Table 10-8 shows the instructions that push local variables of type <FONT FACE="Courier New">long</FONT> and <FONT FACE="Courier New">double</FONT> onto the stack. These instructions move two words from the local variable section of the stack frame to the operand stack section. </P>
<P>Table 10-8. Pushing dual-word local variables onto the stack</P>
<TABLE WIDTH="500">
<TR><TD VALIGN="TOP"><STRONG>Opcode</STRONG></TD><TD VALIGN="TOP"><STRONG>Operand(s)</STRONG></TD><TD VALIGN="TOP"><STRONG>Description</STRONG></TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">lload</FONT></TD><TD VALIGN="TOP">vindex</TD><TD VALIGN="TOP">pushes <FONT FACE="Courier New">long</FONT> from local variable positions vindex and (vindex + 1)</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">lload</FONT>_0</TD><TD VALIGN="TOP">(none)</TD><TD VALIGN="TOP">pushes <FONT FACE="Courier New">long</FONT> from local variable positions zero and one</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">lload</FONT>_1</TD><TD VALIGN="TOP">(none)</TD><TD VALIGN="TOP">pushes <FONT FACE="Courier New">long</FONT> from local variable positions one and two</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">lload</FONT>_2</TD><TD VALIGN="TOP">(none)</TD><TD VALIGN="TOP">pushes <FONT FACE="Courier New">long</FONT> from local variable positions two and three</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">lload</FONT>_3</TD><TD VALIGN="TOP">(none)</TD><TD VALIGN="TOP">pushes <FONT FACE="Courier New">long</FONT> from local variable positions three and four</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">dload</FONT></TD><TD VALIGN="TOP">vindex</TD><TD VALIGN="TOP">pushes <FONT FACE="Courier New">double</FONT> from local variable positions vindex and (vindex + 1)</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">dload</FONT>_0</TD><TD VALIGN="TOP">(none)</TD><TD VALIGN="TOP">pushes <FONT FACE="Courier New">double</FONT> from local variable positions zero and one</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">dload</FONT>_1</TD><TD VALIGN="TOP">(none)</TD><TD VALIGN="TOP">pushes <FONT FACE="Courier New">double</FONT> from local variable positions one and two</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">dload</FONT>_2</TD><TD VALIGN="TOP">(none)</TD><TD VALIGN="TOP">pushes <FONT FACE="Courier New">double</FONT> from local variable positions two and three</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">dload</FONT>_3</TD><TD VALIGN="TOP">(none)</TD><TD VALIGN="TOP">pushes <FONT FACE="Courier New">double</FONT> from local variable positions three and four</TD></TR>
</TABLE>
<P>The final group of opcodes that push local variables move object references (which occupy one word) from the local variables section of the stack frame to the operand section. These opcodes are shown in Table 10-9.</P>
<P>Table 10-9. Pushing object reference local variables onto the stack</P>
<TABLE WIDTH="500">
<TR><TD VALIGN="TOP"><STRONG>Opcode</STRONG></TD><TD VALIGN="TOP"><STRONG>Operand(s)</STRONG></TD><TD VALIGN="TOP"><STRONG>Description</STRONG></TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">aload</FONT></TD><TD VALIGN="TOP">vindex</TD><TD VALIGN="TOP">pushes object reference from local variable position vindex</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">aload</FONT>_0</TD><TD VALIGN="TOP">(none)</TD><TD VALIGN="TOP">pushes object reference from local variable position zero</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">aload</FONT>_1</TD><TD VALIGN="TOP">(none)</TD><TD VALIGN="TOP">pushes object reference from local variable position one</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">aload</FONT>_2</TD><TD VALIGN="TOP">(none)</TD><TD VALIGN="TOP">pushes object reference from local variable position two</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">aload</FONT>_3</TD><TD VALIGN="TOP">(none)</TD><TD VALIGN="TOP">pushes object reference from local variable position three</TD></TR>
</TABLE>
<I><STRONG><P>Popping to Local Variables</P>
</I></STRONG><H3><P></H3>For each opcode that pushes a local variable onto the stack there exists a corresponding opcode that pops the top of the stack back into the local variable. The mnemonics of the pop opcodes can be formed from the mnemonics of the push opcodes by replacing &quot;load&quot; with &quot;store.&quot; The opcodes that pop <FONT FACE="Courier New">int</FONT>s and <FONT FACE="Courier New">float</FONT>s from the top of the operand stack to a local variable are listed in Table 10-10. Each of these opcodes moves one single-word value from the top of the stack to a local variable.</P>
<P>Table 10-10. Popping single-word values into local variables</P>
<TABLE WIDTH="500">
<TR><TD VALIGN="TOP"><STRONG>Opcode</STRONG></TD><TD VALIGN="TOP"><STRONG>Operand(s)</STRONG></TD><TD VALIGN="TOP"><STRONG>Description</STRONG></TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">istore</FONT></TD><TD VALIGN="TOP">vindex</TD><TD VALIGN="TOP">pops <FONT FACE="Courier New">int</FONT> to local variable position vindex</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">istore</FONT>_0</TD><TD VALIGN="TOP">(none)</TD><TD VALIGN="TOP">pops <FONT FACE="Courier New">int</FONT> to local variable position zero</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">istore</FONT>_1</TD><TD VALIGN="TOP">(none)</TD><TD VALIGN="TOP">pops <FONT FACE="Courier New">int</FONT> to local variable position one</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">istore</FONT>_2</TD><TD VALIGN="TOP">(none)</TD><TD VALIGN="TOP">pops <FONT FACE="Courier New">int</FONT> to local variable position two</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">istore</FONT>_3</TD><TD VALIGN="TOP">(none)</TD><TD VALIGN="TOP">pops <FONT FACE="Courier New">int</FONT> to local variable position three</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">fstore</FONT></TD><TD VALIGN="TOP">vindex</TD><TD VALIGN="TOP">pops <FONT FACE="Courier New">float</FONT> to local variable position vindex</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">fstore</FONT>_0</TD><TD VALIGN="TOP">(none)</TD><TD VALIGN="TOP">pops <FONT FACE="Courier New">float</FONT> to local variable position zero</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">fstore</FONT>_1</TD><TD VALIGN="TOP">(none)</TD><TD VALIGN="TOP">pops <FONT FACE="Courier New">float</FONT> to local variable position one</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">fstore</FONT>_2</TD><TD VALIGN="TOP">(none)</TD><TD VALIGN="TOP">pops <FONT FACE="Courier New">float</FONT> to local variable position two</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">fstore</FONT>_3</TD><TD VALIGN="TOP">(none)</TD><TD VALIGN="TOP">pops <FONT FACE="Courier New">float</FONT> to local variable position three</TD></TR>
</TABLE>
<P>Table 10-11 shows the instructions that pop values of type <FONT FACE="Courier New">long</FONT> and <FONT FACE="Courier New">double</FONT> into a local variable. These instructions move a dual-word value from the top of the operand stack to a local variable. </P>
<P>Table 10-11. Popping dual-word values into local variables</P>
<TABLE WIDTH="500">
<TR><TD VALIGN="TOP"><STRONG>Opcode</STRONG></TD><TD VALIGN="TOP"><STRONG>Operand(s)</STRONG></TD><TD VALIGN="TOP"><STRONG>Description</STRONG></TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">lstore</FONT></TD><TD VALIGN="TOP">vindex</TD><TD VALIGN="TOP">pops <FONT FACE="Courier New">long</FONT> to local variable positions vindex and (vindex + 1)</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">lstore</FONT>_0</TD><TD VALIGN="TOP">(none)</TD><TD VALIGN="TOP">pops <FONT FACE="Courier New">long</FONT> to local variable positions zero and one</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">lstore</FONT>_1</TD><TD VALIGN="TOP">(none)</TD><TD VALIGN="TOP">pops <FONT FACE="Courier New">long</FONT> to local variable positions one and two</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">lstore</FONT>_2</TD><TD VALIGN="TOP">(none)</TD><TD VALIGN="TOP">pops <FONT FACE="Courier New">long</FONT> to local variable positions two and three</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">lstore</FONT>_3</TD><TD VALIGN="TOP">(none)</TD><TD VALIGN="TOP">pops <FONT FACE="Courier New">long</FONT> to local variable positions three and four</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">dstore</FONT></TD><TD VALIGN="TOP">vindex</TD><TD VALIGN="TOP">pops <FONT FACE="Courier New">double</FONT> to local variable positions vindex and (vindex + 1)</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">dstore</FONT>_0</TD><TD VALIGN="TOP">(none)</TD><TD VALIGN="TOP">pops <FONT FACE="Courier New">double</FONT> to local variable positions zero and one</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">dstore</FONT>_1</TD><TD VALIGN="TOP">(none)</TD><TD VALIGN="TOP">pops <FONT FACE="Courier New">double</FONT> to local variable positions one and two</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">dstore</FONT>_2</TD><TD VALIGN="TOP">(none)</TD><TD VALIGN="TOP">pops <FONT FACE="Courier New">double</FONT> to local variable positions two and three</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">dstore</FONT>_3</TD><TD VALIGN="TOP">(none)</TD><TD VALIGN="TOP">pops <FONT FACE="Courier New">double</FONT> to local variable positions three and four</TD></TR>
</TABLE>
<P>The final group of opcodes that pops to local variables are shown in Table 10-12. These opcodes pop an object reference from the top of the operand stack to a local variable. </P>
<P>Table 10-12. Popping object references into local variables</P>
<TABLE WIDTH="500">
<TR><TD VALIGN="TOP"><STRONG>Opcode</STRONG></TD><TD VALIGN="TOP"><STRONG>Operand(s)</STRONG></TD><TD VALIGN="TOP"><STRONG>Description</STRONG></TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">astore</FONT></TD><TD VALIGN="TOP">vindex</TD><TD VALIGN="TOP">pops object reference to local variable position vindex</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">astore</FONT>_0</TD><TD VALIGN="TOP">(none)</TD><TD VALIGN="TOP">pops object reference to local variable position zero</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">astore</FONT>_1</TD><TD VALIGN="TOP">(none)</TD><TD VALIGN="TOP">pops object reference to local variable position one</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">astore</FONT>_2</TD><TD VALIGN="TOP">(none)</TD><TD VALIGN="TOP">pops object reference to local variable position two</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">astore</FONT>_3</TD><TD VALIGN="TOP">(none)</TD><TD VALIGN="TOP">pops object reference to local variable position three</TD></TR>
</TABLE>
<H3><EM><P>The wide Instruction</P>
</EM></H3><P>Unsigned 8-bit local variable indexes, such as the one that follows the <CODE>iload</CODE> instruction, limit the number of local variables in a method to 256. A separate instruction, <CODE>wide</CODE>, can extend an 8-bit index by another 8 bits, which raises the local variable limit to 65,536. The <CODE>wide</CODE> opcode modifies other opcodes. <FONT FACE="Courier New">wide</FONT> can precede an instruction, such as <CODE>iload</CODE>, that takes an 8-bit unsigned local variable index. Two bytes that form a 16-bit unsigned index into the local variables follows the <FONT FACE="Courier New">wide</FONT> opcode and the modified opcode.</P>
<P>Table 10-13 lists all but two of the opcodes that can be modified by <FONT FACE="Courier New">wide</FONT>. The other two opcodes, <FONT FACE="Courier New">iinc</FONT> and <FONT FACE="Courier New">ret</FONT>, are described in later chapters. The <FONT FACE="Courier New">iinc</FONT> instruction and its <FONT FACE="Courier New">wide</FONT> variant are described in Chapter 12, &quot;Integer Arithmetic.&quot; The <FONT FACE="Courier New">ret</FONT> instruction and its wide variant are described in Chapter 18, &quot;Finally Clauses.&quot;</P>
<P>Table 10-13. Popping object references into local variables</P>
<TABLE WIDTH="500">
<TR><TD VALIGN="TOP"><STRONG>Opcode</STRONG></TD><TD VALIGN="TOP"><STRONG>Operand(s)</STRONG></TD><TD VALIGN="TOP"><STRONG>Description</STRONG></TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">wide</FONT></TD><TD VALIGN="TOP"><FONT FACE="Courier New">iload</FONT>, indexbyte1, indexbyte2</TD><TD VALIGN="TOP">pushes <FONT FACE="Courier New">int</FONT> from local variable position index</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">wide</FONT></TD><TD VALIGN="TOP"><FONT FACE="Courier New">lload</FONT>, indexbyte1, indexbyte2</TD><TD VALIGN="TOP">pushes <FONT FACE="Courier New">long</FONT> from local variable position index</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">wide</FONT></TD><TD VALIGN="TOP"><FONT FACE="Courier New">fload</FONT>, indexbyte1, indexbyte2</TD><TD VALIGN="TOP">pushes <FONT FACE="Courier New">float</FONT> from local variable position index</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">wide</FONT></TD><TD VALIGN="TOP"><FONT FACE="Courier New">dload</FONT>, indexbyte1, indexbyte2</TD><TD VALIGN="TOP">pushes <FONT FACE="Courier New">double</FONT> from local variable position index</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">wide</FONT></TD><TD VALIGN="TOP"><FONT FACE="Courier New">aload</FONT>, indexbyte1, indexbyte2</TD><TD VALIGN="TOP">pushes object reference from local variable position index</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">wide</FONT></TD><TD VALIGN="TOP"><FONT FACE="Courier New">istore</FONT>, indexbyte1, indexbyte2</TD><TD VALIGN="TOP">pops <FONT FACE="Courier New">int</FONT> to local variable position vindex</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">wide</FONT></TD><TD VALIGN="TOP"><FONT FACE="Courier New">lstore</FONT>, indexbyte1, indexbyte2</TD><TD VALIGN="TOP">pops <FONT FACE="Courier New">long</FONT> to local variable position index</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">wide</FONT></TD><TD VALIGN="TOP"><FONT FACE="Courier New">fstore</FONT>, indexbyte1, indexbyte2</TD><TD VALIGN="TOP">pops <FONT FACE="Courier New">float</FONT> to local variable position index</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">wide</FONT></TD><TD VALIGN="TOP"><FONT FACE="Courier New">dstore</FONT>, indexbyte1, indexbyte2</TD><TD VALIGN="TOP">pops <FONT FACE="Courier New">double</FONT> to local variable position index</TD></TR>
<TR><TD VALIGN="TOP"><FONT FACE="Courier New">wide</FONT></TD><TD VALIGN="TOP"><FONT FACE="Courier New">astore</FONT>, indexbyte1, indexbyte2</TD><TD VALIGN="TOP">pops object reference to local variable position index</TD></TR>
</TABLE>
<P>When verifying bytecode sequences that include <FONT FACE="Courier New">wide</FONT> instructions, the opcode modified by <FONT FACE="Courier New">wide</FONT> is seen as an operand to <FONT FACE="Courier New">wide</FONT>. Jump instructions are not allowed to jump directly to an opcode modified by <FONT FACE="Courier New">wide</FONT>. For example, if a bytecode sequence include the instruction:</P>
<PRE><P><FONT FACE="Courier New">begin</FONT></P>
<FONT FACE="Courier New"><P>wide iload 257</P>
</FONT><P><FONT FACE="Courier New">end</FONT></P></PRE>
<P>No other opcode of that methodís bytecode sequence would be allowed to jump directly to the <FONT FACE="Courier New">iload</FONT> opcode. In this case, the <FONT FACE="Courier New">iload</FONT> opcode must always be executed as an operand to the <FONT FACE="Courier New">wide</FONT> opcode.</P>
<I><STRONG><P>Fibonacci Forever: A Simulation</P>
</I><P></STRONG>The <I>Fibonacci Forever</I> applet, shown in Figure 10-1, demonstrates a Java Virtual Machine executing a sequence of bytecodes that generate the Fibonacci series. The applet is embedded in a web page on the CD-ROM in file <FONT FACE="Courier New">applets/FibonacciForever.html</FONT>. The bytecode sequence in the simulation was generated by the <CODE>javac</CODE> compiler for the <FONT FACE="Courier New">calcSequence</FONT><CODE>()</CODE> method of the class shown below:</P>
<PRE><P><FONT FACE="Courier New">begin</FONT></P>
<FONT SIZE="2"><P></FONT><FONT FACE="Courier New">// On CD-ROM in file stackops/ex1/Fibonacci.java
<P>class Fibonacci {</P>
<P>&nbsp;</P>
<P>    static void calcSequence() {</P>
<P>        long fiboNum = 1;</P>
<P>        long a = 1;</P>
<P>        long b = 1;</P>
<P>&nbsp;</P>
<P>        for (;;) {</P>
<P>            fiboNum = a + b;</P>
<P>            a = b;</P>
<P>            b = fiboNum;</P>
<P>        }</P>
<P>    }</P>
<P>}</P>
</FONT><FONT SIZE="2"><P>&nbsp;</P></FONT><FONT FACE="Courier New">end</FONT></P></PRE>
<P>The <FONT FACE="Courier New">calcSequence()</FONT> method produces the Fibonacci series and places each Fibonacci number successively in the <FONT FACE="Courier New">fiboNum</FONT> variable. The first two numbers of the Fibonacci series are both ones. Each subsequent number is calculated by summing the previous two numbers, as in: 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, and so on.</P>
<P>The bytecodes generated by <CODE>javac</CODE> for the <FONT FACE="Courier New">calcSequence</FONT><CODE>()</CODE> method are shown below:</P>
<PRE><P><FONT FACE="Courier New">begin</FONT></P>
<FONT SIZE="2"><P></FONT><FONT FACE="Courier New"> 0 lconst_1   // Push long constant 1
<P> 1 lstore_0   // Pop long into local vars 0 &amp; 1: long a = 1;</P>
<P> 2 lconst_1   // Push long constant 1</P>
<P> 3 lstore_2   // Pop long into local vars 2 &amp; 3: long b = 1;</P>
<P> 4 lconst_1   // Push long constant 1</P>
<P> 5 lstore 4   // Pop long into local vars 4 &amp; 5: long fiboNum = 1;</P>
<P> 7 lload_0    // Push long from local vars 0 &amp; 1</P>
<P> 8 lload_2    // Push long from local vars 2 &amp; 3</P>
<P> 9 ladd       // Pop two longs, add them, push result</P>
<P>10 lstore 4   // Pop long into local vars 4 &amp; 5: fiboNum = a + b;</P>
<P>12 lload_2    // Push long from local vars 2 &amp; 3</P>
<P>13 lstore_0   // Pop long into local vars 0 &amp; 1: a = b;</P>
<P>14 lload 4    // Push long from local vars 4 &amp; 5</P>
<P>16 lstore_2   // Pop long into local vars 2 &amp; 3: b = fiboNum;</P>
<P>17 goto 7     // Jump back to offset 7: for (;;) {}</P>
</FONT><FONT SIZE="2"><P>&nbsp;</P></FONT><FONT FACE="Courier New">end</FONT></P></PRE>
<P>The <FONT FACE="Courier New">javac</FONT> compiler placed local variable <FONT FACE="Courier New">a</FONT> from the source into local variable slots 0 and 1 on the stack frame. It put <FONT FACE="Courier New">b</FONT> into slots 2 and 3 and <FONT FACE="Courier New">fiboNum</FONT> into slots 4 and 5. As this method calculates each successive Fibonacci number, it places the number into the <FONT FACE="Courier New">fiboNum</FONT> variable. As you run the simulation, therefore, you will see the Fibonacci series appear in the <FONT FACE="Courier New">long</FONT> value stored in local variable slots 4 and 5.</P>
<P>You may notice that <FONT FACE="Courier New">long</FONT> values are split across the two words they occupy in the local variables by placing the lower half (bits 0 through 31) in the first slot and the upper half (bits 32 through 63) in the second slot. For example, the lower half of the <FONT FACE="Courier New">fiboNum</FONT> variable is stored in local variable slot 4. The upper half of <FONT FACE="Courier New">fiboNum</FONT> is stored in local variable slot 5. On the operand stack, a similar representation is used. When a <FONT FACE="Courier New">long</FONT> value is pushed onto the operand stack, the lower half of the word is pushed, then the upper half.</P>
<P>Keep in mind that this manner of representing <FONT FACE="Courier New">long</FONT> values in the local variables and on the operand stack is an artifact of this particular (simulated) implementation of the Java Virtual Machine. As mentioned in Chapter 5, &quot;The Java Virtual Machine,&quot; the specification does not dictate any particular way to layout <FONT FACE="Courier New">long</FONT>s and <FONT FACE="Courier New">double</FONT>s across the two words they occupy on the stack frame.</P>
<P>Although according to the best mathematical minds, the Fibonacci series does indeed go on forever, the <FONT FACE="Courier New">calcSequence()</FONT> method is able to generate Fibonacci numbers only for a while. Unfortunately for <FONT FACE="Courier New">calcSequence()</FONT>, the <FONT FACE="Courier New">long</FONT> type has a finite range. The highest Fibonacci number this simulation can calculate, therefore, is the highest Fibonacci number that can be represented in a long: 7540113804746346429L. After the simulation arrives at this point in the Fibonacci series, the next addition will overflow.</P>
<P>To drive the <I>Fibonacci Forever</I> simulation, use the Step, Reset, Run, and Stop buttons. Each time you press the Step button, the simulator will execute the instruction pointed to by the pc register. If you press the Run button, the simulation will continue with no further coaxing on your part until you press the Stop button. To start the simulation over, press the Reset button. For each step of the simulation, a panel at the bottom of the applet contains an explanation of what the next instruction will do. Happy clicking.</P>
<P><IMG SRC="fig10-1.gif" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/venners/images/fig10-1.gif" ALT="Figure 10-1"></P>

<H3><EM><P>On the CD-ROM</P>
</EM></H3><P>The CD-ROM contains the source code examples from this chapter in the <FONT FACE="Courier New">stackops</FONT> directory. The <I>Fibonacci Forever</I> applet is contained in a web page on the CD-ROM in file <FONT FACE="Courier New">applets/FibonacciForever.html</FONT>. The source code for this applet is found alongside its class files, in the <FONT FACE="Courier New">applets/JVMSimulators</FONT> and <FONT FACE="Courier New">applets/JVMSimulators</FONT>.</P>
<H3><EM><P>The Resources Page</P>
</EM></H3><P>For more information about the material presented in this chapter, visit the resources page: <FONT FACE="Courier New"><A HREF="http://www.artima.com/insidejvm/stackops.html" tppabs="http://www.artima.com/insidejvm/stackops.html">http://www.artima.com/insidejvm/stackops.html</A></FONT>.</P>
<TABLE BORDER="0" WIDTH="100%">
<TR><TD><A HREF="http://www.pbg.mcgraw-hill.com/betabooks/stores.html" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/stores.html" target="bottom"><IMG SRC="hotkey.gif" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/images/hotkey.gif" ALIGN="LEFT" BORDER="0" WIDTH="40" HEIGHT="40" ALT="Orders"></A>
<IMG SRC="order_text.gif" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/images/order_text.gif" WIDTH="103" HEIGHT="41" ALT="Orders"></TD>
<TD ALIGN="RIGHT"><A HREF="chap09.html" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/venners/chap09.html"><IMG SRC="backward.gif" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/images/backward.gif" BORDER="0" ALT="Backward" WIDTH="32" HEIGHT="32"></A>&nbsp;<A HREF="chap11.html" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/venners/chap11.html"><IMG SRC="forward.gif" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/images/forward.gif" BORDER="0" ALT="Forward" WIDTH="32" HEIGHT="32"></A></TD></TR>
<TR><TD COLSPAN="2"><A HREF="mailto:computing@mcgraw-hill.com"><IMG SRC="hotkey.gif" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/images/hotkey.gif" ALIGN="LEFT" BORDER="0" WIDTH="40" HEIGHT="40" ALT="Comments"></A>
<IMG SRC="comment_text.gif" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/images/comment_text.gif" WIDTH="73" HEIGHT="39" ALT="Comments"></TD></TR>

</TABLE>
<HR>
<P ALIGN=CENTER>&nbsp;<A HREF="http://www.pbg.mcgraw-hill.com/computing/computing-home.html" tppabs="http://www.pbg.mcgraw-hill.com/computing/computing-home.html" TARGET="_top">COMPUTING
MCGRAW-HILL</A> | <A HREF="http://www.pbg.mcgraw-hill.com/betabooks/betabooks-home.html" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/betabooks-home.html" TARGET="_top">Beta Books</A>
| <A HREF="http://www.pbg.mcgraw-hill.com/computing/contact.html" tppabs="http://www.pbg.mcgraw-hill.com/computing/contact.html" TARGET="_top">Contact Us</A>
| <A HREF="http://www.pbg.mcgraw-hill.com/betabooks/stores.html" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/stores.html" TARGET="_top">Order Information</A>
| <A HREF="http://mcgraw-hill.inforonics.com/compsearch.shtml" tppabs="http://mcgraw-hill.inforonics.com/compsearch.shtml" TARGET="_top">Online Catalog</A></P>

<P ALIGN=CENTER><FONT SIZE="-1"><A HREF="http://www.pbg.mcgraw-hill.com/computing/computing-home.html" tppabs="http://www.pbg.mcgraw-hill.com/computing/computing-home.html" TARGET="_top">Computing McGraw-Hill</A> is an imprint of the <A HREF="http://www.pbg.mcgraw-hill.com/pbg-home.html" tppabs="http://www.pbg.mcgraw-hill.com/pbg-home.html" TARGET="_top">McGraw-Hill Professional Book Group</A>.</FONT></P>

<!-- begin footer -->
<HR>
<A HREF="http://www.mcgraw-hill.com/" tppabs="http://www.mcgraw-hill.com/" TARGET="_top"><IMG SRC="division-white.gif" tppabs="http://www.pbg.mcgraw-hill.com/images/division-white.gif" WIDTH="350" HEIGHT="44" ALT="A Division of the McGraw-Hill Companies" BORDER="0"></A><BR>
<FONT SIZE="-2">Copyright &copy; 1997 <A HREF="http://www.mcgraw-hill.com/" tppabs="http://www.mcgraw-hill.com/" TARGET="_top">
The McGraw-Hill Companies</A>. All rights reserved. Any use is subject to the 
<A HREF="http://www.mcgraw-hill.com/corporate/news_info/copyrttm.htm" tppabs="http://www.mcgraw-hill.com/corporate/news_info/copyrttm.htm" TARGET="_top">
Terms of Use</A>; the corporation also has a comprehensive <A HREF="http://www.mcgraw-hill.com/corporate/news_info/privacy.html" tppabs="http://www.mcgraw-hill.com/corporate/news_info/privacy.html" TARGET="_top">
Privacy Policy</A> governing information we may collect from our customers.</FONT>
<!-- end footer -->
</BODY>
</HTML>
