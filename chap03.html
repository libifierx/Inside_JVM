<!-- All material contained herein is copyright (c) McGraw-Hill Professional Books
All Rights Reserved. No use of this material may be made without express written
permission of the copyright holder. HTML conversions by Mega Space [barry@megaspace.com] -->

<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=ISO-8859-1">
<TITLE>Understanding Digital Signatures: Inside the Java Virtual Machine
 by Bill Venners - Beta Version</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<TABLE BORDER="0" WIDTH="100%">
<TR><TD><A HREF="http://www.pbg.mcgraw-hill.com/betabooks/stores.html" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/stores.html" target="bottom"><IMG SRC="hotkey.gif" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/images/hotkey.gif" ALIGN="LEFT" BORDER="0" WIDTH="40" HEIGHT="40" ALT="Orders"></A>
<IMG SRC="order_text.gif" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/images/order_text.gif" WIDTH="103" HEIGHT="41" ALT="Orders"></TD>
<TD ALIGN="RIGHT"><A HREF="chap02.html" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/venners/chap02.html"><IMG SRC="backward.gif" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/images/backward.gif" BORDER="0" ALT="Backward" WIDTH="32" HEIGHT="32"></A>&nbsp;<A HREF="chap04.html" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/venners/chap04.html"><IMG SRC="forward.gif" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/images/forward.gif" BORDER="0" ALT="Forward" WIDTH="32" HEIGHT="32"></A></TD></TR>
<TR><TD COLSPAN="2"><A HREF="mailto:computing@mcgraw-hill.com"><IMG SRC="hotkey.gif" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/images/hotkey.gif" ALIGN="LEFT" BORDER="0" WIDTH="40" HEIGHT="40" ALT="Comments"></A>
<IMG SRC="comment_text.gif" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/images/comment_text.gif" WIDTH="73" HEIGHT="39" ALT="Comments"></TD></TR>

<TR><TD COLSPAN="2"><FONT FACE="ARIEL,HELVETICA" SIZE="-1"><I>&copy; 1997 The McGraw-Hill Companies, Inc.  All rights reserved.  <BR>Any use of this Beta Book is subject to the rules stated in the <A HREF="http://www.mcgraw-hill.com/corporate/news_info/copyrttm.htm" tppabs="http://www.mcgraw-hill.com/corporate/news_info/copyrttm.htm" target="_top">Terms of Use</A>.</I></FONT><br>
<script language="javascript">
    document.write("<a href='http://banners.linkbuddies.com/click.php?id=237296'><img src='http://banners.linkbuddies.com/image.php?id=237296&ref=" + document.referrer + "' width=468 height=60 alt='Click Here' border=0></a>");
</script></TD></TR>

</TABLE>
<HR>
<P><H1>Chapter Three</H1></P>
<P><H2>Security</H2></P>
<P>Aside from platform independence, discussed in the previous chapter, the other major technical challenge a network-oriented software technology must deal with is security. Networks, because they allow computers to share data and distribute processing, can potentially serve as a way to break into a computer system, enabling someone to steal information, destroy information, or steal computing resources. As a consequence, connecting a computer to a network raises many security issues.</P>
<P>To address the security concerns raised by networks, Javaís architecture comes with an extensive built-in security model. This chapter gives an overview of the security model built into Javaís core architecture.</P>
<H3><EM><P>Why Security?</P>
</EM></H3><P>Javaís security model is one of the key architectural features that makes it an appropriate technology for networked environments. Security is important because networks represent a potential avenue of attack to any computer hooked to them. This concern becomes especially strong in an environment in which software is downloaded across the network and executed locally, as is done, for example, with Java applets. Because the class files for an applet are automatically downloaded when a user goes to the containing web page in a browser, it is likely that a user will encounter applets from untrusted sources. Without any security, this would be a convenient way to spread viruses. Thus, Javaís security mechanisms help make Java suitable for networks because they establish a needed trust in the safety of network-mobile code.</P>
<P>Javaís security model is focused on protecting end-users from hostile programs downloaded across a network from untrusted sources. To accomplish this goal, Java provides a customizable &quot;sandbox&quot; in which Java programs run. A Java program must play only inside its sandbox. It can do anything within the boundaries of its sandbox, but canít take any action outside those boundaries. The sandbox for untrusted Java applets, for example, prohibits many activities, including:</P>
<UL><LI> reading or writing to the local disk,
<LI> making a network connection to any but the host from which the applet came,
<LI> creating a new process, and
<LI> loading a new dynamic library and directly calling a native method.</UL>
<P>By making it impossible for downloaded code to perform certain actions, Javaís security model protects the end-user from the threat of hostile code.</P>
<H3><EM><P>The Sandbox</P>
</EM></H3><P>Traditionally, you had to trust software before you ran it. You achieved security by being careful only to use software from trusted sources, and by regularly scanning for viruses just to make sure. Once some software got access to your system, it had full reign. If it was malicious, it could do a great deal of damage because there were no restrictions placed on it by the runtime environment of your computer. So in the traditional security scheme, you tried to prevent malicious code from ever gaining access to your computer in the first place.</P>
<P>The sandbox security model makes it easier to work with software that comes from sources you donít fully trust. Instead of approaching security by requiring you to prevent any code you donít trust from ever making its way onto your computer, the sandbox model allows you to welcome code from any source. But as code from an untrusted source runs, the sandbox restricts code from untrusted sources from taking any actions that could possibly harm your system. You donít need to figure out what code you can and canít trust. You donít need to scan for viruses. The sandbox itself prevents any viruses or other malicious code you may invite into your computer from doing any damage.</P>
<P>If you have a properly skeptical mind, youíll need to be convinced a sandbox has no leaks before you trust it to protect you. To make sure the sandbox must has no leaks, Javaís security model involves every aspect of its architecture. If there were areas in Javaís architecture where security was weak, a malicious programmer (a &quot;cracker&quot;) could potentially exploit those areas to &quot;go around&quot; the sandbox. To understand the sandbox, therefore, you must look at several different parts of Javaís architecture, and understand how they work together.</P>
<P>The fundamental components responsible for Javaís sandbox are:</P>
<UL><LI> the class loader architecture
<LI> the class file verifier
<LI> safety features built into the Java Virtual Machine (and the language)
<LI> the security manager and the Java API</UL>
<P>One of the greatest strengths of Javaís security model is that two of these components, the class loader and the security manager, are customizable. By customizing these components, you can create a customized security policy for a Java application. As a developer, you may never need to create your own customized sandbox. You can often make use of sandboxes created by others. When you write and run a Java applet, for instance, you make use of a sandbox created by the developers of the web browser that hosts your applet.</P>
<H3><EM><P>The Class Loader Architecture</P>
</EM></H3><P>In Javaís sandbox, the class loader architecture is the first line of defense. It is the class loader, after all, that brings code into the Java Virtual Machine--code that could be hostile. The class loader architecture contributes to Javaís sandbox in two ways:</P>
<OL><LI>it guards the borders of the trusted class libraries, and</P>
<LI>it prevents malicious code from interfering with benevolent code.</OL>
<P>The class loader architecture guards the borders of the trusted class libraries by preventing an untrusted classes from pretending to be trusted. If a malicious class could successfully trick the Java Virtual Machine into believing it was a trusted class from the Java API, that malicious class could potentially break through the sandbox barrier. By preventing untrusted classes from impersonating trusted classes, the class loader architecture blocks one potential approach to compromising the security of the Java runtime.</P>
<P>The class loader architecture prevents malicious code from interfering with benevolent code by providing protected name-spaces for classes loaded by different class loaders. A <I>name-space</I> is a set of unique names for loaded classes that is maintained by the Java Virtual Machine. Once a Java Virtual Machine has loaded a class named <FONT FACE="Courier New">Volcano</FONT> into a particular name-space, for example, it is impossible to load a different class named <FONT FACE="Courier New">Volcano</FONT> into that same name-space. You can load multiple <FONT FACE="Courier New">Volcano</FONT> classes into a Java Virtual Machine, however, because you can create multiple name-spaces inside a Java application by creating multiple class loaders. If you create three separate name-spaces (one for each of three class loaders) in a running Java application, then, by loading one <FONT FACE="Courier New">Volcano</FONT> class into each name-space, your program could load three different <FONT FACE="Courier New">Volcano</FONT> classes into your application.</P>
<P>Name-spaces contribute to security because you can place a shield between classes loaded into different name-spaces. Inside the Java Virtual Machine, classes in the same name-space can interact with one another directly. Classes in different name-spaces, however, canít even detect each otherís presence unless you explicitly provide a mechanism that allows them to interact. If a malicious class, once loaded, had guaranteed access to every other class currently loaded by the virtual machine, that class could potentially learn things it shouldnít know or interfere with the proper execution of your program.</P>
<P>Often, a class loader object relies on other class loaders--at the very least, upon the primordial class loader--to help it fulfill some of the class load requests that come its way. For example, imagine you write a Java application that installs a class loader whose particular manner of loading class files is by downloading them across a network. Assume that during the course of running the Java application, a request is made of your class loader to load a class named <FONT FACE="Courier New">Volcano</FONT>. One way you could write the class loader is to have it first asks the primordial class loader to find and load the class from its trusted repository. In this case, since <FONT FACE="Courier New">Volcano</FONT> is not a part of the Java API, assume the primordial class loader canít find a class named <FONT FACE="Courier New">Volcano</FONT>. When the primordial class loader responds that it canít load the class, your class loader could then attempt to load the <FONT FACE="Courier New">Volcano</FONT> class in its custom manner, by downloading it across the network. Assuming your class loader was able to download class <FONT FACE="Courier New">Volcano</FONT>, that <FONT FACE="Courier New">Volcano</FONT> class could then play a role in the applicationís future course of execution. </P>
<P>To continue with the same example, assume that at some time later a method of class <FONT FACE="Courier New">Volcano</FONT> is invoked for the first time, and that method references class <FONT FACE="Courier New">String</FONT> from the Java API. Because it is the first time the reference was used by the running program, the virtual machine asks your class loader (the one that loaded <FONT FACE="Courier New">Volcano</FONT>) to load <FONT FACE="Courier New">String</FONT>. As before, your class loader first passes the request to the primordial class loader, but in this case, the primordial class loader is able to return a <FONT FACE="Courier New">String</FONT> class back to your class loader. (The primordial class loader most likely didnít have to actually load <FONT FACE="Courier New">String</FONT> at this point because, given that <FONT FACE="Courier New">String</FONT> is such a fundamental class in Java programs, it was almost certainly used before and therefore already loaded. Most likely, the primordial class loader just returned the <FONT FACE="Courier New">String</FONT> class that it had previously loaded from the trusted repository.) Since the primordial class loader was able to find the class, your class loader doesnít attempt to download it across the network; it merely passes to the virtual machine the <FONT FACE="Courier New">String</FONT> class returned by the primordial class loader. From that point forward, the virtual machine uses that <FONT FACE="Courier New">String</FONT> class whenever class <FONT FACE="Courier New">Volcano</FONT> references a class named <FONT FACE="Courier New">String</FONT>.</P>
<P>When you write a class loader, you create a new environment in which the loaded code runs. If you want the environment to be free of security holes, you must follow certain rules when you write your class loader. In general, you will want to write class loaders such that they protect the borders of trusted class libraries, such as those of the Java API.</P>
<P>Java allows classes in the same package to grant each other special access privileges that arenít granted to classes outside the package. So, if your class loader receives a request to load a class that by its name brazenly declares itself to be part of the Java API (for example, a class named <FONT FACE="Courier New">java.lang.Virus</FONT>), it could gain special access to the trusted classes of <FONT FACE="Courier New">java.lang</FONT> and could possibly use that special access for devious purposes. Consequently, you would normally write a class loader so that it simply refuses to load any class that claims to be part of the Java API (or any other trusted runtime library), but that doesnít exist in the local trusted repository. In other words, after your class loader passes a request to the primordial class loader, and the primordial class loader indicates it canít load the class, your class loader should check to make sure the class doesnít declare itself to be a member of a trusted package. If it does, your class loader, instead of trying to download the class across the network, should throw a security exception.</P>
<P>In addition, you may have installed some packages in the trusted repository that contain classes you want your application to be able to load through the primordial class loader, but that you donít want to be accessible to classes loaded through your class loader. For example, assume you have created a package named <FONT FACE="Courier New">absolutepower</FONT> and installed it on the local repository accessible by the primordial class loader. Assume also that you donít want classes loaded by your class loader to be able to load any class from the <FONT FACE="Courier New">absolutepower</FONT> package. In this case, you would write your class loader such that the very first thing it does is make sure the requested class doesnít declare itself as a member of the <FONT FACE="Courier New">absolutepower</FONT> package. If such a class is requested, your class loader, rather than passing the class name to the primordial class loader, should throw a security exception.</P>
<P>The only way a class loader can know whether or not a class is from a restricted package, such as <FONT FACE="Courier New">java.lang</FONT>, or a forbidden package, such as <FONT FACE="Courier New">absolutepower</FONT>, is by the classís name. Thus a class loader must be given a list of the names of restricted and forbidden packages. Because the name of class <FONT FACE="Courier New">java.lang.Virus</FONT> indicates it is from the <FONT FACE="Courier New">java.lang</FONT> package, and <FONT FACE="Courier New">java.lang</FONT> is on the list of restricted packages, your class loader should throw a security exception if the primordial class loader canít load it. Likewise, because the name of class <FONT FACE="Courier New">absolutepower.FancyClassLoader</FONT> indicates it is part of the <FONT FACE="Courier New">absolutepower</FONT> package, and the <FONT FACE="Courier New">absolutepower</FONT> package is on the list of forbidden packages, your class loader should throw a security exception absolutely.</P>
<P>A common way, therefore, to write a security-minded class loader is using the following four steps:</P>
<OL><LI>If packages exist that this class loader is not allowed to load from, the class loader checks whether the requested class is in one of those forbidden packages. If so, it throws a security exception. Else, it continues on to step two.</P>
<LI>The class loader passes the request to the primordial class loader. If the primordial class loader successfully returns the class, the class loader returns that same class. Else, it continues on to step three.</P>
<LI>If trusted packages exist that this class loader is not allowed to add classes to, the class loader checks whether the requested class is in one of those restricted packages. If so, it throws a security exception. Else, it continues on to step four.</P>
<LI>Finally, the class loader attempts to load the class in the custom way, such as by downloading it across a network. If successful, it returns the class. Else, it throws a &quot;no class definition found&quot; error.</OL>
<P>By performing steps one and three as outlined above, the class loader guards the borders of the trusted packages. With step one, it prevents a class from a forbidden package to be loaded at all. With step three, it doesnít allow an untrusted class to insert itself into a trusted package.</P>
<H3><EM><P>The Class File Verifier</P>
</EM></H3><P>Working in conjunction with the class loader, the class file verifier ensures that loaded class files have a proper internal structure. If the class file verifier discovers a problem with a class file, it throws an exception. Although compliant Java compilers should not generate malformed class files, a Java Virtual Machine canít tell how a particular class file was created. Because a class file is just a sequence of binary data, a virtual machine canít know whether a particular class file was generated by a well-meaning Java compiler or by shady crackers bent on compromising the integrity of the virtual machine. As a consequence, all Java Virtual Machine implementations have a class file verifier that can be invoked on untrusted classes, to make sure the classes are safe to use.</P>
<P>One of the security goals that the class file verifier helps achieve is program robustness. If a buggy compiler or savvy cracker generated a class file that contained a method whose bytecodes included an instruction to jump beyond the end of the method, that method could, if it were invoked, cause the virtual machine to crash. Thus, for the sake of robustness, it is important that the virtual machine verify the integrity of the bytecodes it imports. Although Java Virtual Machine designers are allowed to decide when their virtual machines will perform these checks, many implementations will do most checking just after a class is loaded. Such a virtual machine, rather than checking every time it encounters a jump instruction as it executes bytecodes, analyzes bytecodes (and verifies their integrity) once, before they are ever executed. As part of its verification of bytecodes, the Java Virtual Machine makes sure all jump instructions cause a jump to another valid instruction in the bytecode stream of the method. In most cases, checking all bytecodes once, before they are executed, is a more efficient way to guarantee robustness than checking every bytecode instruction every time it is executed.</P>
<P>A class file verifier that performs its checking as early as possible most likely operates in two distinct phases. During phase one, which takes place just after a class is loaded, the class file verifier checks the internal structure of the class file, including verifying the integrity of the bytecodes it contains. During phase two, which takes place as bytecodes are executed, the class file verifier confirms the existence of symbolically referenced classes, fields, and methods. </P>
<H3><P>Phase One: Internal Checks</P>
</H3><P>During phase one, the class file verifier checks everything thatís possible to check in a class file by looking at only the class file itself. In addition to verifying the integrity of the bytecodes during phase one, the verifier performs many checks for proper class file format and internal consistency. For example, every class file must start with the same four bytes, the magic number: <FONT FACE="Courier New">0xCAFEBABE</FONT>. The purpose of magic numbers is to make it easy for file parsers to recognize a certain type of file. Thus, the first thing a class file verifier likely checks is that the imported file does indeed begin with <FONT FACE="Courier New">0xCAFEBABE</FONT>.</P>
<P>The class file verifier also checks to make sure the class file is neither truncated nor enhanced with extra trailing bytes. Although different class files can be different lengths, each individual component contained inside a class file indicates its length as well as its type. The verifier can use the component types and lengths to determine the correct total length for each individual class file. In this way, it can verify that the imported file has a length consistent with its internal contents.</P>
<P>The verifier also looks at individual components, to make sure they are well-formed instances of their type of component. For example, a method descriptor (its return type and the number and types of its parameters) is stored in the class file as a string that must adhere to a certain context-free grammar. One check the verifier performs on individual components is to make sure each method descriptor is a well-formed string of the appropriate grammar.</P>
<P>In addition, the class file verifier checks that the class itself adheres to certain constraints placed upon it by the specification of the Java programming language. For example, the verifier enforces the rule that all classes, except class <FONT FACE="Courier New">Object</FONT>, must have a superclass. Thus, the class file verifier checks at run-time some of the Java language rules that should have been enforced at compile-time. Because the verifier has no way of knowing if the class file was generated by a benevolent, bug-free compiler, it checks each class file to make sure the rules are followed.</P>
<P>Once the class file verifier has successfully completed the checks for proper format and internal consistency, it turns its attention to the bytecodes. During this part of phase one, which is commonly called the &quot;bytecode verifier,&quot; the Java Virtual Machine performs a data-flow analysis on the streams of bytecodes that represent the methods of the class. To understand the bytecode verifier, you need to understand a bit about bytecodes and frames. </P>
<P>The bytecode streams that represent Java methods are a series of one-byte instructions, called <I>opcodes</I>, each of which may be followed by one or more <I>operands</I>. The operands supply extra data needed by the Java Virtual Machine to execute the opcode instruction. The activity of executing bytecodes, one opcode after another, constitutes a thread of execution inside the Java Virtual Machine. Each thread is awarded its own <I>Java Stack</I>, which is made up of discrete <I>frames</I>. Each method invocation gets its own frame, a section of memory where it stores, among other things, local variables and intermediate results of computation. The part of the frame in which a method stores intermediate results is called the methodís <I>operand stack</I>. An opcode and its (optional) operands may refer to the data stored on the operand stack or in the local variables of the methodís frame. Thus, the virtual machine may use data on the operand stack, in the local variables, or both, in addition to any data stored as operands following an opcode when it executes the opcode.</P>
<P>The bytecode verifier does a great deal of checking. It checks to make sure that no matter what path of execution is taken to get to a certain opcode in the bytecode stream, the operand stack always contains the same number and types of items. It checks to make sure no local variable is accessed before it is known to contain a proper value. It checks that fields of the class are always assigned values of the proper type, and that methods of the class are always invoked with the correct number and types of arguments. The bytecode verifier also checks to make sure that each opcode is valid, that each opcode has valid operands, and that for each opcode, values of the proper type are in the local variables and on the operand stack. These are just a few of the many checks performed by the bytecode verifier, which is able, through all its checking, to verify that a stream of bytecodes is safe for the Java Virtual Machine to execute.</P>
<P>Phase one of the class file verifier makes sure the imported class file is properly formed, internally consistent, adheres to the constraints of the Java programming language, and contains bytecodes that will be safe for the Java Virtual Machine to execute. If the class file verifier finds that any of these are not true, it throws an error, and the class file is never used by the program.</P>
<H3><P>Phase Two: Verification of Symbolic References</P>
</H3><P>Although phase one happens immediately after the Java Virtual Machine loads a class file, phase two is delayed until the bytecodes contained in the class file are actually executed. During phase two, the Java Virtual Machine follows the references from the class file being verified to the referenced class files, to make sure the references are correct. Because phase two has to look at other classes external to the class file being checked, phase two may require that new classes be loaded. Most Java Virtual Machine implementations will likely delay loading classes until they are actually used by the program. If an implementation does load classes earlier, perhaps in an attempt to speed up the loading process, then it must still give the impression that it is loading classes as late as possible. If, for example, a Java Virtual Machine discovers during early loading that it canít find a certain referenced class, it doesnít throw a &quot;class definition not found&quot; error until (and unless) the referenced class is used for the first time by the running program. Therefore, phase two, the checking of symbolic references, is usually delayed until each symbolic reference is actually used for the first time during bytecode execution.</P>
<P>Phase two of class file verification is really just part of the process of dynamic linking. When a class file is loaded, it contains symbolic references to other classes and their fields and methods. A symbolic reference is a character string that gives the name and possibly other information about the referenced item--enough information to uniquely identify a class, field, or method. Thus, symbolic references to other classes give the full name of the class; symbolic references to the fields of other classes give the class name, field name, and field descriptor; symbolic references to the methods of other classes give the class name, method name, and method descriptor.</P>
<P>Dynamic linking is the process of <I>resolving</I> symbolic references into direct references. As the Java Virtual Machine executes bytecodes and encounters an opcode that, for the first time, uses a symbolic reference to another class, the virtual machine must resolve the symbolic reference. The virtual machine performs two basic tasks during resolution:</P>
<OL><LI>find the class being referenced (loading it if necessary)</P>
<LI>replace the symbolic reference with a direct reference, such as a pointer or offset, to the class, field, or method</OL>
<P>The virtual machine remembers the direct reference so that if it encounters the same reference again later, it can immediately use the direct reference without needing to spend time resolving the symbolic reference again.</P>
<P>When the Java Virtual Machine resolves a symbolic reference, phase two of the class file verifier makes sure the reference is valid. If the reference is not valid--for instance, if the class cannot be loaded or if the class exists but doesnít contain the referenced field or method--the class file verifier throws an error.</P>
<P>As an example, consider again the <FONT FACE="Courier New">Volcano</FONT> class. If a method of class <FONT FACE="Courier New">Volcano</FONT> invokes a method in a class named <FONT FACE="Courier New">Lava</FONT>, the name and descriptor of the method in <FONT FACE="Courier New">Lava</FONT> are included as part of the binary data in the class file for <FONT FACE="Courier New">Volcano</FONT>. So, during the course of execution when the <FONT FACE="Courier New">Volcano</FONT>ís method first invokes the <FONT FACE="Courier New">Lava</FONT>ís method, the Java Virtual Machine makes sure a method exists in class <FONT FACE="Courier New">Lava</FONT> that has a name and descriptor that matches those expected by class <FONT FACE="Courier New">Volcano</FONT>. If the symbolic reference (class name, method name and descriptor) is correct, the virtual machine replaces it with a direct reference, such as a pointer, which it will use from then on. But if the symbolic reference from class <FONT FACE="Courier New">Volcano</FONT> doesnít match any method in class <FONT FACE="Courier New">Lava</FONT>, phase two verification fails, and the Java Virtual Machine throws a &quot;no such method&quot; error.</P>
<H3><P>Binary Compatibility</P>
</H3><P>The reason phase two of the class file verifier must look at classes that refer to one<H3> </H3>nother to make sure they are compatible is because Java programs are dynamically linked. Java compilers will often recompile classes that depend on a class you have changed, and in so doing, detect any incompatibility at compile-time. But there may be times when your compiler doesnít recompile a dependent class. For example, if you are developing a large system, you will likely partition the various parts of the system into packages. If you compile each package separately, then a change to one class in a package would cause a recompilation of affected classes within that same package, but not necessarily in any other package. Moreover, if you are using someone elseís packages, especially if your program downloads class files from someone elseís package across a network as it runs, it may be impossible for you to check for compatibility at compile-time. Thatís why phase two of the class file verifier must check for compatibility at run-time.</P>
<P>As an example of incompatible changes, imagine you compiled class <FONT FACE="Courier New">Volcano</FONT> (from the above example) with a Java compiler. Because a method in <FONT FACE="Courier New">Volcano</FONT> invokes a method in another class named <FONT FACE="Courier New">Lava</FONT>, the Java compiler would look for a class file or a source file for class <FONT FACE="Courier New">Lava</FONT> to make sure there was a method in <FONT FACE="Courier New">Lava</FONT> with the appropriate name, return type, and number and types of arguments. If the compiler couldnít find any <FONT FACE="Courier New">Lava</FONT> class, or if it encountered a <FONT FACE="Courier New">Lava</FONT> class that didnít contain the desired method, the compiler would generate an error and would not create a class file for <FONT FACE="Courier New">Volcano</FONT>. Otherwise, the Java compiler would produce a class file for <FONT FACE="Courier New">Volcano</FONT> that is compatible with the class file for <FONT FACE="Courier New">Lava</FONT>. In this case, the Java compiler refused to generate a class file for <FONT FACE="Courier New">Volcano</FONT> that wasnít already compatible with class <FONT FACE="Courier New">Lava</FONT>.</P>
<P>The converse, however, is not necessarily true. The Java compiler could conceivably generate a class file for <FONT FACE="Courier New">Lava</FONT> that isnít compatible with <FONT FACE="Courier New">Volcano</FONT>. If the <FONT FACE="Courier New">Lava</FONT> class doesnít refer to <FONT FACE="Courier New">Volcano</FONT>, you could potentially change the name of the method <FONT FACE="Courier New">Volcano</FONT> invokes from the <FONT FACE="Courier New">Lava</FONT> class, and then recompile only the <FONT FACE="Courier New">Lava</FONT> class. If you tried to run your program using the new version of <FONT FACE="Courier New">Lava</FONT>, but still using the old version of <FONT FACE="Courier New">Volcano</FONT> that wasnít recompiled since you made your change to <FONT FACE="Courier New">Lava</FONT>, the Java Virtual Machine would, as a result of phase two class file verification, throw a &quot;no such method&quot; error when <FONT FACE="Courier New">Volcano</FONT> attempted to invoke the now non-existent method in <FONT FACE="Courier New">Lava</FONT>.</P>
<P>In this case, the change to class <FONT FACE="Courier New">Lava</FONT> broke <I>binary compatibility</I> with the pre-existing class file for <FONT FACE="Courier New">Volcano</FONT>. In practice, this situation may arise when you update a library you have been using, and your existing code isnít compatible with the new version of the library. To make it easier to alter the code for libraries, the Java programming language was designed to allow you to make many kinds of changes to a class that donít require recompilation of classes that depend upon it. The changes you are allowed to make, which are listed in the Java Language Specification, are called the rules of binary compatibility. These rules clearly define what can be changed, added, or deleted in a class without breaking binary compatibility with pre-existing class files that depend on the changed class. For example, it is always a binary compatible change to add a new method to a class, but never to delete a method that other classes may be using. So in the case of <FONT FACE="Courier New">Lava</FONT>, you violated the rules of binary compatibility when you changed the name of the method used by <FONT FACE="Courier New">Volcano</FONT>, because you in effect deleted the old method and added a new. If you had, instead, added the new method and then rewritten the old method so it calls the new, that change would have been binary compatible with any pre-existing class file that already used <FONT FACE="Courier New">Lava</FONT>, including <FONT FACE="Courier New">Volcano</FONT>.</P>
<H3><EM><P>Safety Features Built Into the Java Virtual Machine</P>
</EM></H3><P>Once the Java Virtual Machine has loaded a class and performed phase one of class file verification, the bytecodes are ready to be executed. Besides the verification of symbolic references (phase two of class file verification), the Java Virtual Machine has several other built-in security mechanisms operating as bytecodes are executed. These are the same mechanisms listed in Chapter 1 as features of the Java programming language that make Java programs robust. They are, not surprisingly, also features of the Java Virtual Machine:</P>
<UL><LI> type-safe reference casting
<LI> structured memory access (no pointer arithmetic)
<LI> automatic garbage collection (canít explicitly free allocated memory)
<LI> array bounds checking
<LI> checking references for <FONT FACE="Courier New">null</FONT></UL>
<P>By granting a Java program only safe, structured ways to access memory, the Java Virtual Machine makes Java programs more robust, but it also makes their execution more secure. Why? There are two reasons. First, a program that corrupts memory, crashes, and possibly causes other programs to crash represents one kind of security breach. If you are running a mission critical server process, it is critical that the process doesnít crash. This level of robustness is also important in embedded systems, such as a cell phone, which people donít usually expect to have to reboot. The second reason unrestrained memory access would be a security risk is because a wily cracker could potentially use it to subvert the security system. If, for example, a cracker could learn where in memory a class loader is stored, it could assign a pointer to that memory and manipulate the class loaderís data. By enforcing structured access to memory, the Java Virtual Machine yields programs that are robust, but also frustrates crackers who dream of harnessing the internal memory of the Java Virtual Machine for their own devious plots.</P>
<P>Another safety feature built into the Java Virtual Machine--one that serves as a backup to structured memory access--is the unspecified manner in which the runtime data areas are laid out inside the Java Virtual Machine. The <I>runtime data areas</I> are the memory areas in which the Java Virtual Machine stores the data it needs to execute a Java application: Java stacks (one for each thread), a <I>method area</I>, where bytecodes are stored, and a <I>garbage-collected heap</I>, where the objects created by the running program are stored. If you peer into a class file, you wonít find any memory addresses. When the Java Virtual Machine loads a class file, it decides where in its internal memory to put the bytecodes and other data it parses from the class file. When the Java Virtual Machine starts a thread, it decides where to put the Java stack it creates for the thread. When it creates a new object, it decides where in memory to put the object. Thus, a cracker cannot predict by looking at a class file where in memory the data representing that class, or objects instantiated from that class, will be kept. Whatís worse (for the cracker) is the cracker canít tell anything about memory layout by reading the Java Virtual Machine specification either. The manner in which a Java Virtual Machine lays out its internal data is not part of the specification. The designers of each Java Virtual Machine implementation decide which data structures their implementation will use to represent the runtime data areas, and where in memory their implementation will place them. As a result, even if a cracker were somehow able to break through the Java Virtual Machineís memory access restrictions, they would next be faced with the difficult task of finding something to subvert by looking around.</P>
<P>The prohibition on unstructured memory access is not something the Java Virtual Machine must actively enforce on a running program; rather, it is intrinsic to the bytecode instruction set itself. Just as there is no way to express an unstructured memory access in the Java programming language, there is also no way to express it in bytecodes--even if you write the bytecodes by hand. Thus, the prohibition on unstructured memory access is a solid barrier against the malicious manipulation of memory.</P>
<P>There is, however, a way to penetrate the security barriers erected by the Java Virtual Machine.  Although the bytecode instruction set doesnít give you an unsafe, unstructured way to access memory, there is a way you can go around bytecodes: native methods. Basically, when you call a native method, Javaís security sandbox becomes dust in the wind. First of all, the robustness guarantees donít hold for native methods. Although you canít corrupt memory from a Java method, you can from a native method. But most importantly, native methods donít go through the Java API (they are how you go around the Java API) so the security manager isnít checked before a native method attempts to do something that could be potentially damaging. (This is, of course, often how the Java API itself gets anything done. But the native methods used by the Java API are &quot;trusted.&quot;) Thus, once a thread gets into a native method, no matter what security policy was established inside the Java Virtual Machine, it doesnít apply anymore to that thread, so long as that thread continues to execute the native method. This is why the security manager includes a method that establishes whether or not a program can load dynamic libraries, which are necessary for invoking native methods. Applets, for example, arenít allowed to load a new dynamic library, therefore they canít install their own new native methods. They can, however, call methods in the Java API, methods which may be native, but which are always trusted. When a thread invokes a native method, that thread leaps outside the sandbox. The security model for native methods is, therefore, the same security model described earlier as the traditional approach to computer security: you have to trust a native method before you call it.</P>
<P>One final mechanism that is built into the Java Virtual Machine that contributes to security is structured error handling with exceptions. Because of its support for exceptions, the Java Virtual Machine has something structured to do when a security violation occurs. Instead of crashing, the Java Virtual Machine can throw an exception or an error, which may result in the death of the offending thread, but shouldnít crash the system. Throwing an error (as opposed to throwing an exception) almost always results in the death of the thread in which the error was thrown. This is usually a major inconvenience to a running Java program, but wonít necessarily result in termination of the entire program. If the program has other threads doing useful things, those threads may be able to carry on without their recently departed colleague. Throwing an exception, on the other hand, may result in the death of the thread, but is often just used as a way to transfer control from the point in the program where the exception condition arose to the point in the program where the exception condition is handled.</P>
<H3><EM><P>The Security Manager and the Java API</P>
</EM></H3><P>By using class loaders, you can prevent code loaded by different class loaders from interfering with one another inside the Java Virtual Machine, but to protect assets external to the Java Virtual Machine, you must use a security manager. The security manager defines the outer boundaries of the sandbox. Because it is customizable, the security manager allows you to establish a custom security policy for an application. The Java API enforces the custom security policy by asking the security manager for permission before it takes any action that is potentially unsafe. For each potentially unsafe action, there is a method in the security manager that defines whether that action is allowed by the sandbox. Each methodís name starts with &quot;check,&quot; so for example, <FONT FACE="Courier New">checkRead()</FONT>defines whether or not a thread is allowed to read to a specified file, and <FONT FACE="Courier New">checkWrite()</FONT>defines whether or not a thread is allowed to write to a specified file.  The implementation of these methods is what defines the custom security policy of the application.</P>
<P>Most of the activities that are regulated by a &quot;check&quot; method are listed below. The classes of the Java API check with the security manager before they:</P>
<UL><LI> accept a socket connection from a specified host and port number
<LI> modify a thread (change its priority, stop it, etcÖ)
<LI> open a socket connection to a specified host and port number
<LI> create a new class loader
<LI> delete a specified file
<LI> create a new process
<LI> cause the application to exit
<LI> load a dynamic library that contains native methods
<LI> wait for a connection on a specified local port number
<LI> load a class from a specified package (used by class loaders)
<LI> add a new class to a specified package (used by class loaders)
<LI> access or modify system properties
<LI> access a specified system property
<LI> read from a specified file
<LI> write to a specified file</UL>
<P>Because the Java API always checks with the security manager before it performs any of the activities listed above, the Java API will not perform any action forbidden under the security policy established by the security manager.</P>
<P>Two actions not present in the above list that could potentially be unsafe are allocation of memory and invocation of threads. Currently, a hostile applet that can possibly crash the browser by:</P>
<UL><LI> allocating memory until it runs out
<LI> firing off threads until everything slows to a crawl</UL>
<P>These kinds of attacks are called <I>denial of service</I>, because the deny the end-users from using their own computers. The security manager does not allow you to enforce any kind of limit on allocated memory or thread creation. (There are no <FONT FACE="Courier New">checkAllocateMemory()</FONT> or <FONT FACE="Courier New">checkCreateThread()</FONT> methods in the security manager class.) The difficulty in attempting to thwart this kind of hostile code is that it is hard to tell the difference, for example, between a hostile applet allocating a lot of memory and an image processing applet attempting to do useful work. Other kinds of hostile applets that are currently possible are:
<UL><LI> applets that send unauthorized e-mail from the end-userís computer
<LI> applets that make annoying noises even after you leave the web page
<LI> applets that display offensive images or animations</UL>
<P>So a security manager isnít enough to prevent every possible action that could possibly offend or inconvenience an end-user. Other than the attacks listed here, however, the security manager attempts to provide a check method that allows you to control access to any potentially unsafe action.</P>
<P>When a Java application starts, it has no security manager, but the application can install one at its option. If it does not install a security manager, there are no restrictions placed on any activities requested of the Java API--the Java API will do whatever it is asked. (This is why Java applications, by default, do not have any security restrictions such as those that limit the activities of untrusted applets.) If the application does install a security manager, then that security manager will be in charge for the entire remainder of the lifetime of that application. It canít be replaced, extended, or changed. From that point on, the Java API will only fulfill those requests that are sanctioned by the security manager.</P>
<P>In general, a &quot;check&quot; method of the security manager throws a security exception if the checked upon activity is forbidden, and simply returns if the activity is permitted. Therefore, the procedure a Java API method generally follows when it is about to perform a potentially unsafe activity involves two steps. First, the Java API code checks whether a security manager has been installed. If not, it skips step two and goes ahead with the potentially unsafe action. Otherwise, as step two, it calls the appropriate &quot;check&quot; method in the security manager. If the action is forbidden, the &quot;check&quot; method will throw a security exception, which will cause the Java API method to immediately abort. The potentially unsafe action will never be taken. If, on the other hand, the action is permitted, the &quot;check&quot; method will simply return. In this case, the Java API method carries on and performs the potentially unsafe action.</P>
<P>Although you can only install one security manager, you can write the security manager so that it establishes multiple security policies. In addition to the &quot;check&quot; methods, the security manager also has methods that allow you to determine if a request is being made either directly or indirectly from a class loaded by a class loader object, and if so, which class loader object. This enables you to implement a security policy that varies depending upon which class loader loaded the classes making the request. You can also vary the security policy based on information about the class files loaded by the class loader, such whether or not the class files were down loaded across a network or imported from the local disk. So even though an application can only have one security manager, that security manager can establish a flexible security policy that varies depending upon the trustworthiness of the code requesting the potentially unsafe action.</P>
<H3><EM><P>Authentication</P>
</EM></H3><P>The support for authentication introduced in Java 1.1 in the <FONT FACE="Courier New">java.security</FONT> package expands your ability to establish multiple security policies by enabling you to implement a sandbox that varies depending upon who actually created the code. Authentication allows you to verify that a set of class files was blessed as trustworthy by some vendor, and that the class files were not altered en route to your virtual machine. Thus, to the extent you trust the vendor, you can ease the restrictions placed on the code by the sandbox. You can establish different security policies for code that comes from different vendors.</P>
<P>For links to more information about authentication and <FONT FACE="Courier New">java.security</FONT>, visit the resources page for this chapter.</P>
<H3><EM><P>Security Beyond the Architecture</P>
</EM></H3><P>Security is a tradeoff between cost and risk: the lower the security risk, the higher the cost of security. The costs associated with any computer or network security strategy must be weighed against the costs that would be associated with the theft or destruction of the information or computing resources being protected. The nature of a computer or network security strategy should be shaped by the value of the assets being protected.</P>
<P>To be effective, a computer or network security strategy must be comprehensive. It cannot consist exclusively of a sandbox for running downloaded Java code. For instance, it may not matter much that the Java applets you download from the internet and run on your computer canít read the word processing file of your top-secret business plan if you:</P>
<UL><LI> routinely download untrusted native executables from the internet and run them
<LI> throw away extra printed copies of your business plan without shredding them
<LI> leave your doors unlocked when youíre gone
<LI> hire someone to help you who is actually a spy for your arch-rival</UL>
<P>In the context of a comprehensive security strategy, however, Javaís security model can play a useful role.</P>
<P>The nice thing about Javaís security model is that once you set it up, it does most of the work for you. You donít have to worry about whether a particular program is trusted or not--the Java runtime will determine that for you; and if it is untrusted, the Java runtime will protect your assets by encasing the untrusted code in a sandbox.</P>
<P>End-users of Java software cannot rely only on the security mechanisms built into Javaís architecture. They must have a comprehensive security policy appropriate to their actual security requirements.</P>
<P>Similarly, the security strategy of Java technology itself does not rely exclusively on the architectural security mechanisms described in this chapter. For example, one aspect of Javaís security strategy is that anyone can sign a license agreement and get a copy of the source code of Sunís Java Platform implementation. Instead of keeping the internal implementation of Javaís security architecture a secret &quot;black box,&quot; it is open to anyone who wishes to look at it. This encourages security experts seeking a good technical challenge to try and find security holes in the implementation. When security holes are discovered, they can be patched. Thus, the openness of Javaís internal implementation is part of Javaís overall security strategy.</P>
<P>Besides openness, there are several other aspects to Javaís overall security strategy that donít directly involve its architecture. You can find out more information about these on the resources page for this chapter. </P>
<H3><EM><P>The Resources Page</P>
</EM></H3><P>For more information about Java and security, see the resource page for this chapter: <FONT FACE="Courier New"><A HREF="http://www.artima.com/insidejvm/security.html" tppabs="http://www.artima.com/insidejvm/security.html">http://www.artima.com/insidejvm/security.html</A></FONT>.</P></BODY>
<TABLE BORDER="0" WIDTH="100%">
<TR><TD><A HREF="http://www.pbg.mcgraw-hill.com/betabooks/stores.html" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/stores.html" target="bottom"><IMG SRC="hotkey.gif" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/images/hotkey.gif" ALIGN="LEFT" BORDER="0" WIDTH="40" HEIGHT="40" ALT="Orders"></A>
<IMG SRC="order_text.gif" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/images/order_text.gif" WIDTH="103" HEIGHT="41" ALT="Orders"></TD>
<TD ALIGN="RIGHT"><A HREF="chap02.html" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/venners/chap02.html"><IMG SRC="backward.gif" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/images/backward.gif" BORDER="0" ALT="Backward" WIDTH="32" HEIGHT="32"></A>&nbsp;<A HREF="chap04.html" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/venners/chap04.html"><IMG SRC="forward.gif" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/images/forward.gif" BORDER="0" ALT="Forward" WIDTH="32" HEIGHT="32"></A></TD></TR>
<TR><TD COLSPAN="2"><A HREF="mailto:computing@mcgraw-hill.com"><IMG SRC="hotkey.gif" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/images/hotkey.gif" ALIGN="LEFT" BORDER="0" WIDTH="40" HEIGHT="40" ALT="Comments"></A>
<IMG SRC="comment_text.gif" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/images/comment_text.gif" WIDTH="73" HEIGHT="39" ALT="Comments"></TD></TR>

</TABLE>
<HR>
<P ALIGN=CENTER>&nbsp;<A HREF="http://www.pbg.mcgraw-hill.com/computing/computing-home.html" tppabs="http://www.pbg.mcgraw-hill.com/computing/computing-home.html" TARGET="_top">COMPUTING
MCGRAW-HILL</A> | <A HREF="http://www.pbg.mcgraw-hill.com/betabooks/betabooks-home.html" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/betabooks-home.html" TARGET="_top">Beta Books</A>
| <A HREF="http://www.pbg.mcgraw-hill.com/computing/contact.html" tppabs="http://www.pbg.mcgraw-hill.com/computing/contact.html" TARGET="_top">Contact Us</A>
| <A HREF="http://www.pbg.mcgraw-hill.com/betabooks/stores.html" tppabs="http://www.pbg.mcgraw-hill.com/betabooks/stores.html" TARGET="_top">Order Information</A>
| <A HREF="http://mcgraw-hill.inforonics.com/compsearch.shtml" tppabs="http://mcgraw-hill.inforonics.com/compsearch.shtml" TARGET="_top">Online Catalog</A></P>

<P ALIGN=CENTER><FONT SIZE="-1"><A HREF="http://www.pbg.mcgraw-hill.com/computing/computing-home.html" tppabs="http://www.pbg.mcgraw-hill.com/computing/computing-home.html" TARGET="_top">Computing McGraw-Hill</A> is an imprint of the <A HREF="http://www.pbg.mcgraw-hill.com/pbg-home.html" tppabs="http://www.pbg.mcgraw-hill.com/pbg-home.html" TARGET="_top">McGraw-Hill Professional Book Group</A>.</FONT></P>

<!-- begin footer -->
<HR>
<A HREF="http://www.mcgraw-hill.com/" tppabs="http://www.mcgraw-hill.com/" TARGET="_top"><IMG SRC="division-white.gif" tppabs="http://www.pbg.mcgraw-hill.com/images/division-white.gif" WIDTH="350" HEIGHT="44" ALT="A Division of the McGraw-Hill Companies" BORDER="0"></A><BR>
<FONT SIZE="-2">Copyright &copy; 1997 <A HREF="http://www.mcgraw-hill.com/" tppabs="http://www.mcgraw-hill.com/" TARGET="_top">
The McGraw-Hill Companies</A>. All rights reserved. Any use is subject to the 
<A HREF="http://www.mcgraw-hill.com/corporate/news_info/copyrttm.htm" tppabs="http://www.mcgraw-hill.com/corporate/news_info/copyrttm.htm" TARGET="_top">
Terms of Use</A>; the corporation also has a comprehensive <A HREF="http://www.mcgraw-hill.com/corporate/news_info/privacy.html" tppabs="http://www.mcgraw-hill.com/corporate/news_info/privacy.html" TARGET="_top">
Privacy Policy</A> governing information we may collect from our customers.</FONT>
<!-- end footer -->
</BODY>
</HTML>
